<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SkyFly</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ufolux.github.io/"/>
  <updated>2021-03-16T10:32:36.619Z</updated>
  <id>https://ufolux.github.io/</id>
  
  <author>
    <name>Sines</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>macOS 11 环境下 LLVM 11.0 构建和安装</title>
    <link href="https://ufolux.github.io/2021/03/16/llvm/learning-llvm-11-01/"/>
    <id>https://ufolux.github.io/2021/03/16/llvm/learning-llvm-11-01/</id>
    <published>2021-03-16T09:27:43.000Z</published>
    <updated>2021-03-16T10:32:36.619Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近在研究 VMP 相关的东西，看来最终还是要搞一搞 LLVM 这个大家伙，还蛮有趣的，下面直入主题。</p><span id="more"></span><h2 id="0x00-从源码构建，安装"><a href="#0x00-从源码构建，安装" class="headerlink" title="0x00 从源码构建，安装"></a>0x00 从源码构建，安装</h2><p>我用的是 M1 芯片的 macbook pro, 系统版本为 macOS 11.2.3</p><p>首先从 <a href="https://releases.llvm.org/download.html#git">官网</a> 下载源码</p><p>这里我选择下载全部的组件，也就是 <a href="https://github.com/llvm/llvm-project/releases/download/llvmorg-11.0.0/llvm-project-11.0.0.tar.xz">lvm-project monorepo source code</a> 这个代码。</p><p>这里为了方便，假设这个源码目录叫做 <code>llvm11</code> </p><p>在 <code>llvm11</code> 的同级目录中创建两个目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir b</span><br><span class="line">mkdir i</span><br></pre></td></tr></table></figure><p><code>b</code> 用来存放构建需要的文件，<code>i</code> 是最终的安装目录。</p><p>进入 <code>b</code> 目录，下面开始构建，我选择构建 Release 版本，开启 Assertion。并且同时需要构建 clang：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd b</span><br><span class="line">cmake ..&#x2F;llvm-project-11.0.0&#x2F;llvm&#x2F; -DCMAKE_BUILD_TYPE&#x3D;Release -DLLVM_ENABLE_ASSERTIONS&#x3D;ON  -DLLVM_ENABLE_PROJECTS&#x3D;clang </span><br><span class="line">cmake --build . -- -j 8</span><br></pre></td></tr></table></figure><p>构建的时间会很长，取决于你电脑的配置，一般需要三四十分钟以上（不得不夸下 Apple M1，20 来分钟搞定）。</p><p>构建成功之后进行安装，这里建议配置一个安装目录的环境变量，方便后续使用 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 当前目录 b</span><br><span class="line"># 进入上一级目录</span><br><span class="line">cd ..</span><br><span class="line">export LLVM_HOME&#x3D;&#96;pwd&#96;&#x2F;i</span><br><span class="line">cd b</span><br><span class="line">cmake -DCMAKE_INSTALL_PREFIX&#x3D;$LLVM_HOME -P cmake_install.cmake</span><br></pre></td></tr></table></figure><p>大功告成</p><h2 id="0x01-验证"><a href="#0x01-验证" class="headerlink" title="0x01 验证"></a>0x01 验证</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;tmp</span><br><span class="line">&#x2F;tmp $LLVM_HOME&#x2F;bin&#x2F;clang -v</span><br><span class="line">clang version 11.0.0</span><br><span class="line">Target: arm64-apple-darwin20.3.0</span><br><span class="line">Thread model: posix</span><br><span class="line">InstalledDir: &#x2F;Users&#x2F;sines&#x2F;Code&#x2F;LLVMs&#x2F;11.0.0&#x2F;i&#x2F;bin</span><br><span class="line"></span><br><span class="line">&#x2F;tmp $LLVM_HOME&#x2F;bin&#x2F;clang --sysroot &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;MacOSX.platform&#x2F;Developer&#x2F;SDKs&#x2F;MacOSX11.1.sdk  &#x2F;tmp&#x2F;test.c</span><br><span class="line">&#x2F;tmp .&#x2F;a.out    </span><br><span class="line">Hello World!  </span><br></pre></td></tr></table></figure><p>Ok, works fine, 基础搭好了，可以在它上面干活啦</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在研究 VMP 相关的东西，看来最终还是要搞一搞 LLVM 这个大家伙，还蛮有趣的，下面直入主题。&lt;/p&gt;
    
    </summary>
    
      <category term="llvm" scheme="https://ufolux.github.io/categories/llvm/"/>
    
      <category term="PL" scheme="https://ufolux.github.io/categories/llvm/PL/"/>
    
      <category term="VM" scheme="https://ufolux.github.io/categories/llvm/PL/VM/"/>
    
      <category term="Compiler" scheme="https://ufolux.github.io/categories/llvm/PL/VM/Compiler/"/>
    
    
      <category term="llvm" scheme="https://ufolux.github.io/tags/llvm/"/>
    
  </entry>
  
  <entry>
    <title>Concurrent Programming Concepts Review</title>
    <link href="https://ufolux.github.io/2021/03/11/OS/concurrent-programming-concepts-review/"/>
    <id>https://ufolux.github.io/2021/03/11/OS/concurrent-programming-concepts-review/</id>
    <published>2021-03-11T07:31:17.000Z</published>
    <updated>2021-03-16T10:34:59.672Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>As a Chinese old saying goes: Review the old and know the new (温故而知新). I learnt a lot from the OS class, recently, despite that I have taken this class 5 years ago during my undergraduate study. The latest topic discussed on the class is concurrency and deadlock, I think it is a good time for me to review some concepts of concurrent programming.</p><span id="more"></span><h2 id="Mutual-Exclusion-Synchornization-Methods"><a href="#Mutual-Exclusion-Synchornization-Methods" class="headerlink" title="Mutual Exclusion / Synchornization Methods"></a>Mutual Exclusion / Synchornization Methods</h2><h3 id="Mutual-Exclusion-VS-Synchornization"><a href="#Mutual-Exclusion-VS-Synchornization" class="headerlink" title="Mutual Exclusion VS Synchornization"></a>Mutual Exclusion VS Synchornization</h3><ol><li><p>Mutual Exclusion: There is a critical section (process can write shared data here) that allows only one process to enter. To ensure there is no other process enter this area, some measures should be applied here which called mutual exclusion.</p></li><li><p>Synchornization: A process can only execute when others finish their work. So we should take some actions to guarantee this, which are synchornization methods. </p></li></ol><h3 id="Busy-Waiting"><a href="#Busy-Waiting" class="headerlink" title="Busy Waiting"></a>Busy Waiting</h3><h4 id="Disabling-Interrupts"><a href="#Disabling-Interrupts" class="headerlink" title="Disabling Interrupts"></a>Disabling Interrupts</h4><p>The crucial problem for busy waiting is how to ensure the critical region can not be entered by two different processes at a time. As we known, preemption happens with interrupts. If we disable interrupts temporarily when there is a process enter the critical section, this problem can be solved. But only <strong>on single processor system</strong>. </p><p>On <strong>multi-processor system</strong> this does not work, because interrupts can only be disabled on one of the processors. Processses running on other processor can still enter the critical section simultaneously.</p><h4 id="Lock-Variable"><a href="#Lock-Variable" class="headerlink" title="Lock Variable"></a>Lock Variable</h4><p>It is a very simple solution to this problem. Check if the lock variable is 0, continuously. If it becomes 0, set it to 1, and enter the critical region. When it finishes, reset the lock variable to 0, so that other waiting process can enter the critical section.</p><p>But this can not work as expected, because you can’t perform the set lock operation atomically. There are changces for other processes modify the lock variable at the same time. The solution is not work either.</p><h4 id="TSL-Test-and-Set-Lock"><a href="#TSL-Test-and-Set-Lock" class="headerlink" title="TSL (Test and Set Lock)"></a>TSL (Test and Set Lock)</h4><p>This is a hardware supported primitive. Using lock variable needs set and read lock variable atomically, which means no other operation can interrupt the lock setting procedure. Most of CPUs implement the TSL instruction to support this function. TSL means test and set lock. CPU will first lock the memory bus to prohibit other CPUs from accessing memory, then copy the lock value into register and store a non-zero value to lock variable. So this guarantees the operation is indivisable.</p><h4 id="XCHG-Exchange"><a href="#XCHG-Exchange" class="headerlink" title="XCHG (Exchange)"></a>XCHG (Exchange)</h4><p>It is an alternative atomic instruction for TSL. Just like its name, XCHG will exchange the value in a resgister with value in memory (lock variable).</p><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>Busy waiting with TSL and XCHG can solve the problem, but they are not efficient enough. Busy waiting consumes a lot of CPU resources to check whether the lock varaible is available.</p><p>Semaphore is not like busy waiting, it does not run the checking procedure continuously. Instead, semaphore mechanism uses <em>sleep</em> and <em>wakeup</em> to make it work. </p><p>semaphore is a variable indicating how many processes can perform action. value of semaphore could be 0 or greater than 0. When a process want to perform action, it should decrease the semaphore by 1. When it finishes its work, it becomes ready and increases the semaphore by 1. When the semaphore is 0, which means nobody can perform action at this time, the process will be put into <code>sleep</code> by scheduler. Util the semaphore becomes greater than 0, scheduler will randomly wakes up that number of sleeping processes doing its job.</p><p>The decrement and increament operations are named P, V (Proberen (try) and Verhogen (raise, make higher) in Dutch, because its inventor, Dijkstra, is from Netherlands) operations. It is essential for ensuring these operations are atomic. So usually implementations apply TSL and XCHG for these operations to promise atomicity.</p><p>eg: Producer and Consumer Problem</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#define N 100 &#x2F;&#x2F; N slots in the buffer</span><br><span class="line">item buff[N]; &#x2F;&#x2F; buffer slots</span><br><span class="line">typedef int semaphore;</span><br><span class="line">semaphore mutex &#x3D; 1;</span><br><span class="line">semaphore empty &#x3D; N;</span><br><span class="line">semaphore full &#x3D; 0;</span><br><span class="line"></span><br><span class="line">void Producer() &#123;</span><br><span class="line">    while(True) &#123;</span><br><span class="line">        item ele &#x3D; produceEle(); &#x2F;&#x2F; produce element</span><br><span class="line">        P(empty); &#x2F;&#x2F; decrease number of empty semaphore</span><br><span class="line">        P(mutex);</span><br><span class="line">        insertElem(ele, buff); &#x2F;&#x2F; insert element into buffer slot.</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full); &#x2F;&#x2F; increase number of full semaphore</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Consumer() &#123;</span><br><span class="line">    while(True) &#123;</span><br><span class="line">        P(full); &#x2F;&#x2F; decrease number of full semaphore</span><br><span class="line">        P(mutex);</span><br><span class="line">        item ele &#x3D; removeEle(buff); &#x2F;&#x2F; remove element from buffer</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty); &#x2F;&#x2F; increase number of empty semaphore</span><br><span class="line">        consumeEle(); &#x2F;&#x2F; consume the element</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h4><p>As we see in the code sniplet before, when the value of semaphore are only 0 or 1, it is called a binary-semaphore, or a mutex which could be used for mutual exclusion and synchornization.</p><h4 id="Futex"><a href="#Futex" class="headerlink" title="Futex"></a>Futex</h4><p>Every <em>lock</em> and <em>unlock</em> operation will first trap into kernel by sycalls to check if the lock variable is owned by others. But, in reality, most of time the lock variable does not belongs to anyone.It is usually free for processes to enter the critical section, but the test lock procedure still cost a lot by doing a syscall. To make this more efficiency, futex were created.</p><p>Futex stands for “Fast Userspace muTexes”, which, basically, does the lock test procedure in user space. Only when the lock is not free, it performs a syscall. That’s why futex improves performance a lot.</p><h4 id="Condition-Variables"><a href="#Condition-Variables" class="headerlink" title="Condition Variables"></a>Condition Variables</h4><p>Condition Variables is a synchornization mechanism. Synchornization needs more than just mutual exclusion; also need a way to wait for another thread to do something (e.g., wait for a character to be added to the buffer). So, it provides a way to make process wait util the specific condition is fullfilled.</p><h2 id="Which-Lock-Should-I-Use"><a href="#Which-Lock-Should-I-Use" class="headerlink" title="Which Lock Should I Use"></a>Which Lock Should I Use</h2><p>Which Lock should I use, busy waiting or semaphores? There are two simple principles:</p><ol><li><p>If lock hold time is short or task is uninterruptable, busy waiting and lock variables are OK (Linux kernel always use it).</p></li><li><p>Else use semaphores.</p></li></ol><h2 id="Deadlock-VS-Starvation"><a href="#Deadlock-VS-Starvation" class="headerlink" title="Deadlock VS Starvation"></a>Deadlock VS Starvation</h2><p>These two concepts are usually confusing. Basically, <strong>Deadlock</strong> happens when processes are waiting on events or resources that will never come. It can be on only one process or system wide. And in this case, no process can go further.</p><p>Under <strong>Starvation</strong>, some process can move forward, but there does have some process(es) can not be excuted. Because, there is no resource available for them to access, due to scheduling reason.</p><p>For an instance, if the process scheduler always process short execution time process first (SRTF), the long run time process may have no changce to be executed, if there always comes short time tasks. Then, a starvation happened.</p><h2 id="How-Does-Deadlock-Happen"><a href="#How-Does-Deadlock-Happen" class="headerlink" title="How Does Deadlock Happen"></a>How Does Deadlock Happen</h2><p>When a process A need a resource to move forward, but that resource is held by process B. At the meantime, process B is also waiting for the resource held by A.</p><p>If the resource is like memory, which can be preempted, deadlock will not happen. But, if it is a non-preemptable resource, like a Blu-ray recorder, deadlock will happen.</p><p>There are 4 essential conditions for deadlock:</p><ol><li>Each resource is either currently assigned to exactly one process or is available.</li><li>Processes currently holding resources that were granted earlier can request new resources.</li><li>Resources previously granted cannot be forcibly taken away from a process. They must be explicitly released by the process holding them.</li><li>There must be a circular chain of two or more processes, each of which is waiting for a resource held by the next member of the chain.</li></ol><h2 id="Deadlock-Detection"><a href="#Deadlock-Detection" class="headerlink" title="Deadlock Detection"></a>Deadlock Detection</h2><p>Basically, the algorithm to detect deadlock is to detect cycles in the resource allocation graph.</p><p>For Each node N in the graph do:</p><ol><li>Initialize L to empty list and designate all arcs as unmarked</li><li>Add the current node to end of L. If the node appears in L twice then we have a cycle and the algorithm terminates</li><li>From the given node pick any unmarked outgoing arc. If none is available go to 5.</li><li>Pick an outgoing arc at random and mark it. Then follow it to the new current node and go to 2.</li><li>If the node is the initial node then no cycles and the algorithm terminates. Otherwise, we are in dead end. Remove that node and go back to the previous one. Go to 2.</li></ol><h2 id="Deadlock-Prevention"><a href="#Deadlock-Prevention" class="headerlink" title="Deadlock Prevention"></a>Deadlock Prevention</h2><p>If one of the 4 essential conditions can’t be reached, deadlock is impossible structurally.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li><a href="https://web.stanford.edu/~ouster/cgi-bin/cs140-spring14/lecture.php?topic=locks">https://web.stanford.edu/~ouster/cgi-bin/cs140-spring14/lecture.php?topic=locks</a></li><li>Modern Operating Systems 4th Edition–Andrew Tanenbaum.pdf Section 2.3 and 6</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Background&quot;&gt;&lt;a href=&quot;#Background&quot; class=&quot;headerlink&quot; title=&quot;Background&quot;&gt;&lt;/a&gt;Background&lt;/h2&gt;&lt;p&gt;As a Chinese old saying goes: Review the old and know the new (温故而知新). I learnt a lot from the OS class, recently, despite that I have taken this class 5 years ago during my undergraduate study. The latest topic discussed on the class is concurrency and deadlock, I think it is a good time for me to review some concepts of concurrent programming.&lt;/p&gt;
    
    </summary>
    
      <category term="OS" scheme="https://ufolux.github.io/categories/OS/"/>
    
      <category term="Linux" scheme="https://ufolux.github.io/categories/OS/Linux/"/>
    
      <category term="English" scheme="https://ufolux.github.io/categories/OS/Linux/English/"/>
    
    
      <category term="OS" scheme="https://ufolux.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Different Behavior on getopt</title>
    <link href="https://ufolux.github.io/2021/03/09/C++/different-getopt-behavior/"/>
    <id>https://ufolux.github.io/2021/03/09/C++/different-getopt-behavior/</id>
    <published>2021-03-09T12:30:47.000Z</published>
    <updated>2021-03-16T10:36:14.444Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Backgound"><a href="#Backgound" class="headerlink" title="Backgound"></a>Backgound</h2><p>Recently, I started my master’s study on computer science at NYU. Going back to school life is amazing for me, but at meantime I have to deal with assignments and labs. For me, labs are more interesting than lectures. On doing one of my labs, I met a issue related to today’s topic – <code>getopt</code></p><span id="more"></span><p><code>getopt</code> is a convinent tool helping us handle the command-line arguments. I also use it to parse arguments for my lab’s program which has 4 arguments: “-a -v file1 file2”. The code is like this:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">while</span>((c = getopt(argc, argv, <span class="string">&quot;va&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;v&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *file1 = argv[optind];</span><br><span class="line">    <span class="built_in">puts</span>(file1);</span><br><span class="line">    <span class="keyword">char</span> *file2 = argv[optind + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">puts</span>(file2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>I want all options are to be correct, no matter what order it is in. But when I ran it with my MacBook Pro, I notice that <code>getopt</code> didn’t not work as expected on the circumstance below:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># On MacOS</span><br><span class="line">$ a.out -a file1 -v file2</span><br><span class="line"></span><br><span class="line"># output</span><br><span class="line">a</span><br><span class="line">file1</span><br><span class="line">-v</span><br></pre></td></tr></table></figure><p>I can only get <code>-a</code> option from <code>getopt</code>, then <code>file1</code> and <code>-v</code> as free arguments from <code>argv</code> by <code>optind</code> pointer. The <code>file2</code> option is missing.</p><p>But, why?</p><h2 id="Same-Name-but-Diff-Thing"><a href="#Same-Name-but-Diff-Thing" class="headerlink" title="Same Name but Diff Thing"></a>Same Name but Diff Thing</h2><p>The first thing I thought of is test this code on Ubuntu, and it just ran as I expected (I got all options from <code>getopt</code>). </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># On Ubuntu</span><br><span class="line">$ a.out -a file1 -v file2</span><br><span class="line"></span><br><span class="line"># output</span><br><span class="line">a</span><br><span class="line">v</span><br><span class="line">file1</span><br><span class="line">file2</span><br></pre></td></tr></table></figure><p>There must be something different between these two. After searching, The <a href="https://linux.die.net/man/3/getopt">Linux Document</a> gave the clear explaination about this:</p><blockquote><p>By default, getopt() permutes the contents of argv as it scans, so that eventually all the nonoptions are at the end. Two other modes are also implemented. If the first character of optstring is ‘+’ or the environment variable POSIXLY_CORRECT is set, then option processing stops as soon as a nonoption argument is encountered.</p></blockquote><p>Basically, <code>getopt</code> on Ubuntu is a linux specific version, which is “enhanced”. But on macOS, it is still the BSD/POSIX version. It behaves like the document says that the option processing will stop when the first free argument (the argument not start with ‘-‘) appears. All other arguments after that can only be achieve by <code>argv</code> and <code>optind</code> pointer.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Backgound&quot;&gt;&lt;a href=&quot;#Backgound&quot; class=&quot;headerlink&quot; title=&quot;Backgound&quot;&gt;&lt;/a&gt;Backgound&lt;/h2&gt;&lt;p&gt;Recently, I started my master’s study on computer science at NYU. Going back to school life is amazing for me, but at meantime I have to deal with assignments and labs. For me, labs are more interesting than lectures. On doing one of my labs, I met a issue related to today’s topic – &lt;code&gt;getopt&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://ufolux.github.io/categories/Linux/"/>
    
      <category term="C" scheme="https://ufolux.github.io/categories/Linux/C/"/>
    
      <category term="C++" scheme="https://ufolux.github.io/categories/Linux/C/C/"/>
    
    
      <category term="getopt" scheme="https://ufolux.github.io/tags/getopt/"/>
    
  </entry>
  
  <entry>
    <title>探究 Java HashMap get 操作的时间复杂度</title>
    <link href="https://ufolux.github.io/2020/02/25/Java/HashMapTimeComplexity/"/>
    <id>https://ufolux.github.io/2020/02/25/Java/HashMapTimeComplexity/</id>
    <published>2020-02-25T10:15:51.000Z</published>
    <updated>2021-03-16T10:36:38.749Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>最近刷 leetcode，又回去回顾了很多数据结构的知识。刷题时经常会碰到使用 <code>HashMap</code> 来实现 <code>O(1)</code> 时间内的元素快速查找，以空间换时间。Hash 表的基本原理就是对 key 进行哈希运算得出 HasCode，然后通过对 HashCode 进行变换得到数组的 index。最后将 value 插入到该 index 位置上。但实际上，并不存在完美的散列算法能使得对于每个不同的输入值都能得到独一无二的 HashCode。这也就意味着对于不同的输入值可能会产生相同的 index，这也就是哈希碰撞。对于哈希碰撞大体上有两种解决方案：按照一定规则寻找数组中其他空余的位置，将 value 插入该位置；在 index 位置上使用链表来保存相同 HashCode 的 key 对应的 value。Java 选择了后者的实现方式。那么问题就来了，在对 <code>HashMap</code> 进行 <code>get</code> 操作的时候，势必要进行 key 值的比较。如果 Key 的长度很大的话，<code>HashMap</code> 的 <code>get</code> 操作耗时应该会显著增加，那么是不是这样呢？ 今天研究了一下这个问题。</p><span id="more"></span><h2 id="0x01-Java-的-HashMap-是如何-get-到目标值的"><a href="#0x01-Java-的-HashMap-是如何-get-到目标值的" class="headerlink" title="0x01 Java 的 HashMap 是如何 get 到目标值的"></a>0x01 Java 的 HashMap 是如何 get 到目标值的</h2><p>如上面所说的，为了解决哈希碰撞问题，在对 <code>HashMap</code> 进行 <code>put</code> 操作的时候，有几率会在同一个 index 的位置上挂载多个 value，那么 <code>get</code> 操作想要获得正确的值就必须可以将查询时输入的 <code>key</code> 和 <code>put</code> 时保存在 <code>HashMap</code> 中的 <code>key</code> 值进行比较，相同时才返回 <code>value</code>，否则就继续向后遍历链表。流程如下面流程图所示：</p><p><img src="/2020/02/25/Java/HashMapTimeComplexity/getflow.png" alt="get 的流程"></p><h2 id="0x02-耗时点分析"><a href="#0x02-耗时点分析" class="headerlink" title="0x02 耗时点分析"></a>0x02 耗时点分析</h2><p>由上面的流程可以知道， <code>get</code> 操作涉及了一步 <code>value.key.equals(key)</code> 的比较操作，如果 <code>key</code> 是 <code>String</code> 类型的话，那我们看下 <code>String</code> 是如何实现 <code>equals</code> 方法的：</p><p><img src="/2020/02/25/Java/HashMapTimeComplexity/string_equals.png" alt></p><p>可以看到，在判断是否相同的时候会先比较字符串的 <code>coder</code> 是否相同，从coder方法中可以得知这个标志位是用来区分字符串是否是 Compact String 的，如果两个字符串的 <code>coder</code> 标志位不同也就说明两个字符串的类型有区别，那么就一定不同。如果相同，我们看到又继续执行了 <code>StringLatin</code> 或者 <code>StringUTF16</code> 的 <code>equals</code> 方法。这两个方法的实现很类似，我们以 <code>StringLatin.equals</code> 的实现为例来看：</p><p><img src="/2020/02/25/Java/HashMapTimeComplexity/stringlatin_equals.png" alt></p><p>看到这里是使用了一个 <code>for</code> 循环来遍历两个字符串，逐字符比较两个字符串是否相同，那么这里的时间复杂度是 <code>O(n)</code>。</p><h2 id="0x03-验证"><a href="#0x03-验证" class="headerlink" title="0x03 验证"></a>0x03 验证</h2><p>通过以上的分析可知，<code>HashMap.get</code> 的真正时间复杂度其实是和 <code>key</code> 的判等速度有关的，并不是严格意义上的 <code>O(1)</code>。可见，在字符串作为 <code>Key</code> 的例子下如果使用很长字符串作为 <code>Key</code>，那么 <code>HashMap.get</code> 会耗费大量的时间来进行字符串的判等。下面做一个实验来检验一下这个结论：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Solotion &#123;</span><br><span class="line">    &#x2F;&#x2F; 生成 len 长度的字符串</span><br><span class="line">    String lsGen(int len) &#123;</span><br><span class="line">        String s &#x3D; &quot;&quot;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">            char c &#x3D; (char) (0x4e00 + (int) (Math.random() * (0x9fa5 - 0x4e00 + 1)));</span><br><span class="line">            s +&#x3D; c;</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 测试函数</span><br><span class="line">    void test (String s) &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; m &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            String str &#x3D; s + i;</span><br><span class="line">            m.put(str, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Long bf &#x3D; System.currentTimeMillis();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            m.get(s + i);</span><br><span class="line">        &#125;</span><br><span class="line">        Long af &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;Length of String: &quot; + s.length() + &quot; Time : &quot; + (af - bf));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Solotion m &#x3D; new Solotion();</span><br><span class="line">        String lstr &#x3D; m.lsGen(100000); &#x2F;&#x2F; 长字符串作为 key</span><br><span class="line">        String sstr &#x3D; m.lsGen(100); &#x2F;&#x2F; 短字符串作为 key</span><br><span class="line">        lstr.equals(sstr);</span><br><span class="line">        m.test(lstr);</span><br><span class="line">        m.test(sstr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行得到以下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Connected to the target VM, address: &#39;127.0.0.1:51865&#39;, transport: &#39;socket&#39;</span><br><span class="line">Length of String: 100000 Time : 1354</span><br><span class="line">Length of String: 100 Time : 2</span><br><span class="line">Disconnected from the target VM, address: &#39;127.0.0.1:51865&#39;, transport: &#39;socket&#39;</span><br></pre></td></tr></table></figure><p>可以看到产生了三个数量级的差距，这个差距还会随着 key 增长和元素增多而拉大。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Key 的长度会影响到 <code>HashMap.get</code> 的效率，过多判等比较耗时的 Key 会导致 <code>HashMap.get</code> 变得很慢，所以尽量使用判等效率高的 Object 作为 Key 以获得最大的效率。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;最近刷 leetcode，又回去回顾了很多数据结构的知识。刷题时经常会碰到使用 &lt;code&gt;HashMap&lt;/code&gt; 来实现 &lt;code&gt;O(1)&lt;/code&gt; 时间内的元素快速查找，以空间换时间。Hash 表的基本原理就是对 key 进行哈希运算得出 HasCode，然后通过对 HashCode 进行变换得到数组的 index。最后将 value 插入到该 index 位置上。但实际上，并不存在完美的散列算法能使得对于每个不同的输入值都能得到独一无二的 HashCode。这也就意味着对于不同的输入值可能会产生相同的 index，这也就是哈希碰撞。对于哈希碰撞大体上有两种解决方案：按照一定规则寻找数组中其他空余的位置，将 value 插入该位置；在 index 位置上使用链表来保存相同 HashCode 的 key 对应的 value。Java 选择了后者的实现方式。那么问题就来了，在对 &lt;code&gt;HashMap&lt;/code&gt; 进行 &lt;code&gt;get&lt;/code&gt; 操作的时候，势必要进行 key 值的比较。如果 Key 的长度很大的话，&lt;code&gt;HashMap&lt;/code&gt; 的 &lt;code&gt;get&lt;/code&gt; 操作耗时应该会显著增加，那么是不是这样呢？ 今天研究了一下这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://ufolux.github.io/categories/Java/"/>
    
    
      <category term="数据结构" scheme="https://ufolux.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>OnePassword 原理</title>
    <link href="https://ufolux.github.io/2019/07/26/Casual/onePasswordTheory/"/>
    <id>https://ufolux.github.io/2019/07/26/Casual/onePasswordTheory/</id>
    <published>2019-07-26T09:03:06.000Z</published>
    <updated>2021-03-16T10:37:12.517Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><center>![Alt text](2a547a9f-4e08-4b9c-8ed7-4af67968591f.png)</center><h2 id="OnePassword-解决的问题"><a href="#OnePassword-解决的问题" class="headerlink" title="OnePassword 解决的问题"></a>OnePassword 解决的问题</h2><p>网站账户太多导致需要记录的账号和密码太多，一般人很难记住很多不同的密码。于是很多人会在不同的网站使用相同的账号密码，但是一旦其中一个网站被拖库，所有网站的密码就都会遭到泄露，这种做法很不安全。OnePassword 就针对这个情况为人们提供了一个安全的生成，存储和登录自动填充密码的解决方案。</p><p>那么，OnePassword 是如何解决这个问题的呢？</p><span id="more"></span><h2 id="OnePassword-原理"><a href="#OnePassword-原理" class="headerlink" title="OnePassword 原理"></a>OnePassword 原理</h2><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><p>首先我们来看一下 OnePassword 的交互时序，为了方便起见，我画了一幅时序图放在下面</p><p><img src="/2019/07/26/Casual/onePasswordTheory/48a89fba-5487-4fe1-8845-f707a937901d.png" alt="Alt text"></p><p>可以看到它在注册和登录两个步骤都起到了关键作用，在注册的时候替用户生成了复杂密码，避免了用户自己思考密码的不便和不安全；在登录时又将之前保存的用户名和密码填充到目标网站或者 App 中，解决了用户记不住密码的问题。那么它又是如何保证安全性的呢？</p><h3 id="密码安全性"><a href="#密码安全性" class="headerlink" title="密码安全性"></a>密码安全性</h3><p><img src="/2019/07/26/Casual/onePasswordTheory/48a89fba-5487-4fe1-8845-f707a937901d.png" alt="Alt text"></p><p>为了实现功能在多个终端都可以方便地使用，OnePassword 设计了一个密码仓库的同步机制，会将设备上的密码密文存储到远端的服务器或者网盘中。当新的设备登录时，密码库将被下载到新的设备中以此来实现随时随地在任意设备上均可使用其功能。</p><p>用户的密码被传到服务器中，会不会出现密码泄露的问题呢？答案是不会的。 OnePassword 在保存密码时会对密码进行多重的 AES256 加密，而密钥只保存在本地不会传输到远端，也就是说用于加解密的密钥只有你自己掌握，加密和解密的工作都只由本地客户端来完成。所以即使有人攻破了 OnePassword 的服务器取得了所有被加密的密码，在不知道密钥的情况下也无法在合理时间内将密码破解出来。</p><p>那么，这个用于登录 OnePassword 账号的密码又会不会被人截获呢？答案也是否定的。为了解释这个问题，首先我们先介绍两个概念，主密码（Master Password）和密钥（Secret Key）</p><ul><li><p>主密码（Master Password）<br>用过 OnePassword 的人们都知道，在你注册 OnePassword 时，需要设置一个你自己记得住的密码，这个密码就是主密码。主密码十分重要，当你需要存取其他密码，或者登录其他设备的时候，OnePassword 都会要求你输入主密码（指纹验证其实也依赖了主密码的校验）。主密码只能依赖个人的记忆，不可找回，这意味着一旦你遗失了主密码，那么 OnePassword 中保存的所有密码信息也就随之化为乌有。</p></li><li><p>密钥（Secret Key）<br>在注册阶段用户输入主密码之后，OnePassword 还会生成一个密钥，这个密钥是一个 ‘A3’ 开头的字符串，长下面这个样子<br><img src="/2019/07/26/Casual/onePasswordTheory/d3001b7a-c0b0-423d-9b1d-c339cf27a9dd.png" alt="Alt text"></p></li></ul><p>这个密钥被存储于用户的客户端本地，基本无法被破解，这个密钥有时也被称为隐藏密钥，因为他不像是你的主密码，可以容易地被人记住。</p><p>上面的连词符号其实并不是个人私钥的一部分，只是为了增强可读性做分割使用的。版本号既不随机也不保密，用户 ID 倒是随机的，可是并不保密，而剩下的部分既是随机的也是保密的。</p><p>介绍了以上两个概念，现在回到我们的问题。OnePassword 之所以可以保证用于登录账户的密码不会泄露，是因为它甚至根本没有在服务器中以任何形式存储这个密码。这里 OnePassword 运用了非对称加密中的一项名为 <a href="https://zh.wikipedia.org/zh-cn/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B">迪菲-赫尔曼密钥交换</a>的技术。具体地说，客户端根据<strong>主密码</strong>和<strong>密钥</strong>以及其他一些东西（比如加入一些随机数），计算出一个数字，我们称为A，在注册阶段，客户端根据 A 计算出一个 B；然后把 B 发送给服务器。注意，B 类似于 hash(A)，具体的方式，可能对 A 做一点其他运算再 hash；不管具体是哪种方案，窃听者都无法通过 B 计算出 A，而且他因为不知道 A，所以也无法做碰撞分析；甚至是，即便窃听者知道了主密码，只要他不知道密钥，他仍无法做碰撞分析。客户端任何时候，都可以根据主密码和密钥计算出 A；同时，server 那边有了一个通过 A 计算出的 B；因为 A 和 B 之间这种特殊的关系，那么此后在登陆阶段：</p><ol><li>客户端可以向服务端证明它有一个和 B 对应的 A</li><li>服务端可以向客户端证明它有一个和 A 对应的 B</li><li>同时让客户端和服务端协定出一个 C 作为后续双方通信信息的加密密钥</li></ol><blockquote><p>这里引用维基百科中的一个一般性描述来说明这个算法<br><img src="/2019/07/26/Casual/onePasswordTheory/15a86dcb-cdc2-44a1-ac46-f611b66977cb.png" alt="Alt text"></p></blockquote><p>具体的数学原理可以参见维基百科的说明，这里不再赘述。总之，通过这个密钥交换协议客户端和 OnePassword 服务端实现了在不传输密码本身的条件下进行通信，以此最大程度上保护密码的安全性。</p><h3 id="更换客户端"><a href="#更换客户端" class="headerlink" title="更换客户端"></a>更换客户端</h3><p>由于主密码和密钥均由客户自行保管，而密码的加密解密完全依赖于主密码和密钥，所以在新的客户端上使用 OnePassword 的时候，需要用户将自己保存的主密码和密钥两者都输入到新设备的客户端中，这样客户端才能进行登录账户和对密码进行加解密操作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>OnePassword 是一个安全性很高的密码管理工具，它对密码明文的加密和解密工作均在客户端本地完成，且依赖的密钥也都由客户保管，不会在 OnePassword 服务端传输的过程中产生泄露。由此看来，如果不在乎它每年 $279 HKD 的订阅价格，它的确是一个能帮你在摆脱密码焦虑的同时提升你密码安全性的绝佳工具。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p> <a href="https://zh.wikipedia.org/zh-cn/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B">迪菲-赫尔曼密钥交换</a><br> <a href="https://sspai.com/post/41260">假如你忘了 1Password 的主密码，到底该怎么办？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;![Alt text](2a547a9f-4e08-4b9c-8ed7-4af67968591f.png)&lt;/center&gt;

&lt;h2 id=&quot;OnePassword-解决的问题&quot;&gt;&lt;a href=&quot;#OnePassword-解决的问题&quot; class=&quot;headerlink&quot; title=&quot;OnePassword 解决的问题&quot;&gt;&lt;/a&gt;OnePassword 解决的问题&lt;/h2&gt;&lt;p&gt;网站账户太多导致需要记录的账号和密码太多，一般人很难记住很多不同的密码。于是很多人会在不同的网站使用相同的账号密码，但是一旦其中一个网站被拖库，所有网站的密码就都会遭到泄露，这种做法很不安全。OnePassword 就针对这个情况为人们提供了一个安全的生成，存储和登录自动填充密码的解决方案。&lt;/p&gt;
&lt;p&gt;那么，OnePassword 是如何解决这个问题的呢？&lt;/p&gt;
    
    </summary>
    
      <category term="安全" scheme="https://ufolux.github.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="OnePassword" scheme="https://ufolux.github.io/tags/OnePassword/"/>
    
  </entry>
  
  <entry>
    <title>iOS App 签名的原理</title>
    <link href="https://ufolux.github.io/2019/07/23/iOS/ios-app-signature-theory/"/>
    <id>https://ufolux.github.io/2019/07/23/iOS/ios-app-signature-theory/</id>
    <published>2019-07-23T06:39:17.000Z</published>
    <updated>2021-03-16T10:37:33.649Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>iOS 签名机制比较复杂,涉及到一堆证书，Provisioning Profile，entitlements，CertificateSigningRequest，p12，AppID 等等概念繁多，也很容易出错，下面我们就来看下这些概念到底是什么？是怎么和 iOS App 的签名机制一起工作的？了解这些会有助于理解 iOS 这套复杂的签名机制。</p><span id="more"></span><h2 id="0x01-签名机制的目的"><a href="#0x01-签名机制的目的" class="headerlink" title="0x01 签名机制的目的"></a>0x01 签名机制的目的</h2><p>首先要知道苹果为什么要退出这一套把人搞晕的签名机制。众所周知 iOS 是一个封闭的生态体系，苹果希望能取得对平台上的所有应用的绝对控制权。所以 iOS 不会像 PC 上那样，无需任何签名验证即可随意安装任何地方获取到的软件，而这种不受控的软件安装也是导致盗版盛行和生态混乱的元凶。那么苹果要怎样做才能保证每一个安装到 iOS 设备上的 App 都是经过苹果官方许可的呢？这就要靠签名和签名的验证机制来实现。</p><h2 id="0x02-非对称加密"><a href="#0x02-非对称加密" class="headerlink" title="0x02 非对称加密"></a>0x02 非对称加密</h2><center>Asymmetric Key System</center><br><p><img src="/2019/07/23/iOS/ios-app-signature-theory/j_nleng-2016-0010_fig_002.jpg" alt="RSA"></p><p>具体的原理可以参考这两篇文章：RSA 算法原理<a href="https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">（一）</a>，<a href="https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">（二）</a>以及相关的数论知识：<a href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86_(%E6%95%B0%E8%AE%BA)">欧拉定理</a>，<a href="https://zh.wikipedia.org/wiki/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86">费马小定理</a>，<a href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0">欧拉函数</a>，<a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E9%A4%98">同余</a></p><p>非对称加密算法是数字签名的基石。它通过使用两份密钥对数据进行加解密操作的。这两个密钥分别是公钥和私钥，用公钥加密的数据，要用私钥才能解密，用私钥加密的数据，要用公钥才能解密。</p><h2 id="0x03-数字签名"><a href="#0x03-数字签名" class="headerlink" title="0x03 数字签名"></a>0x03 数字签名</h2><p>现在知道了有非对称加密这东西，那什么是数字签名呢？</p><p><img src="/2019/07/23/iOS/ios-app-signature-theory/Digital-Signature.png" alt></p><p>数字签名的作用是我对某一份数据作个标记，表示我认可了这份数据（签名），然后我再发送给其他人，其他人通过验证签名就能知道这个数据是不是被我认可的，数据有没有被篡改过。</p><p>为了保证签名在传输过程中的安全性需要对签名进行加密，基于非对称加密算法，就可以实现上述的方案：</p><p><img src="/2019/07/23/iOS/ios-app-signature-theory/1540440549901.png" alt="Alt text"></p><ol><li>首先用一种算法，算出原始数据的摘要。需满足:<br>a. 若原始数据有任何变化，计算出来的摘要值都会变化。<br>b. 摘要要够短。<br>这里最常用的算法是MD5。</li><li>生成一份非对称加密的公钥和私钥，私钥我自己拿着，公钥公布出去。</li><li>对一份数据，算出摘要后，用私钥加密这个摘要，得到一份加密后的数据，称为原始数据的签名。把它跟原始数据一起发送给用户。</li><li>用户收到数据和签名后，用公钥解密得到摘要。同时用户用同样的算法计算原始数据的摘要，对比这里计算出来的摘要和用公钥解密签名得到的摘要是否相等，若相等则表示这份数据中途没有被篡改过，因为如果篡改过，摘要会变化。</li></ol><p>之所以要有第一步计算摘要，是因为非对称加密的原理限制可加密的内容不能太大（不能大于上述 n 的位数，也就是一般不能大于 1024 位 / 2048 位），于是若要对任意大的数据签名，就需要改成对它的特征值签名，效果是一样的。</p><p>有了以上的铺垫，现在来看看怎样通过这个数字签名的机制保证每一个安装到 iOS 上的 APP 都是经过苹果允许的。</p><h2 id="0x04-最简单的签名方案"><a href="#0x04-最简单的签名方案" class="headerlink" title="0x04 最简单的签名方案"></a>0x04 最简单的签名方案</h2><p><img src="/2019/07/23/iOS/ios-app-signature-theory/1540449599481.png" alt="200%"></p><p>我们先来讨论一种最直接的验证方式。那就是，苹果官方自己生成一对公私钥对。将公钥内置在 iOS 系统之中，私钥则由苹果的后台保存。开发者将 App 上传到苹果 AppStore 进行发布的时候，苹果用私钥将 App 的数据进行签名，iOS 系统下载这个 App 的时候，用系统中内置的公钥来验证这个 App 的签名，如果签名正确，就可以认为这个 App 的数据是没有被篡改过的，是经过苹果认证的版本。这样就满足了苹果的要求：保证 iOS 上安装的 App 都是经过苹果官方允许的。</p><p>如果 iOS 上的 App 安装渠道只有 AppStore 一个的话，那现在这个方案已经可以满足需求了。但实际上因为除了从 AppStore 下载，我们还可以有其他三种方式安装 App：</p><ol><li>开发 App 时可以直接使用 Xcode 将应用直接编译安装进手机进行调试。</li><li>In-House 企业开发者证书内部分发，iOS  设备可以直接下载安装企业 In-House 证书签名后的 App。</li><li>Ad-Hoc 相当于开发者分发的限制版，限制安装设备数量，较少用。</li></ol><p>所以苹果同样要对用这三种方式安装的 App 进行控制，那么在新的场景之下，方案就无法像上面这样简单了。</p><h2 id="0x05-新场景"><a href="#0x05-新场景" class="headerlink" title="0x05 新场景"></a>0x05 新场景</h2><h3 id="a-XCode-安装"><a href="#a-XCode-安装" class="headerlink" title="a. XCode 安装"></a>a. XCode 安装</h3><p>我们先来看第一个，开发时安装APP，它有两个问题：</p><ol><li>安装包不需要传到苹果服务器，可以直接安装到手机上。如果你编译一个 APP 到手机前要先传到苹果服务器签名，这显然是不能接受的。</li><li>苹果必须对这里的安装有控制权，包括<br>a. 经过苹果允许才可以这样安装。<br>b. 不能被滥用导致非开发app也能被安装。</li></ol><p>为了解决这两个问题，iOS 签名的复杂度也就开始增加了。<br>苹果的方案是使用双层签名，比较繁琐，流程大概是这样的：</p><p><img src="/2019/07/23/iOS/ios-app-signature-theory/1540458455751.png" alt="110%"></p><p>① 首先在你的 Mac 开发机上生成一对公私钥，我们称为公钥L，私钥L（L: Local）。<br>② 苹果自己有固定的一对公私钥，跟上面 AppStore 例子一样，私钥在苹果后台，公钥在每个 iOS 设备上。这里称为公钥A，私钥A (A:Apple)。<br>把公钥 L 传到苹果后台，用苹果后台里的私钥 A 去签名公钥 L。得到一份数据包含了公钥 L 以及其签名，把这份数据称为<strong><em>证书</em></strong>。<br>③ 在开发时，App 编译通过之后，用本地的私钥 L 对这个 App 进行签名，同时把第三步得到的证书一起打包进 App 里，安装到手机上。<strong>所以 App 的 IPA 安装包中同时包含了 可执行文件，可执行文件的签名以及证书</strong><br>④ 在安装 App 时，iOS 系统从 App 包中取得证书，通过系统内置的公钥 A，去验证证书的数字签名是否正确。<br>⑤ 验证证书后确保了公钥 L 是苹果认证过的，没有被篡改，再用公钥 L 去验证 App 的签名，这里就间接验证了这个 App  安装行为是否经过苹果官方允许。（这个过程只验证安装行为，不验证 App 是否被修改，因为开发阶段 APP 内容总是不断变化的，苹果不需要管。）</p><h2 id="0x06-进一步研究"><a href="#0x06-进一步研究" class="headerlink" title="0x06 进一步研究"></a>0x06 进一步研究</h2><p>上面讲的这一堆流程只解决了上面第一个问题，也就是需要经过苹果允许才可以安装 App，还未解决第二个避免证书被滥用的问题。针对这一点，苹果又添加加了两个限制，一是限制在苹果后台注册过的设备（UDID）才可以安装，二是限制签名只能针对某一个具体的 App 起作用。</p><p>那么具体是怎么做的呢？在上面的 ③，苹果用私钥 A 签名我们本地公钥 L 时，实际上除了签名公钥 L，还可以添加他需要的任何数据，这些数据都可以保证 App 是经过苹果官方认证的，不会有被篡改的可能。</p><p><img src="/2019/07/23/iOS/ios-app-signature-theory/1540460710574.png" alt="120%"></p><p>可以想到把 允许安装的设备 ID 列表 和 App对应的 AppID 等数据，都在 ③ 这里跟公钥L一起组成证书，再用苹果私钥 A 对这个证书签名。在 ⑤ 的验证时就可以拿到设备 ID（UDID） 列表，判断当前设备是否符合要求。根据数字签名的原理，只要数字签名通过验证，第 5 步这里的UDID 列表 / AppID / 公钥 L 就都是经过苹果认证的，无法被修改，苹果就可以限制可安装的设备和 APP，避免滥用。</p><h2 id="0x07-最终方案"><a href="#0x07-最终方案" class="headerlink" title="0x07 最终方案"></a>0x07 最终方案</h2><p>现在这个证书已经变得很复杂了，有很多额外信息，实际上除了 UDID 列表 / AppID，还有其他信息也需要在这里用苹果签名，App 里 iCloud / push / App Group / 后台运行 等权限和能力苹果都想控制，苹果称这些权限开关为 Entitlements，它也需要通过签名去授权。</p><p>另外，一个“证书”本来就有规定的格式规范，上面我们把各种额外信息塞入证书里是不合适的，其实在真正的生产环境下，苹果也没有这么做，他们另外搞了个叫 Provisioning Profile 的东西，一个 Provisioning Profile 里就包含了证书以及上述提到的所有额外信息，以及所有信息的签名。</p><p>所以流程就变成了这样：</p><p><img src="/2019/07/23/iOS/ios-app-signature-theory/1540469920699.png" alt="Alt text"></p><p>现在我们来总结一下完整的最终流程</p><p>在你的 Mac 开发机器生成一对公私钥，这里称为公钥L，私钥L。(L: Local)<br>苹果自己有固定的一对公私钥，跟上面 AppStore 例子一样，私钥在苹果后台，公钥在每个 iOS 设备上。这里称为公钥A，私钥A。(A: Apple)</p><ol><li>把公钥 L 传到苹果后台，用苹果后台里的私钥 A 去签名公钥 L。得到一份数据包含了公钥 L 以及其签名，把这份数据称为证书。</li><li>在苹果后台申请 AppID，配置好设备 ID 列表和 APP 可使用的权限，再加上第③步的证书，组成的数据用私钥 A 签名，把数据和签名一起组成一个 Provisioning Profile 文件，下载到本地 Mac 开发机。</li><li>在开发时，编译完一个 App 后，用本地的私钥 L 对这个 APP 进行签名，同时把第④步得到的 Provisioning Profile 文件打包进 APP 里，文件名为 <code>embedded.mobileprovision</code>，把 APP 安装到手机上。</li><li>在安装时，iOS 系统取得证书，通过系统内置的公钥 A，去验证 <code>embedded.mobileprovision</code> 的数字签名是否正确，里面的证书签名也会再验一遍。</li><li>确保了 <code>embedded.mobileprovision</code> 里的数据都是苹果授权以后，就可以取出里面的数据，做各种验证，包括用公钥 L 验证APP签名，验证设备 ID 是否在 ID 列表上，AppID 是否对应得上，权限开关是否跟 App 里的 Entitlements 对应等。</li><li></li></ol><p>开发者证书从签名到认证最终苹果采用的流程大致是这样。</p><h2 id="0x08-概念和操作"><a href="#0x08-概念和操作" class="headerlink" title="0x08 概念和操作"></a>0x08 概念和操作</h2><ol><li>第 1 步对应的是 keychain 里的 “从证书颁发机构请求证书”，这里就本地生成了一对公私钥，保存的 CertificateSigningRequest 就是公钥，私钥保存在本地电脑里。</li></ol><ol start="2"><li>第 2 步苹果处理，不用管。</li></ol><ol start="3"><li>第 3 步对应把 CertificateSigningRequest 传到苹果后台生成证书，并下载到本地。这时本地有两个证书，一个是第 1 步生成的，一个是这里下载回来的，keychain 会把这两个证书关联起来，因为他们公私钥是对应的，在XCode选择下载回来的证书时，实际上会找到 keychain 里对应的私钥去签名。这里私钥只有生成它的这台 Mac 有，如果别的 Mac 也要编译签名这个 App 怎么办？答案是把私钥导出给其他 Mac 用，在 keychain 里导出私钥，就会存成 .p12 文件，其他 Mac 打开后就导入了这个私钥。</li></ol><ol start="4"><li>第 4 步都是在苹果网站上操作，配置 AppID / 权限 / 设备等，最后下载 Provisioning Profile 文件。</li></ol><ol start="5"><li>第 5 步 XCode 会通过第 3 步下载回来的证书（存着公钥），在本地找到对应的私钥（第一步生成的），用本地私钥去签名 App，并把 Provisioning Profile 文件命名为 embedded.mobileprovision 一起打包进去。这里对 App 的签名数据保存分两部分，Mach-O 可执行文件会把签名直接写入这个文件里，其他资源文件则会保存在 _CodeSignature 目录下。</li></ol><ol start="6"><li>第 6 – 7 步的打包和验证都是 Xcode 和 iOS 系统自动做的事。</li></ol><p>然后，在总结下上面说到的概念：</p><h3 id="概念小结"><a href="#概念小结" class="headerlink" title="概念小结"></a>概念小结</h3><p><strong>证书</strong>：内容是公钥或私钥，由其他机构对其签名组成的数据包。<br><strong>Entitlements</strong>：包含了 App 权限开关列表。<br><strong>CertificateSigningRequest</strong>：本地公钥。<br><strong>p12</strong>：本地私钥，可以导入到其他电脑。<br><strong>Provisioning Profile</strong>：包含了 证书 / Entitlements 等数据，并由苹果后台私钥签名的数据包。</p><h2 id="0x09-其他发布方式"><a href="#0x09-其他发布方式" class="headerlink" title="0x09 其他发布方式"></a>0x09 其他发布方式</h2><ol><li><p>In-House, Ad-Hoc</p></li><li><p>AppStore</p></li></ol><p>前面以开发包为例子说了签名和验证的流程，另外两种方式 In-House 企业签名和 AD-Hoc 流程也是差不多的，只是企业签名不限制安装的设备数，另外需要用户在 iOS 系统设置上手动点击信任这个企业才能通过验证。</p><p>而 AppStore 的签名验证方式有些不一样，前面我们说到最简单的签名方式，苹果在后台直接用私钥签名 App 就可以了，实际上苹果确实是这样做的，如果去下载一个 AppStore 的安装包，会发现它里面是没有 embedded.mobileprovision 文件的，也就是它安装和启动的流程是不依赖这个文件，验证流程也就跟上述几种类型不一样了。</p><p> 据猜测，因为上传到 AppStore 的包苹果会重新对内容加密，原来的本地私钥签名就没有用了，需要重新签名，从 AppStore 下载的包苹果也并不打算控制它的有效期，不需要内置一个 <code>embedded.mobileprovision</code> 去做校验，直接在苹果用后台的私钥重新签名，iOS 安装时用本地公钥验证 App 签名就可以了。</p><p>那为什么发布 AppStore 的包还是要跟开发版一样搞各种证书和 Provisioning Profile？猜测因为苹果想做统一管理，Provisioning Profile 里包含一些权限控制，AppID 的检验等，苹果不想在上传 AppStore 包时重新用另一种协议做一遍这些验证，就不如统一把这部分放在 Provisioning Profile 里，上传 AppStore 时只要用同样的流程验证这个 Provisioning Profile 是否合法就可以了。</p><p>所以 App 上传到 AppStore 后，就跟你的 证书 / Provisioning Profile 都没有关系了，<strong>无论他们是否过期或被废除，都不会影响 AppStore 上的安装包。</strong></p><p>上述内容就是 iOS App 签名机制的原理和主流程了，希望能够通过这样简单的梳理让看到这篇文章的 iOS 开发者能够对这个复杂的流程有所认识和了解。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;iOS 签名机制比较复杂,涉及到一堆证书，Provisioning Profile，entitlements，CertificateSigningRequest，p12，AppID 等等概念繁多，也很容易出错，下面我们就来看下这些概念到底是什么？是怎么和 iOS App 的签名机制一起工作的？了解这些会有助于理解 iOS 这套复杂的签名机制。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://ufolux.github.io/categories/iOS/"/>
    
    
      <category term="iOS 签名" scheme="https://ufolux.github.io/tags/iOS-%E7%AD%BE%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>从无到有，开发一个 App（三）--- 多人协助开发APP快速交付</title>
    <link href="https://ufolux.github.io/2019/07/15/Experiences/zeroToOneDevApp-3/"/>
    <id>https://ufolux.github.io/2019/07/15/Experiences/zeroToOneDevApp-3/</id>
    <published>2019-07-15T12:32:06.000Z</published>
    <updated>2021-03-16T10:38:51.439Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>按照我司的现实情况来讲，app 团队基本上维持着一个 10 人以上的移动研发团队，团队里面有项目经理、开发和测试同学，在研发过程中基本上都是多个项目同时进行。在项目的发展中，其中有些项目会参与到各种运营活动之中，需要和其它团队进行协作。所有的代码都耦合在一个客户端里面，每个月至少要发布 2 个版本，大家开发周各自开发暂时相安无事，一旦到了测试周要合代码到一起就出现各种诡异问题导致构建不成功、功能不可用、测试需要反复无数次验证依然惴惴不安。如何才能更好地协作开发，以较高的效率完成 App 开发工作呢？</p><span id="more"></span><h2 id="迭代的典型流程"><a href="#迭代的典型流程" class="headerlink" title="迭代的典型流程"></a>迭代的典型流程</h2><p><img src="/2019/07/15/Experiences/zeroToOneDevApp-3/af4d8275-6aa5-4afd-b402-60887a7d229a.png" alt="Alt text"></p><p>上面是一个应用开发的典型流程图，下面来对流程进行详细的分析。</p><h3 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h3><ul><li><p>工程解耦<br>对于 10 人以上的研发团队，非常需要提高研发协同效率，首先工程需要解耦，各自独立，减少相互依赖和影响，尽量做到每个模块可以独立构建独立发布。在开发中我们也采用了这样的方式，将客户端代码，基础库（网络库等），App 内 使用到的 Web 页面代码分别建立成独立的仓库，在未来应该也会将运营活动的页面和代码建立独立的工程来管理。         </p></li><li><p>PMO(Project Management Office)：定义项目规范和版本计划<br>PMO 作为统筹整个项目的关键环节，先根据团队人员配比等制定适合当前团队的项目管理方案和项目规约，同时定义清楚客户端版本发布计划，例如每周五发布一个灰度版本，每个月底发布一个正式版本，计划清晰后同步到所有人员，方便大家安排工作。</p></li><li><p>产品经理：设计需求<br>产品经理通过分析用户反馈、分析市场诉求，从而抽象出业务需求，研发人员也会自行添加技术升级类需求，统一沉淀到平台做需求管理。当然，在实践中研发人员自行提出的技术需求需要和项目经理以及测试人员进行会商，评估影响面积，风险敞口，测试工作量和测试资源的安排。</p></li><li><p>项目经理：排期分工<br>根据需求和版本计划，PM 应将需求拆分成多个并行项目，如技术改造项目、迭代需求项目、长线需求项目，运营活动项目，项目经理或者资深研发会把这些需求细化拆分成任务，分派给不同的具体开发人员。</p></li></ul><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><ul><li><p>研发：代码变更<br>研发实现需求后，在各自研发项目和代码分支中添加变更，测试自己的变更，当然最好是能对公共部分代码添加或者补充单元测试用例以保障项目的质量。</p></li><li><p>研发：持续集成（CI）<br>使用 CI 解决方案配合构建脚本在开发过程中持续进行构建集成和单元测试，及时发现问题，尽可能将能发现的问题在开发阶段解决。</p></li><li><p>研发：版本集成<br>研发在项目空间中完成代码变更和测试后，按照约定的发版计划，再约定好的时间自行提交版本集成生成最终提供测试冒烟的版本。</p></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li>测试：功能、验收测试<br>参加集成后，测试会对最终集成完成准备发布的包进行功能回归和验收测试，只有测试通过后的包，才能发布到用户手中。</li></ul><h3 id="发布和运维"><a href="#发布和运维" class="headerlink" title="发布和运维"></a>发布和运维</h3><ul><li><p>研发：版本发布<br>版本发布过程，支持丰富的灰度策略，需要支持多批次缓慢放量，发布过程中实时监控 Crash、用户反馈，发生问题可及时止血。在我们的实践中，灰度策略基于 3 个维度，分别是具体客户、客户端版本、ReactNative 版本。客户维度基于客户号实现，客户端和 ReactNative 版本都基于客户端上报的请求头来实现。更复杂的维度甚至可以包含系统版本，手机型号等等。对于一些功能发布出现问题时可以及时将灰度关闭，停止功能的发布上线，将影响降低。<br>在 ReactNative 版本发布的过程中，由于我们的发布窗口在周五，我们采用先对占用户比重较小的新近原生版本放量发布，如果在周末没有大面积的异常情况出现，则在周一对其余的存量旧版本进行发布升级。出现问题的话，可以及时进行版本的回滚，减少问题的影响面积。</p></li><li><p>研发：运维监控<br>线上监控运维，除了实时 Crash 分析之外，还应提供线上问题快速定位分析的解决方案，用户日志跟踪等服务，方便及时发现问题。成熟的解决方案有 MTA，Bugly 和友盟等等开发商提供的 SDK。</p></li></ul><h2 id="控制迭代的节奏"><a href="#控制迭代的节奏" class="headerlink" title="控制迭代的节奏"></a>控制迭代的节奏</h2><p>在我们的具体实践中，迭代的具体步骤大致如下图所示。</p><p><img src="/2019/07/15/Experiences/zeroToOneDevApp-3/b3a5e411-8de6-43b1-8117-6ef8ea4dc0be.png" alt="Alt text"></p><h3 id="开发周"><a href="#开发周" class="headerlink" title="开发周"></a>开发周</h3><ol><li>周一对上一个迭代周期的发布进行全量发布配置。</li><li>开发人员对本迭代需求进行开发，测试人员进行本迭代测试用例的编写</li><li>周五进行本迭代发布需求的测试用例评审</li></ol><h3 id="测试发布周"><a href="#测试发布周" class="headerlink" title="测试发布周"></a>测试发布周</h3><ol><li>周一上午开发将需在本迭代发布需求的代码分支进行合并，并通过构建。</li><li>周一下午测试人员将开始对开发成果进行冒烟测试。</li><li>冒烟测试通过后，开始为期四天的迭代测试。</li><li>在周四，PM召集产品经理和开发负责人讨论并定稿下一迭代需求。</li><li>周五中午锁定开发分支，后续任何提交均需要进行审批。（防止有无限多的修改导致版本质量不可控）</li><li>下午进行回归测试和最小检查点测试。</li><li>晚上进行新版本的发布并对发布代码版本打 tag，发布完成之后进行新近版本的升级配置。</li></ol><h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><p>以上三篇，算是对这几年客户端工作的梳理，也是对经验的一个总结。真正的移动应用开发大潮始于 2007 年 Apple 发布 iPhone 到现在已经过去了 12 个年头。这 12 年里设备在不断创新进步，移动应用开发的技术也在一步步向着成本更低，更可维护的方向发展着。我们也看到前端技术和客户端技术的大融合催生的一系列创新的技术方案，这些技术创新也在一定程度上推动着业务和开发流程的演进和发展。希望通过这几篇文章的分享能够给予刚进入移动应用开发领域的参与者一些有建设性的观点，以更好的方式，开发出更好的应用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按照我司的现实情况来讲，app 团队基本上维持着一个 10 人以上的移动研发团队，团队里面有项目经理、开发和测试同学，在研发过程中基本上都是多个项目同时进行。在项目的发展中，其中有些项目会参与到各种运营活动之中，需要和其它团队进行协作。所有的代码都耦合在一个客户端里面，每个月至少要发布 2 个版本，大家开发周各自开发暂时相安无事，一旦到了测试周要合代码到一起就出现各种诡异问题导致构建不成功、功能不可用、测试需要反复无数次验证依然惴惴不安。如何才能更好地协作开发，以较高的效率完成 App 开发工作呢？&lt;/p&gt;
    
    </summary>
    
      <category term="经验" scheme="https://ufolux.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="从无到有，开发一个 App" scheme="https://ufolux.github.io/tags/%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%EF%BC%8C%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA-App/"/>
    
  </entry>
  
  <entry>
    <title>让网站支持Https</title>
    <link href="https://ufolux.github.io/2019/07/02/Server/LetsHttps/"/>
    <id>https://ufolux.github.io/2019/07/02/Server/LetsHttps/</id>
    <published>2019-07-02T06:39:27.000Z</published>
    <updated>2021-03-16T10:39:17.230Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="HTTPS-原理"><a href="#HTTPS-原理" class="headerlink" title="HTTPS 原理"></a>HTTPS 原理</h2><p>HTTPS 相比 HTTP 而言多了一个 s，也就是 SSL（Secure Sockets Layer），安全套接层。SSL 做的事情就是将用于通信的对称加密密钥进行非对称加密，以此来实现高效且安全的通信。整个 HTTPS 通信的时序图如下，包含了 HTTPS 四次握手。</p><span id="more"></span><blockquote><center>![Alt text](1e7e149c-7ffd-421b-aa19-302cd053a5d1.png)</center></blockquote><blockquote><ol><li>客户端发起一个https的请求，把自身支持的一系列Cipher Suite（密钥算法套件，简称Cipher）发送给服务端</li><li>服务端，接收到客户端所有的Cipher后与自身支持的对比，如果不支持则连接断开，反之则会从中选出一种加密算法和HASH算法<br>以证书的形式返回给客户端 证书中还包含了 公钥 颁证机构 网址 失效日期等等。</li><li>客户端收到服务端响应后会做以下几件事</li></ol><ul><li>验证证书的合法性<br>颁发证书的机构是否合法与是否过期，证书中包含的网站地址是否与正在访问的地址一致等<br>证书验证通过后，在浏览器的地址栏会加上一把小锁（因浏览器而异）</li><li>生成随机密码<br>如果证书验证通过，或者用户接受了不授信的证书，此时浏览器会生成一串随机数，然后用证书中的公钥加密。</li><li>HASH握手信息<br>用最开始约定好的HASH方式，把握手消息取HASH值，  然后用 随机数加密 “握手消息+握手消息HASH值(签名)”  并一起发送给服务端<br>在这里之所以要取握手消息的HASH值，主要是把握手消息做一个签名，用于验证握手消息在传输过程中没有被篡改过。</li></ul><ol start="4"><li>服务端拿到客户端传来的密文，用自己的私钥来解密握手消息取出随机数密码，再用随机数密码 解密 握手消息与HASH值，并与传过来的HASH值做对比确认是否一致。然后用随机密码加密一段握手消息(握手消息+握手消息的HASH值 )给客户端</li><li>客户端用随机数解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。因为这串密钥只有客户端和服务端知道，所以即使中间请求被拦截也是没法解密数据的，以此保证了通信的安全</li></ol><p>在客户端与服务端相互验证的过程中用的是对称加密，客户端与服务端相互验证通过后，以随机数作为密钥，对称加密 hash 算法也同时确认握手消息没有被篡改。</p></blockquote><h2 id="SSL-For-Free-amp-Let’s-Encrypt"><a href="#SSL-For-Free-amp-Let’s-Encrypt" class="headerlink" title="SSL For Free &amp; Let’s Encrypt"></a>SSL For Free &amp; Let’s Encrypt</h2><p>通过上面的描述，可以看到这里我们需要一个由认证机构（CA）颁发的 SSL 证书才能实现 HTTPS 通信，一般而言申请和更新 SSL 证书都是需要一定费用的，但是 <a href="www.sslforfree.com">SSL For Free</a> 为我们提供了一个免费获得 SSL 证书的渠道<br><img src="/2019/07/02/Server/LetsHttps/3cb8e496-b1bb-42a9-985d-4e133301f646.png" alt="Alt text"><br>在 SSL For Free 上可以获得由开放证书认证机构 <a href="https://letsencrypt.org/">Let’s Encrypt</a> 颁发的 SSL 证书，该机构受到很多企业和机构的捐赠以保持免费，这个证书获得世界上绝大多数的浏览器认可，可以说是一个福利。</p><h2 id="施工过程"><a href="#施工过程" class="headerlink" title="施工过程"></a>施工过程</h2><p>施工的过程相对来说很简单，以我的 Nginx 服务器为例分为以下几个步骤：</p><ol><li>在 <a href="www.sslforfree.com">www.sslforfree.com</a> 上输入你的域名，然后点击按钮创建 SSL 证书<br><img src="/2019/07/02/Server/LetsHttps/a54aa523-ff05-4eb0-9e4c-907aa07c0fbe.png" alt="Alt text"></li><li>然后转圈过后会进入下一个页面<br><img src="/2019/07/02/Server/LetsHttps/6c9133fb-ea90-4033-aa87-cf1ee288db9a.png" alt="Alt text"><br>按照上图的描述，选择手动认证，如果你有部署 FTP 可以选用第一个方式。然后点击最下方的按钮。将页面向下滚动之后会出现以下的内容。<br><img src="/2019/07/02/Server/LetsHttps/9eab3380-e061-4415-ae62-debc0ef9939c.png" alt="Alt text"><br>点击下载认证文件<br><img src="/2019/07/02/Server/LetsHttps/8672311b-2f40-4e33-bda7-61ddc9136861.png" alt="Alt text"><br>然后将下载好的认证文件按照图片中的说明部署到网站的目录中。通过下方提供的绿色链接可以验证部署是否成功。完成之后点击下方的绿色按钮。<br><img src="/2019/07/02/Server/LetsHttps/fda7f677-3561-4cdc-ada8-44cfc4d0d60a.png" alt="Alt text"></li><li>到下一个页面中下载包含证书和密钥的压缩文件到本地，解压，然后将文件上传到服务器的某个位置。</li><li>配置 Nginx<br>在 <code>/etc/nginx/sites-available</code> 中的站点配置文件里加上如下内容</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> server &#123;</span><br><span class="line">   ...</span><br><span class="line">   listen 443 ssl;</span><br><span class="line">   ssl_certificate &#123;证书目录&#125;&#x2F;certificate.crt;</span><br><span class="line">   ssl_certificate_key &#123;证书目录&#125;&#x2F;private.key;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 然后重启或者 reload Nginx。<br> 5. 如果 443 端口处于关闭状态，则还需要到 iptables 配置中将 443 端口开放。</p><p>至此整个施工结束。</p><h2 id="强制-HTTPS-访问"><a href="#强制-HTTPS-访问" class="headerlink" title="强制 HTTPS 访问"></a>强制 HTTPS 访问</h2><p>在做如上配置之后你会发现网站既可以通过 http 也可以通过 https 访问，如何强制使用 https 访问呢？也很简单，只需要再给 Nginx 站点配置中添加一条新的规则。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name &#123;域名&#125;;</span><br><span class="line">    return 301 https:&#x2F;&#x2F;&#123;域名&#125;$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 301 跳转的方式将非 https 的访问变更为 https 方式实现了强制 https 访问。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HTTPS-原理&quot;&gt;&lt;a href=&quot;#HTTPS-原理&quot; class=&quot;headerlink&quot; title=&quot;HTTPS 原理&quot;&gt;&lt;/a&gt;HTTPS 原理&lt;/h2&gt;&lt;p&gt;HTTPS 相比 HTTP 而言多了一个 s，也就是 SSL（Secure Sockets Layer），安全套接层。SSL 做的事情就是将用于通信的对称加密密钥进行非对称加密，以此来实现高效且安全的通信。整个 HTTPS 通信的时序图如下，包含了 HTTPS 四次握手。&lt;/p&gt;
    
    </summary>
    
      <category term="Server" scheme="https://ufolux.github.io/categories/Server/"/>
    
    
      <category term="https" scheme="https://ufolux.github.io/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>从无到有，开发一个 App（二）--- 技术选型以及前期准备</title>
    <link href="https://ufolux.github.io/2019/06/17/Experiences/zeroToOneDevApp-2/"/>
    <id>https://ufolux.github.io/2019/06/17/Experiences/zeroToOneDevApp-2/</id>
    <published>2019-06-17T13:01:06.000Z</published>
    <updated>2021-03-11T07:20:00.090Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="0x00-目标产品决定技术方案的选择"><a href="#0x00-目标产品决定技术方案的选择" class="headerlink" title="0x00 目标产品决定技术方案的选择"></a>0x00 目标产品决定技术方案的选择</h2><h3 id="短生命周期和长生命周期产品"><a href="#短生命周期和长生命周期产品" class="headerlink" title="短生命周期和长生命周期产品"></a>短生命周期和长生命周期产品</h3><p>短生命周期的产品通常要求快速起步并在短时间内出品，目的性极强，技术门槛低、代码随便写、不用考虑任何最佳实践。当它的使命结束时，这些代码会被直接抛弃。比如 项目 Demo，临时活动专用 App。 所以，对于这类产品类似前苏联式的 “快糙猛” 的技术是较好的选择。当然能 “快精猛” 更佳，但在现实的短周期开发中实际上很难做到。</p><p>而长生命周期的产品则会对可维护性和可扩展性要求十分强烈，因为它们在相当长的时间内都是无法报废的。甚至对于一些关键的生命线产品，连项目重写都会要求在重写期间线上系统要万无一失地平稳度过，完全平滑地迁移到新技术。这种高水平的要求对团队的工程化能力是个极端的考验。如果工程以及项目管理能力有限，其代价不比用新技术重新写一个功能相同的系统更低。</p><span id="more"></span><h3 id="探索型和成熟型的产品"><a href="#探索型和成熟型的产品" class="headerlink" title="探索型和成熟型的产品"></a>探索型和成熟型的产品</h3><p>探索型产品往往也是短周期产品，但这类项目与上面所说的用后即丢的产品有着显著区别，为了尽快打开或者占领市场它要求开发速度尽可能快，但往往同时也会对质量有高要求。因为探索型的产品的可行性如果得到肯定，那么它很有可能会转型为一个长生命周期项目。</p><p>在我看来对于这种项目的最理想实践应该是由一个资深的架构师设计一个可扩展性和可维护性都很强的核心系统架构，其他功能点的开发完全基于这个高度灵活可维护的架构。这一点其实很多客户端和前端开发框架（尤其是前端框架）可以帮我们做到。</p><p>另一个方面是进行这样的开发时，我们需要一套随项目演进的单元测试以及自动化回归测试系统来保证项目在未来演进时的可靠性。因为探索性的项目一旦如期转换为一个长周期项目，那么对项目的可靠性和可维护性要求会变高。由于先前开发十分迅速，代码质量以及模块结构的设计可能并不能适应日益变化的需求，这就需要大量的重构和重写的工作，但是在项目蒸蒸日上的阶段这样的工作很可能上导致严重的 BUG，那么自动化的质量控制甚至自动化的重构工具都是可以提升软件质量的途径。</p><p>不过，也可以采取十分激进的“快糙猛”的战术，但这要求团队要做好项目中期维护成本上升，维护难度变大的心理准备，更严重的是可能不得不面临全部重写的局面。</p><p>而对成熟型产品的选型则会侧重于与团队现有技术栈的相似程度和与现有项目无缝整合的能力。如果整合的过程中有很大的侵入性，或者所用技术需要大量 hack，那么很可能这种技术方案对项目来说是一个大坑。</p><p>在引入新技术的过程中，也应该尽可能符合现有的开发流程、基础设施和开发的习惯。如果这些旧的方案已经严重过时，则可以联合老技术方案的核心开发一起来规划一个进化路线图，让老技术平稳过渡到相对较先进的技术方案。还有要说的是，如果老技术已经有新版本，应该优先考虑升级到新版本。幻想换个技术栈就能解决一切问题是不切实际的。事实上由于新技术产生时间短，社区规模可能较小，应用规模不大，问题未能广泛暴露导致由新技术带来的问题往往会更多，甚至会遇到无法以合理代价解决的问题。比如 iOS 引入的 WKWebkit 带来的 Cookie 以及 API 方面的问题，又或者 RN 方案导致无法直接使用依赖 DOM 的前端框架（比如 Highcharts 图表库）。</p><h3 id="边缘产品和生命线产品"><a href="#边缘产品和生命线产品" class="headerlink" title="边缘产品和生命线产品"></a>边缘产品和生命线产品</h3><p>在人员的学习能力和意愿允许的前提下，边缘产品是最佳的试验场，适合探索各种候选技术，试验各种激进方案，积累经验教训。其影响范围可控，即使失控也不会带来太大的损失。当然，即使探索，也应该有计划地探索，不要每个边缘产品都采用不同的技术方案，那样会给人才供应带来巨大的挑战。</p><p>而生命线产品则应该稳妥优先，采用保守方案。所以应该优先采用团队内部积累了一定经验或具有稳定的强力外援的技术。</p><p>所有的生命线产品几乎必然是长周期产品，所以其可维护性同样是重中之重。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在目标产品维度上，低价值产品优先考虑门槛低的技术，但是高价值产品应该尽早进行投资性技术积累，优先考虑一些天花板高的技术，这样才不至于在若干年之后因为各种原因（团队技术能力进化空间方面或者项目维护方面）被迫重写。由于项目年久月深，如果工程化能力不足，这种重写往往会成为灾难。</p><h2 id="0x01-几种主流的客户端技术方案"><a href="#0x01-几种主流的客户端技术方案" class="headerlink" title="0x01 几种主流的客户端技术方案"></a>0x01 几种主流的客户端技术方案</h2><p>在客户端开发技术快速演进的几年里，许多技术方案涌现了出来。在众多的技术方案的更新迭代中，我们可以发现一些规律。这些技术的关注点主要都在解决跨平台和热更新的问题。早期关于热更新的探索产生了 JSPatch， OCScript 等方案。而这种对于热更新的探索的研究慢慢拓展到了和跨平台特性结合的研究中，而我们熟悉的 Xamarin, Cordova，ReactNative，Weex 以及最近比较热门的 Flutter 都是这些研究催生的产物。</p><p>相对一般的 App 而言，游戏客户端在上面的道路上早已经走得很远了，Cocos2d-x, Unity3d, Unreal Engine 等及跨平台和热更新及一身的引擎层出不穷，不过这些不是我们讨论的重点。至于为什么不会用游戏引擎来开发 App，请参见知乎上的<a href="https://www.zhihu.com/question/46490922">这个回答</a></p><h3 id="纯原生-JSPatch"><a href="#纯原生-JSPatch" class="headerlink" title="纯原生 + JSPatch"></a>纯原生 + JSPatch</h3><p>这种方案是一种支持热更新的终端开发方案，这项技术诞生于 2015-2016 年左右的 iOS 平台。主要应用的还是 iOS 和 安卓的原生开发技术，在此基础之上辅以 JS 代码为载体的热更新机制。热更新的主要原理是通过 JavaScriptCore 来执行开发者下发的 js 脚本，将包含在脚本中的 OC 代码端提取出来。再通过 Objective-C 的运行时的反射特性，修改类，方法的实现；创建新的协议，类或者方法；在运行时加载原来没有的运行库等等。</p><p>这个方法非常灵活，几乎可以解决一切的原生补丁问题。但这种过于灵活的性质也让 JSPatch 变得十分危险。应用基于这种方式可以绕过 AppStore 的审核实现对系统私有 API 的调用，从而破坏 iOS 的沙盒机制，威胁到用户的安全。这也是苹果所不允许的，目前使用这项技术的应用基本无法通过 AppStore 上架审核。</p><h3 id="Xamarin"><a href="#Xamarin" class="headerlink" title="Xamarin"></a>Xamarin</h3><p>Xamarin 最初是由 Xamarin 公司开发提供的一基于 Mono（一个 C# 跨平台开发方案）的 iOS 和 Android 应用开发的解决方案。2015<br>年这套方案被微软收购，成为 Visual Studio 中的一个组件。</p><p>虽然它实现了两端代码都用 C# 编写，但是对于平台相关的 API， Xamarin 只是做了翻译，而并没有去试图抹平平台间的差异。也就是说虽然你可以用 C# 编写一些公用的业务逻辑代码，但是平台相关的代码依然要写两份。虽然这样相对较薄的封装有利于应对平台日后的发展和变化，但是对于开发者来讲，依然没有显著降低学习成本。而且最致命的问题是它的社区不活跃，软件相对封闭遇到棘手问题的时候很难迅速解决。</p><h3 id="ReactNative"><a href="#ReactNative" class="headerlink" title="ReactNative"></a>ReactNative</h3><p>React Native 确实是最近最火的跨平台App解决方案了。它脱胎于React，因为 React 基于 Virtual DOM 来进行界面渲染，所以用 Native 的 View 来替换掉原本 React 的 HTML DOM 就形成了 React Native 这个框架。</p><p>虽然大部分代码是平台无关的，但是平台相关的代码都交由开发者进行统一的封装和实现，这虽然对跨平台带来了不便，但是引入的好处也是显而易见的，View层的部分通过原生组件实现，性能相对 H5 页面来说要高不少。</p><p>RN 对于热更新也是十分友好的，由于 RN 的全部 js 代码都会被打包在一个 jsbundle 资源文件中，所以我们只需要下载并且替换 jsbundle 文件即可实现对 js 业务逻辑的更新。</p><p>但是 RN 也不是没有缺点，首先 RN 提供了一个类似 CSS 的样式系统，但是由于平台差异以及官方开发力度的问题，这套布局系统存在很多兼容性问题，bug 以及缺少很多必要样式的支持。有些问题在开发中会变成一个阻塞性的障碍，即便有解决方案，实现可能也会是极其复杂的。</p><p>再者，由于没有 DOM，也不支持标准的 SVG，许多涉及 UI 操作的 js 框架都是无法在 RN 中工作的。有人会说，不能用的话就自己写一个呗，那么比如 Highcharts 这种极其复杂的图表框架，显然不是所有团队都有能力和时间随随便便重写一个的，那么这时候就不得不用 webview 来展示这些必要的视图，这样一开实际上开发效率是很差的。</p><p>调试能力不足，开发基础设施差也是一个不能忽视的问题，基于 Chrome Dev Tool 的调试工具经常会莫名其妙的用掉 6，7GB 内存，甚至整个电脑都被拖得变卡。调试需要将手机和电脑连接到同一网段，安卓机需要手动运行 adb 命令才可以实现调试。调试器也经常卡死，尤其是调试进行到最关键阶段的时候，调试器突然变得很卡，单步调试都变得极为困难，这会让人有一种要疯掉的感觉。</p><p>还有一个严重的问题是，RN 框架迟迟未能进入 Release 版本。各种破坏性的改动依然在每个新版本中出现，这就导致框架更新变得十分困难。而且不知出于什么原因，RN 的新版本中经常会出现以前旧版本中已经修改过的 bug，作为一个框架来讲这样的稳定性和维护的水平实在是值得推敲。</p><h3 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h3><p>Flutter 是谷歌研发的一个新的跨平台开发技术，使用 Dart 强类型语言作为开发语言。作为谷歌的下一代操作系统 fuchsia 的应用开发框架，的被谷歌寄予厚望。目前 1.0 版本已经释放出来，也有一些 App 将这个框架用在生产环境中，比如<a href="https://www.infoq.cn/article/VBqfCIuwdjtU_CmcKaEu">闲鱼</a>。</p><p>框架的优点，可以在网上搜一下，有很多布道文章都在吹捧 Flutter, 这里讲一些我认为 Flutter 可能存在的局限性。</p><ol><li><p>不支持热更新，由于 Flutter 在 Release 模式下使用 AOT 方式运行，实际上就是将 Dart 编译成机器码直接在 Dart 虚拟机上执行，这样的运行方式就导致无法通过下发补丁包的方式来直接更新代码。官方曾经在 2019 年的 Roadmap 中提出要关注热更新的问题，但是最近官方也由于苹果的政策问题以及性能问题正式<a href="https://juejin.im/post/5cce88c8f265da039a3d816a">放弃</a>了热更新的开发。</p></li><li><p>无法与现有的前端技术社区提供的解决方案兼容，由于使用了 Dart 和 Dart 虚拟机，Flutter 完全不支持 js 库，而 Dart 库又远远不及 js 库那样丰富。</p></li><li><p>对于图表和图形类的应用，支持十分有限，目前还没有任何完善的图表和图形库支持 Flutter。</p></li><li><p>由于 Flutter 底层完全使用 Skia 绘图引擎来代替各个平台提供的视图组件，Flutter 无法很好地和原生视图一起工作，常见的场景比如嵌入式的地图组件在 Flutter 中的实现会变得异常复杂，甚至无法实现。</p></li><li><p>bug 依旧较多，项目仍不稳定，尚未解决的 Issue，截止现在还有 6018 个之多。而且 Flutter 应用的底层技术较为复杂，一旦框架出现问题，难以解决。</p></li></ol><h3 id="Webview-方案"><a href="#Webview-方案" class="headerlink" title="Webview 方案"></a>Webview 方案</h3><p>Webview 方案是一个比较早期的跨平台方案，大多数 App 也都或多或少会用到 Webview。使用这一方案作为跨平台 App 解决方案的框架，最出名的就是 Cordova 了。虽然这是个很老的技术，但在我的理解来看，即便在今天依然可以发挥它的作用。尤其是多 Webview 的模式，甚至可以解决很多其他方案解决不了的难题。</p><p>直接使用各个平台内建的 Webview，再辅以 JavaScriptBridge 用于 Web 和原生层之间的通信是这个技术方案的基本原理。使用标准的浏览器，可以让开发者将更多地经历放在前端开发商，而且开发者的选择也更加丰富，只要是 js 组件基本上就都可以随心所欲的使用。</p><p>Cordava 基于 Argular2+ 和 AngularJS，使用单页面模式开发，在实践中动画性能存在一些问题，尤其是在安卓平台的页面切换过程中，卡顿尤为明显。 </p><p>由于 Webview 本身可以是一个原生页面，多 Webview 的方式不但可以实现保持页面的状态，并且可以直接使用原生的页面切换动画已达到和原生 App 近似的使用体验。</p><p>热更新同样也不是难题，对于页面文件放在本地的方案，我们只需要更新这些文件即可。如果有的页面被放在远端，那么我们无需考虑热更新的问题，只要将新版本的页面进行发布就可以实现全量客户端的更新。</p><h2 id="0x02-架构设计"><a href="#0x02-架构设计" class="headerlink" title="0x02 架构设计"></a>0x02 架构设计</h2><p>对于客户端的架构设计，我觉得可以简单分为三个大块，第一块内容是客户端系统结构的设计，这部分要解决的问题是，客户端要采用哪些技术，每项技术在系统中处于什么层次，负责什么样的功能；第二块是 UI 框架，包括设计一个合理的可扩展的主题系统，以及扩展性较强的基本组件封装；第三块是对数据流的管理，主要任务是解决如何设计数据流动的路径，让应用在长期发展的过程中保持好的可维护性。</p><h3 id="系统结构"><a href="#系统结构" class="headerlink" title="系统结构"></a>系统结构</h3><p>系统中会涉及到原生和非原生的系统组件，原生组件应该承担诸如 SDK 接入，系统能力调用，通用接口实现等职责，而 UI 相关的能力应该尽量放到非原生或者说跨平台的部分实现，这样可以降低开发的成本。但是遇到 UI 的性能瓶颈，不得不使用原生开发的情况应属例外。</p><h3 id="UI-框架"><a href="#UI-框架" class="headerlink" title="UI 框架"></a>UI 框架</h3><p>由于 UI 的定制化程度和变化的可能性都很高，这一层可以做的比较薄，实现一个轻量的主题系统同时只对基本组件进行简单封装，尽量薄的封装可以提供很强的扩展性和可维护性。</p><h3 id="数据流管理"><a href="#数据流管理" class="headerlink" title="数据流管理"></a>数据流管理</h3><p>软件架构的一个重要任务之一就是组织应用中的数据流，组织应用数据流的方法多种多样，常用的有 MVC，MVVM，Redux 等。</p><center>![Alt text](bfebe9bc-902e-4550-b295-0c8b8bece03b.png)</center><center>MVC</center><p>这个模式认为，程序不论简单或复杂，从结构上看，都可以分成三层。</p><ol><li>View 传送指令到 Controller</li><li>Controller 完成业务逻辑后，要求 Model 改变状态</li><li>Model 将新的数据发送到 View，用户得到反馈</li></ol><center>![Alt text](f4ece01a-6eb4-427d-a07b-d748dd465ba1.png)</center><center>MVVM</center><ol><li><p>各部分之间的通信，都是双向的。</p></li><li><p>View 与 Model 不发生联系，都通过 ViewModel 传递。</p></li><li><p>View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 ViewModel 非常厚，所有逻辑都部署在那里。View 和 ViewModel 之间通过双向绑定来实现数据的同步。</p></li></ol><center>![Alt text](918e01e3-1182-4330-b695-e0a8280fa646.png)</center><center>Redux</center><p>关于 Redux 的概念，可以参见<a href="https://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html">这篇文章</a></p><p>三种模式各有各的优缺点，网上的分析也很多，这里我不想重复这些内容，下面谈一点我自己的感受。</p><p>网上很多观点认为 MVVM 是 MVC 的进化，主要的论点是说 MVC 会导致 Controller 中代码过于臃肿。而 MVVM 的双向数据绑定以及 View 和 Model 的解耦解决了这个问题。其实多了解一些信息就会发现 MVC 模式并不只一种形式，还有很多其他的变形。有一些变形比如 MVP<br><img src="/2019/06/17/Experiences/zeroToOneDevApp-2/dac89d01-888c-45e3-8b16-da6ee8bc7c91.png" alt="Alt text"><br>和 MVVM 十分相似。难道只是在三者之间简单改变数据流向或者添加数据绑定就可以解决 controller 臃肿的问题吗？我认为还是远远不够的，真正解决问题还是需要将业务逻辑从 controller 中分散出来，分散到 service, adaptor, model 中去才能解决臃肿的问题。而数据绑定只是减少了更新数据的逻辑，这部分逻辑其实相对而言只占用了少数的代码量，并不能从根本上解决问题。</p><p>Redux 看似简洁明了，单向数据流很清晰。但实际上自定义 Action 和为了保障数据不可变性而编写的大量模板代码让开发过程略显繁琐。</p><p>因此，我认为设计架构不光要遵守某种教条的逻辑，更重要的是思考问题发生的根源，然后在一个基础上去改进设计。</p><h2 id="0x03-准备脚手架"><a href="#0x03-准备脚手架" class="headerlink" title="0x03 准备脚手架"></a>0x03 准备脚手架</h2><h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><p>在创建视图，控制器或者数据模型的时候的时候免不了要写许多模板代码。软件工程的前辈们告诉我们，能够让电脑自动完成的事情就不要手动去做。代码生成器就是一个能够很大程度上解放生产力的工具。一旦开发模式固化下来，就应该着手去写一个这样的工具供开发人员使用。一键生成模板代码是一件非常爽的事情，大家可以将更多的时间和精力投入到有效的业务代码开发中。而且自动化的工具在很大程度上可以防止低级错误的出现，在这个层面上也有助于提升软件质量。</p><h3 id="构建方案"><a href="#构建方案" class="headerlink" title="构建方案"></a>构建方案</h3><p>作为客户端项目来说，构建打包是一个必经的过程。对于小型项目来讲，可能构建和打包就是点击一下 IDE 上的 <code>Build</code> 按钮这么简单。但是对于有复杂依赖的大型项目来讲，构建就是一个过程很繁琐的过程，远不是单纯依靠 IDE 可以实现的。</p><p>以一个成熟的 ReactNative 项目为例，构建和打包需要经历以下几个过程：</p><ol><li>安装 iOS / Android 依赖包</li><li>安装 js 依赖包</li><li>进行代码质量检查</li><li>构建 ReactNative 资源包</li><li>对资源包进行签名</li><li>为资源包添加平台以及版本号信息</li><li>ReactNative 资源包压缩</li><li>将 ReactNative 资源移动到原生资源目录</li><li>构建 iOS / Android 项目原生代码（在此过程中需要确保 iOS 证书的正确性，如果在开发者账户中添加了新的设备 ID 需要更新证书以确保构建包可以在目标设备上使用）</li><li>为构建结果添加版本以及构建时间等信息</li><li>将构建结果输出至目标路径</li><li>清理工作空间</li></ol><p>可以看到想要得到一个可安装的 ReactNative App 包要经历如此复杂的步骤，这些步骤如果是依赖手动操作的话，想必几乎不可能一次性没有失误地通过。而构建脚本就是来解决这个问题的一个手段。</p><h4 id="shell-脚本"><a href="#shell-脚本" class="headerlink" title="shell 脚本"></a>shell 脚本</h4><p>由于涉及到的很多操作基于操作系统提供的工具链以及其他应用提供的命令行界面才能完成，编写 shell 脚本是打造一个构建方案的必备能力。但是 shell 脚本有先天的劣势，语法较现代语言来讲比较晦涩，语法的容错性和灵活性也比较差，多一个或者少一个空格就会导致语句无法执行。调试也只有日志输出这个唯一的办法。在构件流程随着项目发展越发复杂的时候，shell 脚本较差的可维护性会变成项目的一个炸弹，可能在某次修改之后，构建会产生意料之外的结果进而造成质量问题。</p><h4 id="fastlane"><a href="#fastlane" class="headerlink" title="fastlane"></a>fastlane</h4><p>为了解决单单依靠 shell 带来的问题，fastlane 被发明了出来，虽然在操作系统的框架之上，使用 fastlane 的构建过程也不能摆脱依赖 shell 的命运，但是由 ruby 编写的 fastlane 针对客户端构建提供了很多包装好的 ruby 方法，包括调用构建工具，执行 shell 指令，解决 iOS 证书相关问题等。使用这些方法可以方便地使用现代语言实现一些功能。即便当你不得不使用 shell 的时候，fastlane 提供的 shell 脚本包装方法也有助于将 shell 脚本产生的问题控制在最小的区域。统一的异常处理机制为脚本的可靠性提供了有力的保障。</p><h2 id="0x04-参见"><a href="#0x04-参见" class="headerlink" title="0x04 参见"></a>0x04 参见</h2><ol><li><a href="https://fastlane.tools/">Fastlane</a></li><li><a href="https://www.zhihu.com/question/46490922">用游戏引擎(如Unity)开发一款App应用有什么优势或劣势？</a></li><li><a href="https://www.infoq.cn/article/VBqfCIuwdjtU_CmcKaEu">闲鱼开源 FlutterBoost：实现 Flutter 混合开发</a></li><li><a href="https://juejin.im/post/5cce88c8f265da039a3d816a">坏消息：Flutter官方暂时不会开发热更新（Code push）了。</a></li><li><a href="https://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html">Redux 入门教程（一）：基本用法</a></li><li><a href="https://blog.csdn.net/troubleshooter/article/details/78479984">贫血充血模型</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-目标产品决定技术方案的选择&quot;&gt;&lt;a href=&quot;#0x00-目标产品决定技术方案的选择&quot; class=&quot;headerlink&quot; title=&quot;0x00 目标产品决定技术方案的选择&quot;&gt;&lt;/a&gt;0x00 目标产品决定技术方案的选择&lt;/h2&gt;&lt;h3 id=&quot;短生命周期和长生命周期产品&quot;&gt;&lt;a href=&quot;#短生命周期和长生命周期产品&quot; class=&quot;headerlink&quot; title=&quot;短生命周期和长生命周期产品&quot;&gt;&lt;/a&gt;短生命周期和长生命周期产品&lt;/h3&gt;&lt;p&gt;短生命周期的产品通常要求快速起步并在短时间内出品，目的性极强，技术门槛低、代码随便写、不用考虑任何最佳实践。当它的使命结束时，这些代码会被直接抛弃。比如 项目 Demo，临时活动专用 App。 所以，对于这类产品类似前苏联式的 “快糙猛” 的技术是较好的选择。当然能 “快精猛” 更佳，但在现实的短周期开发中实际上很难做到。&lt;/p&gt;
&lt;p&gt;而长生命周期的产品则会对可维护性和可扩展性要求十分强烈，因为它们在相当长的时间内都是无法报废的。甚至对于一些关键的生命线产品，连项目重写都会要求在重写期间线上系统要万无一失地平稳度过，完全平滑地迁移到新技术。这种高水平的要求对团队的工程化能力是个极端的考验。如果工程以及项目管理能力有限，其代价不比用新技术重新写一个功能相同的系统更低。&lt;/p&gt;
    
    </summary>
    
      <category term="经验" scheme="https://ufolux.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="从无到有，开发一个 App" scheme="https://ufolux.github.io/tags/%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%EF%BC%8C%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA-App/"/>
    
  </entry>
  
  <entry>
    <title>从无到有，开发一个 App（一）---在开发之前我们要想些什么</title>
    <link href="https://ufolux.github.io/2019/06/09/Experiences/zeroToOneDevApp-1/"/>
    <id>https://ufolux.github.io/2019/06/09/Experiences/zeroToOneDevApp-1/</id>
    <published>2019-06-09T14:01:06.000Z</published>
    <updated>2021-03-11T07:20:00.084Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="0x00-Before-takeoff"><a href="#0x00-Before-takeoff" class="headerlink" title="0x00 Before takeoff"></a>0x00 Before takeoff</h2><p>在这个 App 泛滥的时代，从无到有开发一个 App 看似是一个很简单的事情，网上也有大把的教程来告诉你如何开发各种 App 和网站等等。但是在实际工作中，当我们提到“做一个 App”的时候，含义却十分深奥，那么这个坑到底有多深呢？我希望能够通过几篇文章的篇幅来做一个简要的叙述。</p><p>要说明的是，这个系列的文章并不会和网上大量的 App 开发指南类文章一样只是简单着眼于技术细节。而是通过对几年工作经验的总结来讲述当你在一个企业中从事客户端或者前端开发工作，面临一个全新的 App 开发任务时需要如何从头开始考虑整个任务以及流程。</p><p>只是一点微小的见解，希望能够给观众一点帮助。如有考虑不周，欢迎指教；如有失误，请多包涵（作揖）。</p><span id="more"></span><h2 id="0x01-项目有啥背景？"><a href="#0x01-项目有啥背景？" class="headerlink" title="0x01 项目有啥背景？"></a>0x01 项目有啥背景？</h2><p>有一天老板突然跟你讲，来吧，我们要做一个新的 App。作为一个有经验的开发者你一定知道，OK，你将会面临一箩筐需要考虑的问题。但是我们很容易直接陷入技术细节的思考，却忽视了一个重要的问题：这个项目的背景是什么？</p><p>项目的背景，听起来是一个非常泛泛的说法，没错，下面我们来明确一下到底需要留意哪些方面。</p><h3 id="这是一个什么行业的项目"><a href="#这是一个什么行业的项目" class="headerlink" title="这是一个什么行业的项目?"></a>这是一个什么行业的项目?</h3><p>不同行业不同功能的 App，同时也是面向不同用户群体的 App，这些不同点会影响 <strong>潜在的需求</strong> 以及日后的 <strong>技术选型</strong> </p><h3 id="潜在的用户量"><a href="#潜在的用户量" class="headerlink" title="潜在的用户量"></a>潜在的用户量</h3><p>用户的规模大小也会对开发产生影响，一般来讲金融行业的 App，有效用户数量相对而言都比较少，以我之前在某基金公司实习时开发的某基金 App 来看，用户量基本处于 40-50w 的水平。但是对于现象级的互联网娱乐产品来讲，亿级用户是十分普遍的。用户规模的大小会对 App 设计的理念，需求的优先级带来影响，从而影响开发成本和开发的节奏。用户群体庞大的 App 可能需要将所有功能都做得很完善之后才敢对外发布，反之的话，就可以现将主要功能做到可用，其他次要问题可以迭代优化解决。</p><h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><p>对于可用性，一般来讲都是要求比较高的，毕竟可用性越高用户流失的几率越小。这里讨论的是对于可用性保障的程度。如果我们做的是一个八卦新闻 App，那么对于它的可用性要求相对支付宝这样的 App 来讲就会低一些。可用性要求的高低会影响到软件设计者在开发初期采用什么样的策略来保障可用性。</p><p>可用性保障的方式有很多，包括异常上报，闪退检测（安卓甚至可以闪退后主动拉活 App），崩溃恢复，异常恢复，热更新修复，功能降级，可用性测试，更深层次的还有 App 问题自动修复（数据修复，版本回滚）等等。</p><p>有关的技术方案可以参见<a href="http://developer.51cto.com/art/201712/561341.htm">亿级APP支付宝在移动端的高可用技术实践</a></p><p>在这么多手段中，显然实现的难度和维护的成本是有巨大差异的。到底选择哪一种，也需要结合 App 的定位来分析</p><h3 id="实时性"><a href="#实时性" class="headerlink" title="实时性"></a>实时性</h3><p>以金融行业为例，金融行业涉及到众多金融资产的流转和存储，所以交易功能和资产的浏览几乎是每个金融类 App 的最主要功能。由于这两个操作都和客户的财产安全紧密相关，那么我们的 App 需要非常高的实时性以保证客户可以实时看到名下资产的变动状况，以便准确地处理交易。否则很容易出现投诉等情况。这一点也深刻地影响着 App 的缓存策略设计。</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>有些安全性的操作比较繁琐甚至会带来高昂成本，比如安卓加固，项目对安全性的要求也是在项目初期需要探讨的问题。</p><h3 id="出现问题的后果严重性"><a href="#出现问题的后果严重性" class="headerlink" title="出现问题的后果严重性"></a>出现问题的后果严重性</h3><p>这方面问题的探讨主要是为了发现系统中最不能出问题的地方在哪里，也就是一旦出现问题后果最严重的部分是什么。对于这些功能点可以设计兜底方案，也就是功能的降级处理，确保即便出现问题也能够挺过去。</p><h3 id="项目中各方的利益是怎样的？"><a href="#项目中各方的利益是怎样的？" class="headerlink" title="项目中各方的利益是怎样的？"></a>项目中各方的利益是怎样的？</h3><p>这个问题在小公司一般不存在，在大企业中由于各个部门是不同的利益实体，在同一个项目的合作中不同利益实体所能得到的投入产出比一般是很不相同的。所以不得不说，虽说是同一个公司，在同一个项目中合作的团队主观的动能是有相当差距的。这里说这个问题并不是想批评公司的弊病之类，只是想表达一个观点，尽早明确各方利益关系有助于提前发现项目的风险点。比如，某团队在开发流程的关键路径上，但是这个团队对项目的主管动能明显不足，那么就很有可能在这个位置上出现重大风险，提前预计到这些风险对项目的规划和安排很有帮助。</p><h2 id="0x02-有什么隐藏的坑？"><a href="#0x02-有什么隐藏的坑？" class="headerlink" title="0x02 有什么隐藏的坑？"></a>0x02 有什么隐藏的坑？</h2><h3 id="小心隐藏的需求"><a href="#小心隐藏的需求" class="headerlink" title="小心隐藏的需求"></a>小心隐藏的需求</h3><p>往往会在开发进行到后期才会提出，这时已经为时已晚，措手不及<br>比如 </p><ol><li>是否有特殊的安全需求？比如，接入其它安全插件等等。</li><li>是否需要热更新和修复的能力？</li><li>异常处理的方式是怎样的？比如，网络异常，服务器错误，应用崩溃闪退等等。</li><li>网络状态切换是否需要判断和提示？</li><li>是否支持多国语言？</li><li>是否会规划类似夜间模式，更换皮肤的功能？</li><li>数据实时性要求，涉及到缓存系统的设计。</li></ol><h3 id="需求变化的可能性"><a href="#需求变化的可能性" class="headerlink" title="需求变化的可能性?"></a>需求变化的可能性?</h3><p>需求经常变化一定会导致软件质量不断下降，开发周期被拖长。让需求不断趋于稳定，需要流程的控制和强有力的执行来保证。</p><h3 id="由其他团队提供的技术方案是否完善，是否真的可用"><a href="#由其他团队提供的技术方案是否完善，是否真的可用" class="headerlink" title="由其他团队提供的技术方案是否完善，是否真的可用?"></a>由其他团队提供的技术方案是否完善，是否真的可用?</h3><p>项目中可能要接入某团队提供的 SDK，对于这个问题，我的看法是，首先我们需要知道这些 SDK 的作用是否不可替代？尤其是一些流程简单，但是调试复杂的关键流程，比如登录。再者，提供的技术方案有无文档，有无测试环境，支持人员是否可以及时响应，如果这些基本的保障比较贫乏的话。应该可以确认这里一定是一个坑，要提前规划风险的应对。</p><h3 id="各类账号和证书由谁提供？"><a href="#各类账号和证书由谁提供？" class="headerlink" title="各类账号和证书由谁提供？"></a>各类账号和证书由谁提供？</h3><p>大多数 App 都会关联 QQ 和微信等三方登录，这些第三方平台需要注册开发者账号，有的甚至需要上传营业执照等等公司信息，需要在早期明确责任人，及时申请和处理这些账号资料问题。</p><p>iOS 平台开发和上线需要使用开发者账号和证书，在团队开发的模式下，这些东西需要由团队来统一提供，而非使用某个人的。如果涉及到了公司证书或者企业证书的申请，由于需要申请邓白氏编码和验证公司身份，这两种证书的申请周期相对都比较长，需要尽早明确账号归属者，敦促其尽快申请账号，以免耽误开发流程。</p><p>Android 平台虽然没有开发证书的问题，但是安卓的发布依然是一个很复杂的过程，需要确认发布的渠道，以及申请相应发布渠道的账号。</p><h3 id="测试包如何分发？"><a href="#测试包如何分发？" class="headerlink" title="测试包如何分发？"></a>测试包如何分发？</h3><p>测试包分发最重要的是权限的控制方式，公司内部是否有成熟的可控权限的安装包分发平台？如果需要使用外部平台，权限控制则可能需要后台配合在 App 中以邀请码或者体验账户方式来实现。金融机构的分发还涉及到是否合规，以及安全审计，这些也都是要考虑的范畴。</p><h2 id="0x03-团队擅长什么技术？"><a href="#0x03-团队擅长什么技术？" class="headerlink" title="0x03 团队擅长什么技术？"></a>0x03 团队擅长什么技术？</h2><h3 id="设计和交互团队是否擅长-App-设计？"><a href="#设计和交互团队是否擅长-App-设计？" class="headerlink" title="设计和交互团队是否擅长 App 设计？"></a>设计和交互团队是否擅长 App 设计？</h3><p>UI 设计在很多方面与平面设计或者其他行业的设计工作在流程，出品规格，工作流程上都有不同。</p><p>交互和设计上主要考虑几个点</p><ol><li>是否有成熟可用的工作流程</li><li>出品的规格是否能够符合开发要求</li></ol><p>这两点在很大程度上会影响到开发的进展，以及开发的工作量。</p><h3 id="原生开发者是必不可少的"><a href="#原生开发者是必不可少的" class="headerlink" title="原生开发者是必不可少的"></a>原生开发者是必不可少的</h3><p>客户端项目需要原生开发的参与，如果没有原生开发者，那么在技术架构上应该将重心偏向于跨端技术栈，尽量减少原生的工作量。<br>但对于 App 项目来说，原生开发者依然是必不可少的存在。</p><h3 id="前端技术栈"><a href="#前端技术栈" class="headerlink" title="前端技术栈"></a>前端技术栈</h3><p>团队更侧重于什么框架的使用？ Vue，React 还是 Angular。<br>成员是否有强类型语言经验？如果有强类型语言经验，Typescript，Dart 等强类型语言会是一个有意义的选择。</p><h3 id="前后端交互技术"><a href="#前后端交互技术" class="headerlink" title="前后端交互技术"></a>前后端交互技术</h3><p>在网络通信方面熟悉什么样的技术？<br>RESTful API，Socket，GraphQL，Protocol Buffers 等等</p><h2 id="0x04-制定开发规约"><a href="#0x04-制定开发规约" class="headerlink" title="0x04 制定开发规约"></a>0x04 制定开发规约</h2><h3 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h3><p>这部分有很多现成的方案，谷歌，微软，FB，Airbnb 都有贡献过关于代码规范的资料。但这些规范并不是拿来就用，需要针对团队的习惯和项目的要求进行修改。</p><h3 id="流程规范"><a href="#流程规范" class="headerlink" title="流程规范"></a>流程规范</h3><p>流程规范的问题涉及到开发迭代的流程，需求变更的流程，代码修改的流程，代码提交的流程，打包测试，发布上线的流程。<br>这些问题都需要提前做一个框架性的约定，而且在开发过程中需要不断地完善改进。</p><p>关于代码提交的流程，可以参考<a href="https://www.ruanyifeng.com/blog/2015/08/git-use-process.html">Git 使用规范流程</a></p><h3 id="开发规约要容易实施"><a href="#开发规约要容易实施" class="headerlink" title="开发规约要容易实施"></a>开发规约要容易实施</h3><p>制定规范是为了保证出品的质量最大限度不受低级错误影响，在这个话题下，我特意强调了<strong>容易实施</strong>这几个关键字。为什么要做这个强调呢？如果大家有使用或者查看过各种代码规范或者开发规范的话，不难发现，有相当多的条条框框可以运用到开发过程中。但是结合实际的团队状况来看的话，由于大家对规范的看法不同或者出于个人开发习惯的不同，在一些议题上大家是很难达成一致的。举个栗子，编辑器和 IDE 的统一，除了 iOS 开发大家必须要用 Xcode 别无选择之外，几乎任何平台或者语言的开发可用的编辑器和 IDE 都有浩如烟海的可选项。在我们现在的条件下不可能要求大家能够使用统一的 IDE，即便这有很多好处，比如，可以避免不同编辑器之间由于设定不同为编辑过的文件添加奇怪的属性带来的问题，或者对某些配置文件或者 UI 文件的修改时，不同编辑器会添加不同风格的配置导致混乱。如果我们强制推行这样的方案，会造成很大的迁移成本，有人惯用 eclipse 系列的编辑器，快捷键和各种 panel 的位置都已经十分熟悉了，这时候一下子叫他迁移到 Intellij 系列，熟悉起来还是需要一定的时间，这样就会影响到开发的效率。另一个问题是，我们也无法保证新加入的团队成员能够熟悉某周 IDE，每次有人加入团队可能都会产生一次额外的学习成本。类似这种规范，对于任务紧张而且人数不多的团队我认为不是一个很可行的方案。</p><p>从上面的例子可以看出，并不是所有的方案都能契合自己团队的实际情况，那么有哪些规范是所谓<strong>容易实施</strong>的呢？</p><p>根据我个人的经验来看的话呢，这样的方案有几个特点：</p><ul><li><strong>足够简单，容易记忆</strong><br>越简单的方法越容易记忆，形成长期记忆后就会变成习惯，容易保证措施有效地贯彻落实。同时也方便形成经验，在日后的项目上方也可以及时想到，实施。</li><li><strong>操作便利，步骤简单</strong><br>在操作上要保证步骤尽可能的少，一方面可以保证第一条中说到的优势，另一方面可以保证流程的稳定性，不易出错。</li><li><strong>脚本固化，IDE 无关</strong><br>在第二步的基础上，借助构建脚本或者运维脚本将流程固化下来，实现自动化。注意：这种自动化流程需要与 IDE 解耦（只依赖命令行工具），不要依赖特定的开发工具（比如 Intellij 系列提供的代码检查功能）以实现普适性，在同一项目中零成本复用。</li><li><strong>流程整合，异常报错</strong><br>更进一步，我们可以将上述的自动化过程整合进入构建或者提交流程，在构建流程中完成对代码的合规审查，通过对不符合出口标准的代码抛异常报错来防止不合格代码流入代码库或者进入编译打包的过程。</li></ul><p>说了这么多，举个实际的例子。最常用到的就是 git 的 hook 功能。最理想的做法是在 gitlab 或者其他 git 仓库的服务端来布置 <code>pre-receive</code> hook 脚本，在脚本中集成代码审查的流程即可，当有不合格代码提交到服务器中的时候，该脚本会把这个无法通过审查的提交直接拒绝掉。这样，我们就实现了一个<strong>足够简单</strong>，<strong>无需</strong>开发者本地操作，<strong>使用脚本</strong>将规范的审核自动化，并<strong>集成到代码提交流程中</strong>将不合格代码屏蔽在仓库之外的代码规约过程。</p><h2 id="0x06-一些好用的开发工具推荐"><a href="#0x06-一些好用的开发工具推荐" class="headerlink" title="0x06 一些好用的开发工具推荐"></a>0x06 一些好用的开发工具推荐</h2><p>在这里也分享一下我平时经常使用的一些工具，和原因，个人感觉对效率提升还是十分有效的。</p><ul><li><p>开发机：Mac 电脑 + macOS<br>原生类 Unix 环境，自带 bash，使用 brew 包管理可以安装绝大多数 Linux 平台上的命令行工具，对开发十分友好。</p></li><li><p>编辑器： VSCode<br>之所以推荐一款编辑器，是因为我认为开发中仅仅有 IDE 是不够的，IDE 提供了很多高级功能不假，但是文本操作和对各种格式文件的兼容未必都做得很好。使用 VSCode 提供的灵活的光标移动能力可以提高文本处理的效率，比如批量处理文本的任务，还有文本编辑器一般不会对文件格式有苛刻的要求，遇到想要查看的文件，直接丢到编辑器就可以打开查看了。</p></li><li><p>终端：iTerm2 + zsh + oh-my-zsh<br>iTerm2 是一个很经典的 macOS 终端代替品，实现了很多方便的操作和功能，这里不细说，有兴趣可以查看<a href="http://wulfric.me/2015/08/iterm2/">你应该知道的 iTerm2 使用方法–MAC终端工具</a>。<code>zsh</code> 是一个 bash 代替品，<code>oh-my-zsh</code> 是一套 zsh 配置文件集合，可以帮你省去复杂的 zsh 配置过程，开箱即用，同样不展开，参见<a href="https://blog.csdn.net/timesir/article/details/78158645">zsh教程</a>。</p></li><li><p>Paste 一个剪贴板工具，可以方便的记录和使用剪贴历史，相当于为剪贴板提供了一个置换空间<img src="/2019/06/09/Experiences/zeroToOneDevApp-1/6b286baa-0271-4010-a452-db6a44c79a9c.png" alt="Paste"></p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/35a7b6f5f92e">从客户端的角度设计后端的接口</a><br><a href="http://developer.51cto.com/art/201712/561341.htm">亿级APP支付宝在移动端的高可用技术实践</a><br><a href="http://wulfric.me/2015/08/iterm2/">你应该知道的 iTerm2 使用方法–MAC终端工具</a><br><a href="https://blog.csdn.net/timesir/article/details/78158645">zsh教程</a><br><a href="https://www.ruanyifeng.com/blog/2015/08/git-use-process.html">Git 使用规范流程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-Before-takeoff&quot;&gt;&lt;a href=&quot;#0x00-Before-takeoff&quot; class=&quot;headerlink&quot; title=&quot;0x00 Before takeoff&quot;&gt;&lt;/a&gt;0x00 Before takeoff&lt;/h2&gt;&lt;p&gt;在这个 App 泛滥的时代，从无到有开发一个 App 看似是一个很简单的事情，网上也有大把的教程来告诉你如何开发各种 App 和网站等等。但是在实际工作中，当我们提到“做一个 App”的时候，含义却十分深奥，那么这个坑到底有多深呢？我希望能够通过几篇文章的篇幅来做一个简要的叙述。&lt;/p&gt;
&lt;p&gt;要说明的是，这个系列的文章并不会和网上大量的 App 开发指南类文章一样只是简单着眼于技术细节。而是通过对几年工作经验的总结来讲述当你在一个企业中从事客户端或者前端开发工作，面临一个全新的 App 开发任务时需要如何从头开始考虑整个任务以及流程。&lt;/p&gt;
&lt;p&gt;只是一点微小的见解，希望能够给观众一点帮助。如有考虑不周，欢迎指教；如有失误，请多包涵（作揖）。&lt;/p&gt;
    
    </summary>
    
      <category term="经验" scheme="https://ufolux.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="从无到有，开发一个 App" scheme="https://ufolux.github.io/tags/%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%EF%BC%8C%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA-App/"/>
    
  </entry>
  
  <entry>
    <title>加速 GitHub 访问</title>
    <link href="https://ufolux.github.io/2019/02/06/git/make-github-faster/"/>
    <id>https://ufolux.github.io/2019/02/06/git/make-github-faster/</id>
    <published>2019-02-06T02:26:55.000Z</published>
    <updated>2021-03-11T07:20:00.112Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>经常受困于 GitHub clone 速度过慢的问题，之前有很多号称加速 github 的方法都不是很有效。现在发现一个亲测有效的方法，记录一下。</p><p>打开 hosts 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure><p>在文件末尾添加以下三行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">192.30.253.112     github.com</span><br><span class="line"></span><br><span class="line">151.101.72.133    assets-cdn.github.com</span><br><span class="line"></span><br><span class="line">151.101.193.194    github.global.ssl.fastly.net</span><br></pre></td></tr></table></figure><p>搞定，现在开始享受飞速的 github 体验。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="git" scheme="https://ufolux.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>复习 JavaScript 原型链</title>
    <link href="https://ufolux.github.io/2018/07/11/Front_End/js-fondation/javascript-prototype/"/>
    <id>https://ufolux.github.io/2018/07/11/Front_End/js-fondation/javascript-prototype/</id>
    <published>2018-07-11T13:49:31.000Z</published>
    <updated>2021-03-11T07:20:00.096Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原型链是 JavaScript 里面很基础的概念，面试中和工作中也经常遇到，但是有的时候用起来还是会犹豫一下。尤其是存在继承关系的时候，有时候搞不清楚对象的原型是谁，这里来结合实验详细的梳理一下。</p><p>假设我们有一个 <code>Person</code> 类（构造函数）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">foo () &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用 new 操纵符构造一个新的对象 <code>person</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person()</span><br></pre></td></tr></table></figure><p>那么 <code>person</code> 对象和 <code>Person</code> 的原型链是什么样的呢</p><ol><li><p><code>person.__proto__</code> 指向 <code>Person.prototype</code></p></li><li><p><code>person.constructor</code> 指向 <code>Person</code> 类，因为该对象的构造函数就是 <code>Person</code></p></li><li><p><code>person.constructor.prototype</code> 也就是 <code>Person.prototype</code></p></li><li><p><code>Person.prototype.constructor</code> 指向 <code>Person</code> 自己</p></li><li><p><code>Person.constructor</code> 指向 <code>Function</code></p></li><li><p><code>Person.__proto__</code> 指向 <code>Function.prototype</code></p><p> 至此，Person 类和它的实例对象的原型链基本分析完毕了，接下来我们顺着这条链一直走到底来看一下。</p></li><li><p><code>Person.prototype.__proto__</code> 指向 <code>Object.prototype</code></p></li><li><p><code>Object</code> 实例对象的 <code>constructor</code> 指向 <code>Object.prototype.constructor</code></p></li><li><p><code>Object.prototype.__proto__</code> 是 <code>null</code></p></li></ol><p>下面上一张完整的图，看了这张图，对 js 的原型链就可以一目了然了</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1ft68qb2djhj30nw0i90th.jpg" alt="构造函数原型链"></p><p>总结下就是：</p><ol><li>实例对象的 <code>__proto__</code> 指向类（构造函数）的 <code>prototype</code></li><li>实例对象的 <code>constructor</code> 指向类（构造函数）本身</li><li>类（构造函数）的 <code>__proto__</code> 指向父类或者 <code>Function</code> 的 <code>prototype</code></li><li><code>Function</code> 的基类是 <code>Object</code></li><li>特别的 <code>Object.__proto__</code> 指向一个空函数</li><li>特别的 <code>Object.property.__proto__</code> 是 <code>null</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://ufolux.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>CSS 入门（一）</title>
    <link href="https://ufolux.github.io/2018/05/03/Front_End/css/intro-css-1/"/>
    <id>https://ufolux.github.io/2018/05/03/Front_End/css/intro-css-1/</id>
    <published>2018-05-02T16:07:29.000Z</published>
    <updated>2021-03-11T07:20:00.095Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="0x00-盒模型"><a href="#0x00-盒模型" class="headerlink" title="0x00 盒模型"></a>0x00 盒模型</h2><p>盒模型分为两种，标准模式和怪异模式，他们的定义如下：</p><blockquote><p>标准模式: (box-sizing: content-box)<br>padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和，即 ( Element width = width + border + padding )</p></blockquote><blockquote><p>怪异模式: (box-sizing: border-box)<br>padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值，即使定义有border和padding也不会改变对象的实际宽度，即 ( Element width = width )</p></blockquote><p>怪异模式是 IE 5.x 6.x 中的标准盒模型，虽然叫做怪异模式，但是这种模式的布局模型更符合我们的直觉，所以一般都会将 <code>box-sizing</code> 属性设置为 <code>border-box</code> 。</p><span id="more"></span><p>example:</p><p>content-box</p><blockquote><div style="box-sizing:border-box; width: 50px;height:50px;background:blue;padding:10px;border:5px solid lightblue"></div>div { box-sizing:content-box;  width:200px; height:200px; background:blue; padding:10px; border:5px solid lightblue}</blockquote><p>border-box</p><blockquote><div style="box-sizing:content-box; width: 50px;height:50px;background:blue;padding:10px;border:5px solid lightblue"></div>div { box-sizing:border-box;  width:200px; height:200px; background:blue; padding:10px; border:5px solid lightblue}</blockquote><h2 id="0x01-边距合并"><a href="#0x01-边距合并" class="headerlink" title="0x01 边距合并"></a>0x01 边距合并</h2><p>情况1：<br>当一个元素出现在另一个元素的上面时，第一个元素的下外边距会与第二个元素的上外边距合并，合并后的边距为两个边距中较大的值。</p><p>example:</p><blockquote><div style="width:30px;height:30px;margin-bottom:20px;background:lightgreen;">div1</div><div style="width:30px;height:30px;margin-top:10px;background:lightblue;">div2</div></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.div1 &#123;                             .div1 &#123;</span><br><span class="line">    width:30px;                         width:30px;     </span><br><span class="line">    height:30px;                        height:30px;</span><br><span class="line">    margin-bottom:20px;                 margin-top:10px;</span><br><span class="line">    background:lightgreen;              background:lightblue;</span><br><span class="line">&#125;                                   &#125;</span><br></pre></td></tr></table></figure><p>连个 div 的上边距都合并为 20px 了，既两个边距中较大的值。</p><p>情况2：<br>当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），<br>它们的上和/或下外边距也会发生合并。<br>example:</p><blockquote><div style="width:80px;height:80px;margin-top:20px;background:lightgreen;"><div style="width:40px;height:40px;margin-top:30px;background:green;"></div></div></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.outter &#123;                           .inner &#123;</span><br><span class="line">    width:80px;                         width:30px;     </span><br><span class="line">    height:80px;                        height:30px;</span><br><span class="line">    margin-top:20px;                    margin-top:30px;</span><br><span class="line">    background:lightgreen;              background:green;</span><br><span class="line">&#125;                                   &#125;</span><br></pre></td></tr></table></figure><p>整体的上边距都合并为 30px 了，既两个上边距中较大的值。</p><p>情况3：<br>空元素，它有外边距，但是没有边框或填充。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fqxg7ea476j30fd036745.jpg" alt="Alt text"></p><p>如果这个外边距遇到另一个元素的外边距，它还会发生合并<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fqxg74v62hj30fe042746.jpg" alt="Alt text"></p><blockquote><p>例外情况：<br>只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并</p></blockquote><h2 id="0x02-定位"><a href="#0x02-定位" class="headerlink" title="0x02 定位"></a>0x02 定位</h2><p>浏览器中只有两种定位的层次，普通流和非普通流。相对定位的元素会被放置在普通流中，浮动和绝对定位的元素都不会被放入普通流中。</p><p>在流中的<strong>块级元素</strong>会按照<strong>从上到下</strong>的顺序一个个排列。元素之间的距离根据垂直方向的外边距计算而得。</p><p>在流中的<strong>行内元素</strong>会在行中水平布置。水平方向的间距不会影响行内框的高度，行内框的高度只能通过行高来设置。</p><p>position 为 absolute 的时候，元素会从普通流中脱离，普通流中不会再包含这个元素的空间。此时偏移属性参照的是离自身最近的相对定位祖先元素，如果没有相对定位的祖先元素，则一直回溯到body元素。盒子的偏移位置不影响常规流中的任何元素，其margin不与其他任何margin折叠。</p><p>position 为 fixed 时，和 absolute 一样，只是包含块被指定为视窗本身。</p><blockquote><p>绝对定位元素的默认 top 值是最近一个已经定位元素的底部坐标。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-盒模型&quot;&gt;&lt;a href=&quot;#0x00-盒模型&quot; class=&quot;headerlink&quot; title=&quot;0x00 盒模型&quot;&gt;&lt;/a&gt;0x00 盒模型&lt;/h2&gt;&lt;p&gt;盒模型分为两种，标准模式和怪异模式，他们的定义如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;标准模式: (box-sizing: content-box)&lt;br&gt;padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和，即 ( Element width = width + border + padding )&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;怪异模式: (box-sizing: border-box)&lt;br&gt;padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值，即使定义有border和padding也不会改变对象的实际宽度，即 ( Element width = width )&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;怪异模式是 IE 5.x 6.x 中的标准盒模型，虽然叫做怪异模式，但是这种模式的布局模型更符合我们的直觉，所以一般都会将 &lt;code&gt;box-sizing&lt;/code&gt; 属性设置为 &lt;code&gt;border-box&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="https://ufolux.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>金融衍生工具介绍（二） 牛熊证</title>
    <link href="https://ufolux.github.io/2018/02/22/InvestmentLife/intro-to-derivative-part2/"/>
    <id>https://ufolux.github.io/2018/02/22/InvestmentLife/intro-to-derivative-part2/</id>
    <published>2018-02-22T14:44:03.000Z</published>
    <updated>2021-03-11T07:20:00.103Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="牛熊证（CBBCs）"><a href="#牛熊证（CBBCs）" class="headerlink" title="牛熊证（CBBCs）"></a>牛熊证（CBBCs）</h2><p>牛熊证（合约），全称为 <strong>可收回牛/熊证（合约）</strong>（Callable Bull/Bear Contracts/Certificates）。牛熊证和窝轮很相似，是一种具有期权性质的金融衍生工具，属于结构化金融产品的一种，它的价格和标的资产的价格挂钩。</p><p>牛熊证最早于 2001 年产生于欧洲和澳大利亚的金融市场，香港联交所于 2006 引入了这种新型的投资产品，之后牛熊证在香港证券市场的成交量迅速上升，形成了与窝轮分庭抗礼的局面。目前牛熊证在欧洲和香港的交易十分活跃，受到投资者的热烈追捧。</p><center>![63943](https://ws3.sinaimg.cn/bmiddle/006tNc79ly1fmnmkd14omj30ja0sktel.jpg)<p>一只香港联交所上市的牛证</p></center><span id="more"></span><h2 id="牛熊证的运作方式"><a href="#牛熊证的运作方式" class="headerlink" title="牛熊证的运作方式"></a>牛熊证的运作方式</h2><p>牛熊证（合约），看名字就可以知道有两种类型的合约，一种是牛证（Bull Contract），另一种是熊证（Bear Contract），我们知道在投资市场上 “牛” 是上涨看多的代名词，而 “熊” 恰恰相反，它是下跌看空的代名词。牛证可以类比上一篇文章讲到的认购证，当标的资产价格上涨时，牛证的价格会随之上涨，而熊证的价格会下跌，反之则反。而上涨和下跌的幅度大小和牛熊证的杠杆比率正相关。和权证不同的是，在牛熊证的最后交易日之前，一旦标的资产的价格或者指数触及牛熊证的回收价，牛熊证将被立即收回（平仓）。投资者也将损失全部，或者几乎全部的投资金额。</p><h2 id="牛熊证的基本要素"><a href="#牛熊证的基本要素" class="headerlink" title="牛熊证的基本要素"></a>牛熊证的基本要素</h2><h3 id="发行人"><a href="#发行人" class="headerlink" title="发行人"></a>发行人</h3><p>牛熊证一般由第三人发行，绝大多数情况下是由投资银行或者券商发行的。标的资产的上市主体或者交易所都不能发行牛熊证，这一点和权证有些区别。</p><h3 id="看涨看跌方向"><a href="#看涨看跌方向" class="headerlink" title="看涨看跌方向"></a>看涨看跌方向</h3><p>和权证类似，牛证对应看涨，熊证则对应看跌方向。</p><h3 id="到期日"><a href="#到期日" class="headerlink" title="到期日"></a>到期日</h3><p>对于牛熊证来说，到期日是其最后结算的日期，最终会根据当时的标的物价值和以及牛熊证的行使价以现金结算。</p><h3 id="交割方式"><a href="#交割方式" class="headerlink" title="交割方式"></a>交割方式</h3><p>交割方式为现金交割，指投资者在行使权利时，由发行人向投资者支付市价高于执行价的差额。</p><h3 id="行权价"><a href="#行权价" class="headerlink" title="行权价"></a>行权价</h3><p>认股价是发行人在发行权证时所订下的价格，到期发行商将根据这个价格来支付当时价格与其的差额</p><h3 id="回收价"><a href="#回收价" class="headerlink" title="回收价"></a>回收价</h3><p>与权证不同的是，牛熊证的标的资产价格一旦触及回收价，牛熊证既被回收，这个行为又被戏称为 “打靶” 或者 “爆仓”，牛熊证一旦被回收，投资者当即便会损失绝大多数甚至全部的资金（R 类牛熊证会根据观察期内标的的价格来确定牛熊证的剩余价值）。</p><h3 id="权证价格"><a href="#权证价格" class="headerlink" title="权证价格"></a>权证价格</h3><p>牛熊证的时间递耗可以忽略不计，其价格可以直接看作其内在价值。对于牛证而言，当正股股价（指标的证券市场价格）高于行使价时，内在价值为两者之差；而当正股股价触及回收价时，牛证虽然还有内在价值，但是也已经处于被收回无法交易的阶段，如果是 R 型牛证，还会根据观察期内正股的价格来确定其价格从而确定剩余价值。</p><h3 id="换股比率-认购比率"><a href="#换股比率-认购比率" class="headerlink" title="换股比率/认购比率"></a>换股比率/认购比率</h3><p>可以和权证的换股比率等同，指的是是认购或者认沽 1 股标的资产需要的认股证数量，如换股比率为 100，就表示每 100 张权证可认购或者认沽 1 股标的资产。认购、认沽比率表示的是每张权证可以认购的标的资产数量，所以 认购、认沽比率 = 1 / 换股比率。</p><h3 id="杠杆比率（Leverage-ratio）"><a href="#杠杆比率（Leverage-ratio）" class="headerlink" title="杠杆比率（Leverage ratio）"></a>杠杆比率（Leverage ratio）</h3><p>杠杆比率是正股市价与购入一股正股所需权证的市价之比，即：杠杆比率＝正股股价 /（权证价格÷认购比率）。杠杆比率可用来衡量“以小博大”的放大倍数，杠杆比率越高，投资者盈利率也越高，当然，其可能承担的亏损风险也越大。</p><h2 id="与权证的异同"><a href="#与权证的异同" class="headerlink" title="与权证的异同"></a>与权证的异同</h2><p>可以看到牛熊证在很多特性上与权证类似，简单来讲可以看做是可以被回收的且没有时间价值损耗的认股权证。关于这些异同点，我们对比着来看一下这两种衍生工具。</p><ol><li><p>相同/相似点</p><table><thead><tr><th align="left"></th><th align="left">权证/牛熊证</th></tr></thead><tbody><tr><td align="left">方向</td><td align="left">可多可空（牛/购，熊/沽）</td></tr><tr><td align="left">到期</td><td align="left">到期行权或结算</td></tr><tr><td align="left">杠杆</td><td align="left">有</td></tr></tbody></table></li><li><p>不同点</p><table><thead><tr><th align="left"></th><th align="left">权证</th><th align="left">牛熊证</th></tr></thead><tbody><tr><td align="left">时间损耗</td><td align="left">有</td><td align="left">没有</td></tr><tr><td align="left">到价是否会被回收</td><td align="left">不会</td><td align="left">会</td></tr><tr><td align="left">发行人</td><td align="left">上市主体或者其他第三方机构</td><td align="left">上市主体自己不能发行，第三方机构发行</td></tr><tr><td align="left">价内价外</td><td align="left">存在</td><td align="left">不存在</td></tr><tr><td align="left">杠杆</td><td align="left">名义杠杆≠实际杠杆</td><td align="left">名义杠杆=实际杠杆</td></tr><tr><td align="left">引伸波幅</td><td align="left">有</td><td align="left">无</td></tr></tbody></table></li></ol><h2 id="牛熊证的类型"><a href="#牛熊证的类型" class="headerlink" title="牛熊证的类型"></a>牛熊证的类型</h2><h3 id="N-类牛熊证"><a href="#N-类牛熊证" class="headerlink" title="N 类牛熊证"></a>N 类牛熊证</h3><p>N = (N)o residual value 意即没有剩余价值，N 类牛熊证的回收价和行使价相同，标的资产价格触及回收价就会被收回，与此同时牛熊证也就失去了一切的价值。所以 N 类牛熊证被回收之后，投资者将立即损失全部本金。</p><h3 id="R-类牛熊证"><a href="#R-类牛熊证" class="headerlink" title="R 类牛熊证"></a>R 类牛熊证</h3><p>R = With (r)esidual value 意即有剩余价值的牛熊证，R 类牛熊证的回收价会高于行使价，资产价格达到回收价格当即被強制收回停止交易，然后进入观察期，在观察期期间会按照牛熊证的发行章程来决定牛熊证的剩余价值，一般来讲只要在观察期内，标的资产价格没有触及行使价，一般还会有少许剩余价值留下，但也是微乎其微。</p><h4 id="观察期"><a href="#观察期" class="headerlink" title="观察期"></a>观察期</h4><p>牛熊证被强制收回后，至下一个交易时段结束(上午、下午分别为各一个交易时段) 为观察期。</p><center>![观察期](https://ws3.sinaimg.cn/large/006tNbRwgy1fopk8ljb52g30ci08cwec.gif)<p>观察期</p></center>如图所示，上午被收回的牛熊证观察期持续到下午收市为止，下午被收回的牛熊证观察期持续到第二日中午收市为止。<h4 id="结算价"><a href="#结算价" class="headerlink" title="结算价"></a>结算价</h4><p>说道剩余价值，这里还要阐述一个结算价的概念，这里以牛证为例</p><center>![结算价](https://ws4.sinaimg.cn/large/006tNbRwgy1fopk1wulnsg30ci08cdfq.gif)<p>恒指牛证结算</p></center><p>从图中我们可以看到，当回收事件发生之后（图中即恒指点位跌到 20000 点时）牛证进入了观察期，观察期内恒指没有跌到行使价 19500 点，这时牛熊证还有剩余价值可以兑现。牛证的结算价就是整个观察期内价格的最低位，而熊证相反，则是观察期内价格的最高位，也就是说取观察期内最少的价值作为牛熊证的剩余价值。</p><h4 id="剩余价值的计算"><a href="#剩余价值的计算" class="headerlink" title="剩余价值的计算"></a>剩余价值的计算</h4><p>现实在香港联交所上市交易的牛熊证皆属于 R 类牛熊证，以上图中所示的香港上市的恒指牛证为例，剩余价值的计算方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">牛证剩余价值 &#x3D; (牛证结算价 -行使价) &#x2F; 兑换比率</span><br><span class="line">熊证剩余价值 &#x3D; (行使价 - 熊证结算价) &#x2F; 兑换比率</span><br></pre></td></tr></table></figure><p>例如上面图中的牛证，假设换股比例为 10000，结算价格为 19900 则剩余价值为 （19900 - 19500） / 10000 = 0.04 港元</p><h2 id="如何看一只牛熊证"><a href="#如何看一只牛熊证" class="headerlink" title="如何看一只牛熊证"></a>如何看一只牛熊证</h2><center>![63943](https://ws3.sinaimg.cn/bmiddle/006tNc79ly1fmnmkd14omj30ja0sktel.jpg)<p>舜光海通八三牛B.C</p></center><p>下面我们来看一只港交所挂牌的牛证，结合以上讲到的内容来分析一下从这个权证的信息中我们可以知道什么：</p><p>以这个认购证为例，我们从它的名称中可以得到一些信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">舜光             海通                 八三牛             B.                       C</span><br><span class="line">^^               ^^                  ^^                ^                        ^</span><br><span class="line">正股是舜宇光学科技  发行人是海通国际证券   到期日是2018年3月   海通国际行的第2只八三牛     牛证(看多 call）</span><br></pre></td></tr></table></figure><ul><li><p>溢价：表示当前这个牛证的名义价格高于牛证的实际价格 0.40%</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">牛证溢价率&#x3D;（行权价+牛证价格 x 换股比率-正股价）&#x2F;正股价 x 100% </span><br><span class="line">熊证溢价率&#x3D;（正股价+熊证价格 x 换股比率-行使价）&#x2F;正股价 x 100% </span><br></pre></td></tr></table></figure><p>eg. ((88.800 + 0.124 x 100 - 100.800)  / 100.800) x 100% = 0.40%</p></li><li><p>杠杆比率：由于牛熊证的<strong>对冲值都是1</strong>（对冲值对实际的影响<a href="http://skyfly.xyz/2017/11/26/InvestmentLife/intro-to-derivative-part1/">参见</a>），这里的杠杆比率就是牛熊证的实际杠杆。表示的是相关资产价格高于牛证价格（权利金）的倍数。计算方式为： <code>杠杆比率=正股股价/权证价格  x 换股比率</code>。</p></li><li><p>换股比率：既每 100 张牛证可以换取到期购买 1 股舜宇光学科技股票的权利（实际上只会使用现金结算）</p></li><li><p>行权价：表示权证到期时持有人将可以用 100 张该权证以 88.800 港元的价格购买 1 股舜宇光学科技的股票。</p></li><li><p>街货占比：假如该投行发行了1亿张该牛证，街货占比 31.80% 表示当前已经有占总发行量 31.80% 的权证也就是 3180 万张牛证在当日收盘后留在了投资者的手中。街货占比小的权证做市商对价格的控制能力就越强，街货占比大的权证价格容易被市场供需，做市商操守和投资者情绪所影响导致 “不跟价” 的情况出现。</p></li><li><p>打和点：因为该权证行使认购股票的权力（其实只有现金结算）时需要支付 <code>0.124 x 100 = 12.4</code> 港元的牛证的权利费用。所以只有股价达到 <code>88.800（行使价）+ 12.40（权利费）= 101.20</code> 港元时，这个牛证才能真正获利。打和点表示的就是行权时盈亏的平衡点。</p></li><li><p>换股价：<code>0.124（牛证价格）x 100（换股比率）= 12.40</code></p></li></ul><h2 id="牛熊证的风险"><a href="#牛熊证的风险" class="headerlink" title="牛熊证的风险"></a>牛熊证的风险</h2><p>牛熊证和认股证一样属于权证类型的结构化产品，这类产品的共同特点是损失有限（全部本金），收益无限。利用这个特性，他们都可以作为对冲风险的有力工具。作为投机手段来讲，相较于权证（认股证），牛熊证没有时间递耗和引伸波幅这两个恼人的属性，价格更加的透明，方便判断和操作，但是牛熊证由于其可被回收的特性，可能会让投资者一瞬间损失全部本金，对于风险承受能力有限的投资/投机者而言可能不是一个好的选择。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://warrants-hk.credit-suisse.com/home/html/tutorial/cbbc/cbbc_tutorial_6r_c.html">瑞信牛熊证教室</a></li><li><a href="https://en.wikipedia.org/wiki/Callable_bull/bear_contract">WikiPedia CBBCs</a></li><li><a href="https://www.hkex.com.hk/Products/Securities/Callable-Bull-Bear-Contracts?sc_lang=en">HKEX CBBCs</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;牛熊证（CBBCs）&quot;&gt;&lt;a href=&quot;#牛熊证（CBBCs）&quot; class=&quot;headerlink&quot; title=&quot;牛熊证（CBBCs）&quot;&gt;&lt;/a&gt;牛熊证（CBBCs）&lt;/h2&gt;&lt;p&gt;牛熊证（合约），全称为 &lt;strong&gt;可收回牛/熊证（合约）&lt;/strong&gt;（Callable Bull/Bear Contracts/Certificates）。牛熊证和窝轮很相似，是一种具有期权性质的金融衍生工具，属于结构化金融产品的一种，它的价格和标的资产的价格挂钩。&lt;/p&gt;
&lt;p&gt;牛熊证最早于 2001 年产生于欧洲和澳大利亚的金融市场，香港联交所于 2006 引入了这种新型的投资产品，之后牛熊证在香港证券市场的成交量迅速上升，形成了与窝轮分庭抗礼的局面。目前牛熊证在欧洲和香港的交易十分活跃，受到投资者的热烈追捧。&lt;/p&gt;
&lt;center&gt;
![63943](https://ws3.sinaimg.cn/bmiddle/006tNc79ly1fmnmkd14omj30ja0sktel.jpg)

&lt;p&gt;一只香港联交所上市的牛证&lt;/p&gt;
&lt;/center&gt;
    
    </summary>
    
      <category term="投资" scheme="https://ufolux.github.io/categories/%E6%8A%95%E8%B5%84/"/>
    
    
      <category term="衍生品学习" scheme="https://ufolux.github.io/tags/%E8%A1%8D%E7%94%9F%E5%93%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>使用 mocha 和 babel 来测试你的 es6 代码</title>
    <link href="https://ufolux.github.io/2017/11/29/Front_End/front-end-engineering/use-babel-and-mocha-for-testing/"/>
    <id>https://ufolux.github.io/2017/11/29/Front_End/front-end-engineering/use-babel-and-mocha-for-testing/</id>
    <published>2017-11-29T14:00:23.000Z</published>
    <updated>2021-03-11T07:20:00.095Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前段时间给一个项目提 PR，帮助该项目实现 es6 module 的支持，所以要想办法给 es6 代码写测试用例。顺便研究了一下这块东西，感觉还挺简单的，这里记录一下吧。</p><span id="more"></span><h2 id="原料"><a href="#原料" class="headerlink" title="原料"></a>原料</h2><ol><li>mocha</li><li>babel-register</li><li>babel-preset-es2015</li></ol><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="0x00-安装必要的依赖"><a href="#0x00-安装必要的依赖" class="headerlink" title="0x00 安装必要的依赖"></a>0x00 安装必要的依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add mocha -D</span><br><span class="line">$ yarn add babel-register -D</span><br><span class="line">$ yarn add babel-preset-es2015 -D</span><br></pre></td></tr></table></figure><h3 id="0x01-写配置文件"><a href="#0x01-写配置文件" class="headerlink" title="0x01 写配置文件"></a>0x01 写配置文件</h3><p>为 package.json 添加 script</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;mocha --compilers js:babel-register&quot;</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>创建 .babelrc 文件并写入以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;: [ &quot;es2015&quot; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x02-写测试用例"><a href="#0x02-写测试用例" class="headerlink" title="0x02 写测试用例"></a>0x02 写测试用例</h3><p>新建 test 目录，mocha 会默认执行 test 目录下的测试脚本，在 test 目录下新建 a.js 和 b.js 文件</p><p>a.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">constructor () &#123;</span><br><span class="line">console.log(&#39;import A succeed !&#39;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">export &#123;A&#125;</span><br></pre></td></tr></table></figure><p>b.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123;A&#125; from &#39;a.js&#39;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">constructor () &#123;</span><br><span class="line">let a &#x3D; new A()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x03-执行测试用例"><a href="#0x03-执行测试用例" class="headerlink" title="0x03 执行测试用例"></a>0x03 执行测试用例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm test</span><br></pre></td></tr></table></figure><p>完成</p><h2 id="参见"><a href="#参见" class="headerlink" title="参见"></a>参见</h2><p><a href="http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html">测试框架 Mocha 实例教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间给一个项目提 PR，帮助该项目实现 es6 module 的支持，所以要想办法给 es6 代码写测试用例。顺便研究了一下这块东西，感觉还挺简单的，这里记录一下吧。&lt;/p&gt;
    
    </summary>
    
      <category term="前端工程化" scheme="https://ufolux.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="单元测试" scheme="https://ufolux.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>金融衍生工具介绍（一） 权证</title>
    <link href="https://ufolux.github.io/2017/11/26/InvestmentLife/intro-to-derivative-part1/"/>
    <id>https://ufolux.github.io/2017/11/26/InvestmentLife/intro-to-derivative-part1/</id>
    <published>2017-11-26T14:31:12.000Z</published>
    <updated>2021-03-11T07:20:00.103Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>金融衍生工具（Derivative）是一种特殊类别买卖的金融工具统称。这种买卖的回报率是根据一些其他金融要素的表现情况衍生出来的。比如资产（商品，股票或债券），利率，汇率，或者各种指数（股票指数，消費者物價指數，以及天气指数）等。这些要素的表现将会决定一个衍生工具的回报率和回报时间。衍生工具的主要类型有期货，期权，权证，远期合约，掉期交易等，這些期货，期权合約都能在市場上買賣。</p><p>对此类金融工具进行买卖投资者需要十分谨慎，因为由其引起的损失有可能大于投资者最初投放于其中的资金。同时由于其本身并不代表任何资产，其买卖也不应该被视作投资。</p><span id="more"></span><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><h3 id="对冲（Hedge）"><a href="#对冲（Hedge）" class="headerlink" title="对冲（Hedge）"></a>对冲（Hedge）</h3><p>衍生金融工具其中一项用途，是用来转移风险：采取跟标的资产（underlying asset）相反的立场。例如，小麦农夫和磨坊主人订定期货合约，在未来以现金买小麦。双方因此都能减低风险：小麦农夫能确定价格，而磨坊主人则能确定小麦供应。</p><p>对冲在外汇市场中最为常见，着意避开单线买卖的风险。所谓单线买卖，就是看好某一种货币就做买空，看淡某一种货币，就做沽空。如果判断正确，所获利润自然多；但如果判断错误，损失亦会比没有进行“对冲”时来得大。</p><p>举个具体的例子：<br>1990年初，中东伊拉克战争完结，美国成为战胜国，美元价格亦稳步上升，走势强劲，兑所有外汇都上升，当时只有日元仍是强势货币。当时柏林墙倒下不久，德国刚统一，东德经济差令德国受拖累，经济有隐忧。苏联政局不稳，戈尔巴乔夫地位受到动摇。英国当时经济亦差，不断减息，而保守党又受到工党的挑战，所以英磅亦偏弱。瑞士法郎在战后作为战争避难所的吸引力大减，亦成为弱势货币。</p><p>假如在当时买外汇，长沽英磅、马克、瑞士法郎，同时买入日元，就会赚大钱。当美元升时，所有外币都跌，只有日元跌得最少，其他外币都大跌；当美元回软，其他外币升幅少，日元却会大升。无论如何，只要在当时的市场这样做对冲，都会获利。</p><h3 id="投机和套利"><a href="#投机和套利" class="headerlink" title="投机和套利"></a>投机和套利</h3><p>市场上的炒家除了和其他炒家交易之外，也会和对冲的人交易获取投机利润<br>因为不同衍生工具有相同或极为相似的指定证券，他们的价格可能在短时间内会出现与指定证券或资产的价格背离，所以衍生工具交易也能提供套利机会。<br>炒家除了会投机涨跌（正向反向产品），还会投机波幅，期权和认股证等用作炒波幅（杠杆产品）。</p><blockquote><p>由于金融衍生工具其本身并不代表任何资产，而且相当多的金融衍生工具是建立在对标的物的层层的杠杆化包装之上的，投机衍生品会带来很大的风险。<br>比如在1995年时，衍生金融工具投机得到臭名远播。巴林银行的一名交易员<a href="https://zh.wikipedia.org/wiki/%E5%B0%BC%E5%85%8B%C2%B7%E6%9D%8E%E6%A3%AE">尼克·李森</a>，造成14亿美元的损失，损失的金额几乎是巴林银行可交易资金的两倍，这令这家有数百年历史的金融机构瞬间破产。</p></blockquote><h2 id="衍生工具的种类"><a href="#衍生工具的种类" class="headerlink" title="衍生工具的种类"></a>衍生工具的种类</h2><p>按照交易发生的场所来区分，可以分为场外交易和交易所交易衍生工具</p><h3 id="场外交易衍生工具"><a href="#场外交易衍生工具" class="headerlink" title="场外交易衍生工具"></a>场外交易衍生工具</h3><p>场外交易衍生工具，是买卖双方之间（私下协商）直接交易的合约，无须通过交易场或其他中介机构。产品如掉期交易（swap）、远期利率协议以及奇异期权（exotic options）几乎都是用场外交易这种交易方式。</p><h3 id="交易所买卖之衍生工具（ETD）"><a href="#交易所买卖之衍生工具（ETD）" class="headerlink" title="交易所买卖之衍生工具（ETD）"></a>交易所买卖之衍生工具（ETD）</h3><p>交易所买卖之衍生工具（ETD），顾名思义，是通过期货交易所或其他交易所买卖的衍生工具。衍生品交易所是一个中介机构，向交易双方收取孖展（margin 保证金）作为担保。</p><p>这里简单列举一些衍生品的名称：</p><ol><li>权证（Warrant）</li><li>牛熊证/合约（CBBC）</li><li>期权（Option）</li><li>期货（Futures）</li><li>掉期（Swap，也称为互换）如信用违约掉期（CDS）</li><li>资产支撑证券（ABS）以及在证券化资产上的进一步证券化包装</li><li>可转债</li><li>凭证（Obligation）如担保债务凭证（CDO）</li><li>票据<br>等等</li></ol><h2 id="一些衍生工具的简介"><a href="#一些衍生工具的简介" class="headerlink" title="一些衍生工具的简介"></a>一些衍生工具的简介</h2><h3 id="权证（Warrant）"><a href="#权证（Warrant）" class="headerlink" title="权证（Warrant）"></a>权证（Warrant）</h3><center>![权证](https://ws2.sinaimg.cn/large/006tNc79gy1flvm69h4yij309i0dxt95.jpg)</center><p>权证，又称“认股证”或“认股权证”，在香港俗称为“窝轮”。权证是一种金融衍生产品（工具），是依附于标的证券的有价证券，是持有者一种权利（但没有义务）的证明。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>权证（share warrant），是指基础证券发行人或其以外的第三人发行的，约定持有人在规定期间内或特定到期日，有权按约定价格向发行人购买或出售标的证券，或以现金结算方式收取结算差价的有价证券。</p><p>权证实质反映的是发行人与持有人之间的一种契约关系，持有人向权证发行人支付一定数量的价金之后，就从发行人那获取了一个权利。这种权利使得持有人可以在未来某一特定日期或特定期间内，以约定的价格向权证发行人购买/出售一定数量的资产。购买股票的权证称为认购权证，出售股票的权证叫作认售权证（或认沽权证）。</p><p>需要注意的是持有人获取的是一个权利而不是责任，其有权决定是否履行契约，而发行者仅有被执行的义务，因此为获得这项权利，投资者需付出一定的代价(权利金既权证价格)。权证(实际上所有期权)与远期或期货的区别在于前者持有人所获得的不是一种责任，而是一种权利，后者持有人需有责任执行双方签订的买卖合约，即必须以一个指定的价格，在指定的未来时间，交易指定的相关资产，如不愿发生资产的交割，则合约双方需要在期货合约到期前冲销相关的交易。</p><h4 id="权证的分类"><a href="#权证的分类" class="headerlink" title="权证的分类"></a>权证的分类</h4><h5 id="按照行权期限分类"><a href="#按照行权期限分类" class="headerlink" title="按照行权期限分类"></a>按照行权期限分类</h5><p>权证按照行权期限的设置分为 <strong>欧式权证</strong>、<strong>美式权证</strong> 和 <strong>百慕大式权证</strong>。欧式权证是只有到了到期日才能行权的权；美式权证则是一种在到期日之前随时都可以行权的权证；所谓百慕大式权证规定了持有人可在特定的几个日子或约定的到期日有权买卖标的证券。</p><blockquote><p>目前在香港市场上交易的权证都是欧式权证</p></blockquote><h5 id="按照买卖的方向分类"><a href="#按照买卖的方向分类" class="headerlink" title="按照买卖的方向分类"></a>按照买卖的方向分类</h5><p>权证按照买卖方向可以分为 <strong>认购权证</strong> 和 <strong>认沽权证</strong> 认购权证持有人有权按约定价格在特定期限内或到期日向发行人买入标的证券，认沽权证持有人则有权按约定价格卖出标的证券。</p><h5 id="按照发行人分类"><a href="#按照发行人分类" class="headerlink" title="按照发行人分类"></a>按照发行人分类</h5><p>按照发行人不同可以分为 <strong>股本权证</strong> 和 <strong>备兑权证</strong>，股本权证由标的证券对应的上市公司主体发行。而备兑权证一本都是由券商，投行等声誉较佳的金融机构（称为做市商 market maker）发行的。做市商有责任为其发行的权证提供流动性，也就是提供买盘和卖盘的报价和挂单。</p><p>香港市场上交易的权证都属于备兑权证，而备兑权证在香港又称为衍生权证（Derivative Warrant），这一类型的权证不仅发行人都是股本证券上市主体之外的第三方，也就是券商投行这些金融机构，而且这类权证的标的物也并非一定是股本证券，也可以是指数、ETF、外汇汇率，期货等产品。</p><p>备兑的含义指其发行人将权证的指定证券或资产存放在独立的受托人、托管人或存管处，作为其履行责任的抵押，而受托人、托管人或存管处则代表权证持有人的利益。备兑权证的发行人依靠持有或者沽出标的资产仓位来对冲认股证的损益，而不是像股本权证那样靠增发股份来兑付行权的结果。这和中央银行持有储备资产并发行信用货币的行为有些类似。</p><center>![南方东英 A50 ETF 认购证](https://ws2.sinaimg.cn/large/006tNc79gy1flvngpu5khj309n0ds0t6.jpg)<p>南方东英 A50 ETF 认购证</p></center><center>![期货原油认沽证](https://ws3.sinaimg.cn/large/006tNc79gy1flvnjk0ku9j309n0dxt92.jpg)<p>期货原油认沽证</p></center><center>![恒指认购证](https://ws4.sinaimg.cn/large/006tNc79gy1flvnl6qctjj309v0eo0t7.jpg)<p>恒生指数认购证</p></center><table><thead><tr><th align="left">区分点</th><th align="left">股本权证</th><th align="left">备兑权证</th></tr></thead><tbody><tr><td align="left">发行人</td><td align="left">标的证券发行人</td><td align="left">标的证券发行人以外的第三方</td></tr><tr><td align="left">标的证券</td><td align="left">需要发行新股</td><td align="left">已在交易所挂牌交易的证券、ETF、指数<br>或者其他可交易的产品</td></tr><tr><td align="left">发行目的</td><td align="left">为筹资或高管人员激励用</td><td align="left">为投资者提供避险、套利工具</td></tr><tr><td align="left">行权结果</td><td align="left">公司股份增加、每股净值稀释</td><td align="left">不造成股本增加或权益稀释</td></tr></tbody></table><center>股本权证和备兑权证的区别</center><h5 id="按照权证行使价分类"><a href="#按照权证行使价分类" class="headerlink" title="按照权证行使价分类"></a>按照权证行使价分类</h5><p>按照行使价分类可以将权证分为价内，价平，价外三类，见下表：</p><table><thead><tr><th align="left">价格关系</th><th align="left">认购权证</th><th align="left">认沽权证</th></tr></thead><tbody><tr><td align="left">行使价格＞标的资产收盘价格</td><td align="left">价外</td><td align="left">价内</td></tr><tr><td align="left">行使价格＝标的证券收盘价格</td><td align="left">价平</td><td align="left">价平</td></tr><tr><td align="left">行使价格＜标的证券收盘价格</td><td align="left">价内</td><td align="left">价外</td></tr></tbody></table><h4 id="权证的发展过程"><a href="#权证的发展过程" class="headerlink" title="权证的发展过程"></a>权证的发展过程</h4><h4 id="权证的基本要素"><a href="#权证的基本要素" class="headerlink" title="权证的基本要素"></a>权证的基本要素</h4><p>从权证的设计和运作来看，包括以下几个要素：</p><h5 id="发行人"><a href="#发行人" class="headerlink" title="发行人"></a>发行人</h5><p>股本权证的发行人为标的上市公司，而衍生权证的发行人为标的公司以外的第三方，一般为大股东或券商。在后一种情况下，发行人往往需要将标的证券存放于独立保管人处，作为其履行责任的担保。</p><h5 id="看涨和看跌方向"><a href="#看涨和看跌方向" class="headerlink" title="看涨和看跌方向"></a>看涨和看跌方向</h5><p>当权证持有人拥有从发行人处购买标的证券的权利时，该权证为看涨权证。反之，当权证持有人拥有向发行人出售标的证券的权利时，该权证为看跌权证。认股权证一般指看涨权证。</p><h5 id="到期日"><a href="#到期日" class="headerlink" title="到期日"></a>到期日</h5><p>到期日是权证持有人可行使认购（或出售）权利的最后日期。该期限过后，权证持有人便不能行使相关权利，权证的价值也变为零。</p><h5 id="执行方式"><a href="#执行方式" class="headerlink" title="执行方式"></a>执行方式</h5><p>在美式执行方式下，持有人在到期日以前的任何时间内均可行使认购权；而在欧式执行方式下，持有人只有在到期日当天才可行使认购</p><h5 id="交割方式"><a href="#交割方式" class="headerlink" title="交割方式"></a>交割方式</h5><p>交割方式包括实物交割和现金交割两种形式，其中，实物交割指投资者行使认股权利时从发行人处购入标的证券，而现金交割指投资者在行使权利时，由发行人向投资者支付市价高于执行价的差额。　　</p><h5 id="行权价"><a href="#行权价" class="headerlink" title="行权价"></a>行权价</h5><p>认股价是发行人在发行权证时所订下的价格，持证人在行使权利时以此价格向发行人认购标的股票。</p><h5 id="权证价格"><a href="#权证价格" class="headerlink" title="权证价格"></a>权证价格</h5><p>权证价格由内在价值和时间价值两部分组成。当正股股价（指标的证券市场价格）高于认股价时，内在价值为两者之差；而当正股股价低于认股价时，内在价值为零。但如果权证尚没有到期，正股股价还有机会高于认股价，因此权证仍具有市场价值，这种价值就是时间价值。</p><h5 id="换股比率-认购比率"><a href="#换股比率-认购比率" class="headerlink" title="换股比率/认购比率"></a>换股比率/认购比率</h5><p>换股比率是认购 1 股标的资产需要的认股证数量，如换股比率为 100，就表示每 100 张权证可认购 1 股标的资产。认购比率表示的是每张权证可以认购的标的资产数量，所以 <strong><code>认购比率 = 1 / 换股比率</code></strong>。</p><h5 id="杠杆比率（Leverage-ratio）"><a href="#杠杆比率（Leverage-ratio）" class="headerlink" title="杠杆比率（Leverage ratio）"></a>杠杆比率（Leverage ratio）</h5><p>杠杆比率是正股市价与购入一股正股所需权证的市价之比，即：<strong><code>杠杆比率＝正股股价/（权证价格÷认购比率）</code></strong>。杠杆比率可用来衡量“以小博大”的放大倍数，杠杆比率越高，投资者盈利率也越高，当然，其可能承担的亏损风险也越大。</p><h5 id="对冲值（Delta）"><a href="#对冲值（Delta）" class="headerlink" title="对冲值（Delta）"></a>对冲值（Delta）</h5><p>对冲值，用以量度认股权证理论价格对相关资产价格变动的敏感度。另外，对冲值亦是根据期权理论价格模式，计算投资者在到期日时，行使该认股证的机会率，故其数值只会在0至1之间。而认沽证的对冲值就会在0至-1之间。Delta也显示发行人要对冲一份认股证时，需要买入或沽出的股份数目。举例说：某公司甲认购证的对冲值为 0.45、换股比率为1兑1，意指每当公司甲股票价格变动1.00元时，该认购证的理论价格便变动0.45元。同时，这也表示为了对冲每1000万份已售出的认购证，发行人需要购入450万股公司甲的股份。</p><p>对冲值反映窝轮在到期时成为价内的机会，深入价外窝轮的对冲值接近0，表示窝轮只有接近0的机会于到期时成为价内；贴价窝轮的对冲值接近50％，表示窝轮于到期时成为价内的机会接近50％；深入价内窝轮的对冲值的绝对值接近100％，表示窝轮到期成为价内的机会接近100％。</p><h5 id="时间递耗值-Theta"><a href="#时间递耗值-Theta" class="headerlink" title="时间递耗值(Theta)"></a>时间递耗值(Theta)</h5><p>时间递耗值也就是权证的价值磨损显示衍生权证剩余时间的变动引致衍生权证价格的变动。由于时间递耗值量度时间递耗对衍生权证的影响，其数值必属负数。举例来说，如每日时间递耗值为 -0.0015，即假设其他因素维持不变，权证的价值每日会跌0.0015元。</p><h5 id="引伸波幅（Implied-volatility）"><a href="#引伸波幅（Implied-volatility）" class="headerlink" title="引伸波幅（Implied volatility）"></a>引伸波幅（Implied volatility）</h5><p>引伸波幅是将市场上的权证交易价格代入权证理论价格模型，反推出来的波动率数值，也称为隐含波动率。权证的理论价格采用 <a href="http://wiki.mbalib.com/wiki/Black%E2%80%94Scholes%E5%85%AC%E5%BC%8F">Black—Scholes 期权定价模型</a> 来计算。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1flvtb8j360j30s00eqaao.jpg" alt="B-S 期权定价模型"></p><p>只要将权证当前的价格带入 C 中，L，S，T，r 均为已知量，这样就可以解出唯一的未知数 σ2，这就是所谓的引伸波幅。</p><p>可以看到所谓的引伸波幅实际上是描述了一个权证对应的标的资产价格的波动率，　一般来说，认股权证正股的隐含波动率普遍比历史波动率要高，两者具有正相关关系。若正股历史波动率高，相关权证的隐含波动率也较高；若正股历史波动率低，相关的权证隐含波动率也相对较低。特别是在发行权证时，发行人会把正股的历史波动率作为依据之一来确定权证的隐含波动率，从而确定权证价格。此外，供求关系也会影响隐含波动率，隐含波动率在某种程度上是权证供求关系的一个反映。当投资者对某只权证需求旺盛，使得权证价格虚高，引申波幅达到了较高的水平，甚至远高于正股的实际波幅。</p><p><strong>以上参数中最重要的是权证当前的价格，换股比率，到期日和行使价，这几个参数构成了一个权证的基本属性。</strong></p><blockquote><p>注意，以上提及的技术性参数不是固定值，它们会根据市场的行情不时改变。</p></blockquote><h4 id="权证的价值"><a href="#权证的价值" class="headerlink" title="权证的价值"></a>权证的价值</h4><p>　　权证价值由两部分组成，一是内在价值，即标的股票与行权价格的差价；二是时间价值，代表持有者对未来股价波动带来的期望与机会。在其他条件相同的情况下，权证的存续期越长，权证的价格越高。　　　　</p><h4 id="如何看一只权证"><a href="#如何看一只权证" class="headerlink" title="如何看一只权证"></a>如何看一只权证</h4><p>下面我们来看一只港交所挂牌的权证，结合以上讲到的内容来分析一下从这个权证的信息中我们可以知道什么：</p><center>![](https://ws1.sinaimg.cn/large/006tNc79gy1flvr7cif0pj309s0ecaap.jpg)<p>权证示例</p></center><p>以11090这个认购证为例，我们从它的名称中可以得到一些信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">腾讯         瑞信               七乙购                I.                       C</span><br><span class="line">^^           ^^                ^^                   ^                        ^</span><br><span class="line">正股是腾讯控股 发行人是瑞士信贷公司 到期日是2017年12月（乙）瑞信发行的第9只七乙购   认购权证（call）</span><br></pre></td></tr></table></figure><ul><li><p>价内价外：可以看到这个认购证的行使价高于当前正股的价格，所以这是一个价外的权证。</p></li><li><p>溢价：表示当前这个权证的名义价格高于权证的实际价格 4.9%</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">认购权证溢价率&#x3D;（行权价+认购权证价格 x 换股比率-正股价）&#x2F;正股价 x 100% </span><br><span class="line">认沽权证溢价率&#x3D;（正股价+认沽权证价格 x 换股比率-行权价）&#x2F;正股价 x 100% </span><br></pre></td></tr></table></figure><p>eg. ((421.08 + 1.51 x 10 - 415.8)  / 415.8) x 100% = 4.90%</p></li><li><p>杠杆比率：这里的杠杆比率描述的是这个权证的名义杠杆。表示的是相关资产价格高于权证价格的倍数。计算方式为： <code>名义杠杆=正股股价/权证价格  x 换股比率</code>。</p></li><li><p>有效杠杆：指的是这个权证的实际杠杆，实际杠杆会将对冲值考虑在内。计算方式为：<code>实际杠杆=名义杠杆 x 对冲值</code>。这个数据表示了这个权证价格随正股的实际波动情况，比如腾讯控股上涨 1%，那么这个权证理论上将会上涨 13.02%。</p></li><li><p>换股比率：既每 10 张认购证可以换取 1 股腾讯控股的股票</p></li><li><p>行权价：表示权证到期时持有人将可以用 10 张该权证以 421.080 港元的价格购买1 股腾讯控股的股票。</p></li><li><p>引伸波幅：这个权证的隐含波动率为 35.108%</p></li><li><p>街货占比：假如该投行发行了1亿张该认股权证，街货占比 41.40% 表示当前已经有占总发行量 41.40% 的权证也就是 4140万张权证在当日收盘后留在了投资者的手中。街货占比小的权证做市商对价格的控制能力就越强，街货占比大的权证价格容易被市场情绪所影响导致“不跟价”的情况出现。</p></li><li><p>打和点：因为该权证行使认购股票的权力时需要支付 <code>1.51 x 10 = 15.10</code> 港元的认购证的权利费用。所以只有股价达到 <code>421.080（行使价）+ 15.10（权利费）= 431.18</code> 港元时，这个认购权证才能真正获利。打和点表示的就是行权时盈亏的界限。</p></li><li><p>换股价：<code>1.51（权证价格）x 10（换股比率）= 15.10</code></p></li><li><p>对冲值：表示了当正股上涨 1 港元时权证价格会上涨 0.473 港元亦表示当投资者购每购买 1 港元该认购证时做市商需要购买 0.473 港元的腾讯控股来做对冲</p></li></ul><p>这样我们就看懂了一个港交所挂牌的权证。</p><h4 id="权证的风险"><a href="#权证的风险" class="headerlink" title="权证的风险"></a>权证的风险</h4><p>权证在用于投机时提升风险，加杠杆使收益的方差扩大；在用于套期保值时，降低风险，使收益的方差降低。</p><blockquote><p>例如<br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1flvurkmajrj30li0eh0tt.jpg" alt="暴涨"></p></blockquote><p>半日之内 17474 权证暴涨 344.44% 后续收盘又回落 30% 收于 240.74% 权证持有者的资产半日内即可翻 3 倍，但是于半日内又可下跌 30%，振幅很大。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1flvusurhrgj30li0e2dgr.jpg" alt="暴跌"></p><p>权证 16122 开盘不久即遭重挫，下跌超过 80%，如果大量仓位持有该权证很可能导致投资者血本无归。</p><p>所以，权证投资有风险，入市交易需谨慎。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://zh.wikipedia.org/wiki/%E5%B0%BC%E5%85%8B%C2%B7%E6%9D%8E%E6%A3%AE">尼克.李森</a></li><li><a href="http://wiki.mbalib.com/wiki/%E6%9D%83%E8%AF%81">权证</a></li><li><a href="http://wiki.mbalib.com/wiki/%E8%9D%B6%E5%BC%8F%E6%9D%83%E8%AF%81">蝶式权证</a></li><li><a href="http://wiki.mbalib.com/wiki/%E9%A9%AC%E9%9E%8D%E5%BC%8F%E7%AD%96%E7%95%A5">鞍式权证</a></li><li><a href="http://wiki.mbalib.com/wiki/Black-Scholes%E6%9C%9F%E6%9D%83%E5%AE%9A%E4%BB%B7%E6%A8%A1%E5%9E%8B">B-S 定价模型</a></li><li><a href="http://wiki.mbalib.com/wiki/%E5%BC%95%E4%BC%B8%E6%B3%A2%E5%B9%85">引伸波幅</a></li><li><a href="http://finance.sina.com.cn/stock/hkstock/warrants/20110917/145910497249.shtml">如何用权证对冲风险及实战操作技巧</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;金融衍生工具（Derivative）是一种特殊类别买卖的金融工具统称。这种买卖的回报率是根据一些其他金融要素的表现情况衍生出来的。比如资产（商品，股票或债券），利率，汇率，或者各种指数（股票指数，消費者物價指數，以及天气指数）等。这些要素的表现将会决定一个衍生工具的回报率和回报时间。衍生工具的主要类型有期货，期权，权证，远期合约，掉期交易等，這些期货，期权合約都能在市場上買賣。&lt;/p&gt;
&lt;p&gt;对此类金融工具进行买卖投资者需要十分谨慎，因为由其引起的损失有可能大于投资者最初投放于其中的资金。同时由于其本身并不代表任何资产，其买卖也不应该被视作投资。&lt;/p&gt;
    
    </summary>
    
      <category term="投资" scheme="https://ufolux.github.io/categories/%E6%8A%95%E8%B5%84/"/>
    
    
      <category term="衍生品学习" scheme="https://ufolux.github.io/tags/%E8%A1%8D%E7%94%9F%E5%93%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>High Sierra (macOS10.13) 下 CocoaPods 报错的处理方法</title>
    <link href="https://ufolux.github.io/2017/11/03/iOS/cocoapods-down-highsierra/"/>
    <id>https://ufolux.github.io/2017/11/03/iOS/cocoapods-down-highsierra/</id>
    <published>2017-11-03T02:52:50.000Z</published>
    <updated>2021-03-11T07:20:00.112Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近升级到 macOS 10.13 之后，执行 pod 命令报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;pod: &#x2F;System&#x2F;Library&#x2F;Frameworks&#x2F;Ruby.framework&#x2F;Versions&#x2F;2.0&#x2F;usr&#x2F;bin&#x2F;ruby: bad interpreter: No such file or directory  </span><br></pre></td></tr></table></figure><p>发现是 10.13 里面系统预装的 ruby 版本变成了 2.3，于是之前安装的 cocoapods 就找不到之前的 2.0 版本了，重装一下即可解决。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install -n &#x2F;usr&#x2F;local&#x2F;bin cocoapods</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="iOS" scheme="https://ufolux.github.io/categories/iOS/"/>
    
    
      <category term="cocoapods" scheme="https://ufolux.github.io/tags/cocoapods/"/>
    
      <category term="环境问题" scheme="https://ufolux.github.io/tags/%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>iOS 网络异常情况提示的处理方式</title>
    <link href="https://ufolux.github.io/2017/10/29/iOS/ios-network-exception/"/>
    <id>https://ufolux.github.io/2017/10/29/iOS/ios-network-exception/</id>
    <published>2017-10-29T14:11:28.000Z</published>
    <updated>2021-03-11T07:20:00.115Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近做了一个在 iOS 平台下提示用户网络异常的功能，许久没有做 iOS 原生需求了，接手这个需求后感觉 iOS 的坑也越来越多了。</p><p>这种需求很常见，首先分析一下这里指的网络异常包括，飞行模式、Wi-Fi 和蜂窝网络都被关闭、Wi-Fi 连接状态下应用的 Wi-Fi 权限被关闭，只有蜂窝连接的情况下应用蜂窝权限被关闭。</p><p>对这些情况的处理里程图如下：</p><p><img src="/2017/10/29/iOS/ios-network-exception/ios-network-exception.png" alt></p><p>下面把整个流程中的实现方法和需要注意的坑讲一下。</p><span id="more"></span><h2 id="判断是否飞行模式"><a href="#判断是否飞行模式" class="headerlink" title="判断是否飞行模式"></a>判断是否飞行模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;CoreTelephony&#x2F;CTTelephonyNetworkInfo.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> 判断是否飞行模式</span><br><span class="line"> *&#x2F;</span><br><span class="line">+ (BOOL)isAirPlaneMode</span><br><span class="line">&#123;</span><br><span class="line">    CTTelephonyNetworkInfo *networkInfo &#x3D; [[CTTelephonyNetworkInfo alloc] init];</span><br><span class="line">    return (BOOL)!networkInfo.currentRadioAccessTechnology;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>networkInfo.currentRadioAccessTechnology</code> 返回 <code>nil</code> 则可以判断处于飞行模式。</p><h2 id="判断-Wi-Fi-是否打开"><a href="#判断-Wi-Fi-是否打开" class="headerlink" title="判断 Wi-Fi 是否打开"></a>判断 Wi-Fi 是否打开</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;ifaddrs.h&gt;</span><br><span class="line">#import &lt;net&#x2F;if.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> Wifi开关是否打开</span><br><span class="line"> *&#x2F;</span><br><span class="line">+ (BOOL) isWiFiEnabled &#123;</span><br><span class="line">NSString *const WIFI_INTERFACE_NAME &#x3D; @&quot;awdl0&quot;;</span><br><span class="line">NSCountedSet * cset &#x3D; [NSCountedSet new];</span><br><span class="line">    struct ifaddrs *interfaces;</span><br><span class="line">    if(!getifaddrs(&amp;interfaces)) &#123;</span><br><span class="line">        for( struct ifaddrs *interface &#x3D; interfaces; interface; interface &#x3D; interface-&gt;ifa_next) &#123;</span><br><span class="line">            if ( (interface-&gt;ifa_flags &amp; IFF_UP) &#x3D;&#x3D; IFF_UP ) &#123;</span><br><span class="line">                [cset addObject:[NSString stringWithUTF8String:interface-&gt;ifa_name]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return [cset countForObject:WIFI_INTERFACE_NAME] &gt; 1 ? YES : NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>awdl0</code> 是 wifi interface 的名称，判断是否有这个名称的 <code>interface</code> 就知道是否有打开 wifi 开关。</p><h2 id="判断是否有-Wi-Fi-权限"><a href="#判断是否有-Wi-Fi-权限" class="headerlink" title="判断是否有 Wi-Fi 权限"></a>判断是否有 Wi-Fi 权限</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;SystemConfiguration&#x2F;CaptiveNetwork.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> 判断是否禁用了 Wi-Fi 权限</span><br><span class="line"> *&#x2F;</span><br><span class="line">+ (BOOL) isWifiNetWorkRestricted</span><br><span class="line">&#123;</span><br><span class="line">    NSArray *ifs &#x3D; (__bridge_transfer NSArray *)CNCopySupportedInterfaces();</span><br><span class="line">    if (!ifs) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSDictionary *info &#x3D; nil;</span><br><span class="line">    for (NSString *ifnam in ifs) &#123;</span><br><span class="line">        info &#x3D; (__bridge_transfer NSDictionary *)CNCopyCurrentNetworkInfo((__bridge CFStringRef)ifnam);</span><br><span class="line">        if (info &amp;&amp; [info count]) &#123; break; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (BOOL)info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 Wi-Fi 开关已经打开且 info 是 <code>nil</code> 那么就可以判断没有 Wi-Fi 权限。</p><h2 id="判断是否有蜂窝网络权限"><a href="#判断是否有蜂窝网络权限" class="headerlink" title="判断是否有蜂窝网络权限"></a>判断是否有蜂窝网络权限</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;CoreTelephony&#x2F;CTCellularData.h&gt;</span><br><span class="line"></span><br><span class="line">if ([GlobalUtils systemVersion] &gt;&#x3D; 9.0) &#123; &#x2F;&#x2F; iOS系统版本 &gt;&#x3D; 9.0</span><br><span class="line">CTCellularData *cellularData &#x3D; [[CTCellularData alloc] init];</span><br><span class="line">cellularData.cellularDataRestrictionDidUpdateNotifier &#x3D; ^(CTCellularDataRestrictedState state)&#123;</span><br><span class="line">&#x2F;&#x2F;获取联网状态</span><br><span class="line">switch (state) &#123;</span><br><span class="line">case kCTCellularDataRestricted:</span><br><span class="line">&#x2F;&#x2F; 蜂窝网络受限，提示用户</span><br><span class="line">...</span><br><span class="line">break;</span><br><span class="line">case kCTCellularDataNotRestricted:</span><br><span class="line">&#x2F;&#x2F; 有访问蜂窝网络的权限，说明蜂窝数据的开关被关闭了</span><br><span class="line">         ...</span><br><span class="line">break;</span><br><span class="line">case kCTCellularDataRestrictedStateUnknown: &#x2F;&#x2F; 从来没有过网络访问的时候会是这个状态</span><br><span class="line">&#x2F;&#x2F; 异常情况</span><br><span class="line">...</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; 异常情况</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><ol><li>国行版本的 iPhone 存在 Wi-Fi 权限的开关但是其他版本的 iPhone 不存在这个开关。</li><li>iOS 10 以上版本的操作系统不允许第三方 App 跳转到系统设置页面，只允许他们跳转到 App 自己的设置页。</li><li>国行版本的 iPhone 在蜂窝和 Wi-Fi 关闭的情况下可以设置应用的 Wi-Fi 和蜂窝的权限，而其他版本不可以。</li><li>无法知道蜂窝开关是否打开，只能知道有无权限，非国行版本的 iPhone 在蜂窝被关闭的情况下无法打开蜂窝权限，所以要特殊处理，iOS10.0 以下的版本跳转到系统的蜂窝移动网络设置页面，10.0 以上的版本不做跳转。</li></ol><h2 id="参见"><a href="#参见" class="headerlink" title="参见"></a>参见</h2><p><a href="http://blog.csdn.net/u011146511/article/details/64981647">iOS中判断网络的状态的几种方法</a><br><a href="http://blog.csdn.net/u011439689/article/details/50463158">iOS，利用URL Schemes跳转到设置wifi、蜂窝移动网络页面 </a><br><a href="https://github.com/phynet/iOS-URL-Schemes">iOS Settings URL Scheme</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近做了一个在 iOS 平台下提示用户网络异常的功能，许久没有做 iOS 原生需求了，接手这个需求后感觉 iOS 的坑也越来越多了。&lt;/p&gt;
&lt;p&gt;这种需求很常见，首先分析一下这里指的网络异常包括，飞行模式、Wi-Fi 和蜂窝网络都被关闭、Wi-Fi 连接状态下应用的 Wi-Fi 权限被关闭，只有蜂窝连接的情况下应用蜂窝权限被关闭。&lt;/p&gt;
&lt;p&gt;对这些情况的处理里程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2017/10/29/iOS/ios-network-exception/ios-network-exception.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;下面把整个流程中的实现方法和需要注意的坑讲一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="权限" scheme="https://ufolux.github.io/tags/%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>【20171019】操作日记</title>
    <link href="https://ufolux.github.io/2017/10/19/InvestmentLife/investment-and-life-20171019/"/>
    <id>https://ufolux.github.io/2017/10/19/InvestmentLife/investment-and-life-20171019/</id>
    <published>2017-10-19T13:44:07.000Z</published>
    <updated>2021-03-11T07:20:00.103Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>进入股票二级市场投资到现在也一年有余了，其中 A 股投资一年多，港股的投资也进行了半年有余，一年来也从一个股都不知道该怎么选的菜鸟变成了一个每日盈亏浮动三四千都波澜不惊的老股民。我最近总是和朋友讲，这一年来学习了很多，也成长了很多。其实这不是一句笑谈，除了在公司这个优秀团队中给自己带来的技术和社会阅历成长之外，投资也让我看到了充满欲望，贪婪，恐惧的脆弱人性。经过这段不长不短的投资之后，我觉得有必要将每日的操作进行记录，并阐述操作的理由，让自己能够更清晰的知道操作中存在什么问题，什么样的操作是合理的，什么样的操作又是由于脆弱人性或者盲目跟风导致的，希望对自己和看到的人都能有帮助。</p><span id="more"></span><p>切入正题，首先今日 A 股市场高位震荡，十九大期间的今天一开始就掀起了一波喝酒吃药吹空调吃榨菜的消费行情，表明资金开始采取防守姿态，神股茅台更是大涨 4 个点突破 580 元大关。今天为止手中持有以下股票</p><ol><li>美的集团(000333) </li><li>格力电器(000651) </li><li>青岛海尔(600690) </li><li>招商蛇口(001979) </li><li>集泰股份(002909)</li></ol><p>其中集泰股份是新股中签所得，这个纯属运气，也是念念不忘必有回响吧。A 股新股申购这种低风险投资还是要搞着点。</p><p>招商蛇口这个票，是之前同事推荐的，买它是因为招商蛇口在深圳蛇口片区占有了大量的优质土地资源，不夸张的说蛇口是招商蛇口开的。持有招商蛇口是一笔价值投资，长期持有。不过由于入场价格太高，成本价在 19.85 元，所以目前处于亏损的状态。这期间还经历了几次起起落落的调整和拉升，中间还赶上了政府的一次政策收紧，导致之前的所有利润回吐并且跌到了今天的新低价格还录得了巨额的亏损，但是这一切都已经忍到了现在，招商蛇口不断地试探着我的底线，我也都坚持住了。依然看好它的长期价值，继续坚定持有。</p><p>美的和招蛇几乎是同时入手的，美的也经历了2个月左右的调整，但最终跟随着最近的上证50白电行情冲上了新高，作为龙头股在短短几日已经上涨了 15% 之多。于前几天减仓至一半，并且将减仓获得的现金投入了青岛海尔和格力之中。这个操作有两点原因，美的最近资金流出，股价上涨，有庄家拉高出货的嫌疑。考虑这一点，我做了减仓的操作。相反格力资金流入，股价上涨，所以资金投入格力。至于青岛海尔则是因为，海尔的前三季度销售业绩得到明显的改观，已经走出了之前被边缘化的阴霾，但是知道我买入的时候这些价值尚未在其股价上体现出来，其股价并未跟随这波行情获得合理的上涨，所以我将大部分的资金投入了青岛海尔，这笔投资也在投入的当天获得盈利，截止今天，一周已经获利 11% 左右。</p><p>然后是 H 股，在香港市场股票变动记录如下</p><ol><li>新天绿色能源(000956) 持有</li><li>平安麦银八九牛C.C(64477) 沽出</li><li>中企法巴八八牛U.C(64584) 早上购入 下午沽出</li><li>平安瑞信八四牛(63153) 购入</li></ol><p>首先说下 00956 这只，这个股票是河北建投旗下的新能源公司，主营天然气和风电业务，看好它的有三点。第一、他在全国风电市场占有绝对的统治地位，装机容量全国第一而且已审批待建的装机容量更是十分庞大，新能源是未来的方向，该公司提前布局这一领域并取得领导地位在日后的新能源行业的竞争中占有绝对优势。第二、市盈很低 PE（TTM）只有 9.79，同时他还是一只破净股，市净率只有 0.8 左右，我认为市场对它的价值存在低估。第三、该公司将在 A 股市场进行 IPO 的消息属实，并且获得摩根士丹利的400万股增持，从市场反应来看利多该股，从十一假期开始关注它到昨天已经累计上涨 17% 左右，但现在依然便宜。所以继续持有这只股票。</p><p>平安是保险行业的龙头企业，今年上半年平安业绩良好，相比年初股价已经翻了一倍，市场对平安的预期良好，股价有进一步上涨空间。与此同时北水大量增持中国平安，更是进一步推高了它的价格。平安是一个大盘股，交易量巨大但是涨幅却甚微，所以我选择了平安的牛熊证产品进行杠杆投资以期获得更大收益。今日早上平安上涨高见 2% 所持有的 64477 牛证已经累计上涨 60%，为了控制风险，出掉了这只牛证。并且挂了一个很低的价格准备挂单购入 63153 这个牛证。</p><p>由于在全球牛市的环境下，中国股市依然处于低位震荡的状态（上证50除外），我个人看好中国经济的发展前景，所以我判断国指可能还会继续保持上涨行情，而且国指的波动不大，风险较小，所以购入了国指的牛证 64584 购入价位于今日的相对高位。 </p><p>最戏剧的是，今天下午 3 点半左右，恒指突然在十分钟之内大幅跳水 500 点，早盘购入的国指牛 64584 瞬间暴跌 30 点左右，这时我心中升起了巨大的恐惧，眼看在十分钟之内手中的牛证跌去了 30% 情急之下我选择了止损，抛售了牛证。然而这又犯了一个大忌，往往最恐惧的时候就是恐惧即将结束的时候，在这个时候选择止损，往往会录得最多的亏损，事实证明这个决策也是失误的，几乎抛售在了全日的最低点，成为最失败的一笔交易。在基本面没有吹an 根本性转变的时候，止损要谨慎，这种操作还是要引以为戒。</p><p>暴跌也导致我的本以为不可能成交的低价买单瞬间成交，又一次购入了平安牛 63153。购入之后平安股价继续暴跌至 2% 新购入的牛证又损失了奖金10个点。不过这么大的跌幅之下，明天定有回调，我认为无须担心，明天可能就指望这个回本了。</p><p>总结一下，今日的大市尾盘暴跌，据推断市因为外资投行获利盘借助周小川讲话的利空（伪）集中大量抛售导致的，今天被平仓的牛证也超过100只，可谓是被外资银行收割了一波。今天跌得很惨，回吐了前两日的涨幅，相信明日必有反弹，保持心态平和继续坚持投资。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;进入股票二级市场投资到现在也一年有余了，其中 A 股投资一年多，港股的投资也进行了半年有余，一年来也从一个股都不知道该怎么选的菜鸟变成了一个每日盈亏浮动三四千都波澜不惊的老股民。我最近总是和朋友讲，这一年来学习了很多，也成长了很多。其实这不是一句笑谈，除了在公司这个优秀团队中给自己带来的技术和社会阅历成长之外，投资也让我看到了充满欲望，贪婪，恐惧的脆弱人性。经过这段不长不短的投资之后，我觉得有必要将每日的操作进行记录，并阐述操作的理由，让自己能够更清晰的知道操作中存在什么问题，什么样的操作是合理的，什么样的操作又是由于脆弱人性或者盲目跟风导致的，希望对自己和看到的人都能有帮助。&lt;/p&gt;
    
    </summary>
    
      <category term="投资人生" scheme="https://ufolux.github.io/categories/%E6%8A%95%E8%B5%84%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="操作日记" scheme="https://ufolux.github.io/tags/%E6%93%8D%E4%BD%9C%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>为 ionic 3.x（ts）项目配置单元测试框架</title>
    <link href="https://ufolux.github.io/2017/10/11/Front_End/ionic/how-to-settingup-unittest-for-ionic3x/"/>
    <id>https://ufolux.github.io/2017/10/11/Front_End/ionic/how-to-settingup-unittest-for-ionic3x/</id>
    <published>2017-10-11T09:37:34.000Z</published>
    <updated>2021-03-11T07:20:00.095Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这是一个配置教程，关于 karma 和 jasmine 的知识请参考 <a href="https://karma-runner.github.io/1.0/index.html">karma doc</a> 和 <a href="https://jasmine.github.io/">jasmine doc</a>。</p><p>开始之前先看一下我们的目录结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">├── angular-cli.json</span><br><span class="line">├── config.xml</span><br><span class="line">├── ionic.config.json</span><br><span class="line">├── node_modules</span><br><span class="line">├── package.json</span><br><span class="line">├── resources</span><br><span class="line">├── src</span><br><span class="line">├── tests</span><br><span class="line">├── tsconfig.json</span><br><span class="line">├── tslint.json</span><br><span class="line">├── typings</span><br><span class="line">├── typings.json</span><br><span class="line">└── www</span><br></pre></td></tr></table></figure><p>这是一个直接使用 <code>ionic-cli</code> 创建的 <code>ionic3.x</code> 项目</p><span id="more"></span><h2 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h2><p>在项目的 <code>package.json</code> 的 <code>devDependencies</code> 中添加如下内容，然后执行 <code>npm i</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&quot;@angular&#x2F;cli&quot;: &quot;^1.3.2&quot;,</span><br><span class="line">   &quot;@ionic&#x2F;app-scripts&quot;: &quot;2.1.3&quot;,</span><br><span class="line">   &quot;@types&#x2F;jasmine&quot;: &quot;^2.5.54&quot;,</span><br><span class="line">   &quot;@types&#x2F;node&quot;: &quot;^8.0.26&quot;,</span><br><span class="line">   &quot;codelyzer&quot;: &quot;^3.1.2&quot;,</span><br><span class="line">   &quot;jasmine&quot;: &quot;^2.8.0&quot;,</span><br><span class="line">   &quot;jasmine-core&quot;: &quot;^2.8.0&quot;,</span><br><span class="line">   &quot;jasmine-spec-reporter&quot;: &quot;^4.2.1&quot;,</span><br><span class="line">   &quot;karma&quot;: &quot;^1.7.1&quot;,</span><br><span class="line">   &quot;karma-chrome-launcher&quot;: &quot;^2.2.0&quot;,</span><br><span class="line">   &quot;karma-cli&quot;: &quot;^1.0.1&quot;,</span><br><span class="line">   &quot;karma-coverage-istanbul-reporter &quot;: &quot;^1.3.0&quot;,</span><br><span class="line">   &quot;karma-jasmine&quot;: &quot;^1.1.0&quot;,</span><br><span class="line">   &quot;karma-jasmine-html-reporter&quot;: &quot;^0.2.2&quot;,</span><br><span class="line">   &quot;karma-mocha-reporter&quot;: &quot;^2.2.4&quot;,</span><br><span class="line">   &quot;karma-remap-istanbul&quot;: &quot;^0.6.0&quot;,</span><br></pre></td></tr></table></figure><p>在 <code>typings.json</code> (如果没有就创建一个) 文件中添加以下内容，然后执行 <code>typings install</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;globalDependencies&quot;: &#123;</span><br><span class="line">    &quot;jasmine&quot;: &quot;registry:dt&#x2F;jasmine#2.5.2+20170317130948&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>angular-cli.json</code>（如果没有就创建一个）文件中添加以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;project&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;app name&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;apps&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;root&quot;: &quot;src&quot;,</span><br><span class="line">      &quot;outDir&quot;: &quot;dist&quot;,</span><br><span class="line">      &quot;assets&quot;: [</span><br><span class="line">        &quot;assets&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;index&quot;: &quot;index.html&quot;,</span><br><span class="line">      &quot;main&quot;: &quot;.&#x2F;app&#x2F;main.ts&quot;,</span><br><span class="line">      &quot;polyfills&quot;: &quot;..&#x2F;tests&#x2F;polyfills.ts&quot;,</span><br><span class="line">      &quot;test&quot;: &quot;..&#x2F;tests&#x2F;test.ts&quot;,</span><br><span class="line">      &quot;tsconfig&quot;: &quot;..&#x2F;tests&#x2F;tsconfig.spec.json&quot;,</span><br><span class="line">      &quot;prefix&quot;: &quot;app&quot;,</span><br><span class="line">      &quot;mobile&quot;: false,</span><br><span class="line">      &quot;styles&quot;: [</span><br><span class="line">        &quot;styles.css&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;scripts&quot;: [],</span><br><span class="line">      &quot;environmentSource&quot;: &quot;..&#x2F;tests&#x2F;environments&#x2F;environment.ts&quot;,</span><br><span class="line">      &quot;environments&quot;: &#123;</span><br><span class="line">        &quot;dev&quot;: &quot;..&#x2F;tests&#x2F;environments&#x2F;environment.ts&quot;,</span><br><span class="line">        &quot;prod&quot;: &quot;..&#x2F;tests&#x2F;environments&#x2F;environment.prod.ts&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;addons&quot;: [],</span><br><span class="line">  &quot;packages&quot;: [],</span><br><span class="line">  &quot;test&quot;: &#123;</span><br><span class="line">    &quot;karma&quot;: &#123;</span><br><span class="line">      &quot;config&quot;: &quot;.&#x2F;karma.conf.js&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;defaults&quot;: &#123;</span><br><span class="line">    &quot;styleExt&quot;: &quot;css&quot;,</span><br><span class="line">    &quot;prefixInterfaces&quot;: false,</span><br><span class="line">    &quot;inline&quot;: &#123;</span><br><span class="line">      &quot;style&quot;: false,</span><br><span class="line">      &quot;template&quot;: false</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;spec&quot;: &#123;</span><br><span class="line">      &quot;class&quot;: false,</span><br><span class="line">      &quot;component&quot;: true,</span><br><span class="line">      &quot;directive&quot;: true,</span><br><span class="line">      &quot;module&quot;: false,</span><br><span class="line">      &quot;pipe&quot;: true,</span><br><span class="line">      &quot;service&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h2><p>在根目录下创建 <code>karma.conf.js</code> 文件，内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; function (config) &#123;</span><br><span class="line">  config.set(&#123;</span><br><span class="line">    basePath: &#39;&#39;,</span><br><span class="line">    frameworks: [&#39;jasmine&#39;, &#39;@angular&#x2F;cli&#39;],</span><br><span class="line">    plugins: [</span><br><span class="line">      require(&#39;karma-jasmine&#39;),</span><br><span class="line">      require(&#39;karma-chrome-launcher&#39;),</span><br><span class="line">      require(&#39;karma-remap-istanbul&#39;),</span><br><span class="line">      require(&#39;karma-mocha-reporter&#39;),</span><br><span class="line">      require(&#39;@angular&#x2F;cli&#x2F;plugins&#x2F;karma&#39;)</span><br><span class="line">    ],</span><br><span class="line">    files: [</span><br><span class="line">      &#123; pattern: &#39;.&#x2F;src&#x2F;test.ts&#39;, watched: false &#125;</span><br><span class="line">    ],</span><br><span class="line">    preprocessors: &#123;</span><br><span class="line">      &#39;.&#x2F;tests&#x2F;test.ts&#39;: [&#39;@angular&#x2F;cli&#39;]</span><br><span class="line">    &#125;,</span><br><span class="line">    mime: &#123;</span><br><span class="line">      &#39;text&#x2F;x-typescript&#39;: [&#39;ts&#39;,&#39;tsx&#39;]</span><br><span class="line">    &#125;,</span><br><span class="line">    remapIstanbulReporter: &#123;</span><br><span class="line">      reports: &#123;</span><br><span class="line">        html: &#39;coverage&#39;,</span><br><span class="line">        lcovonly: &#39;.&#x2F;coverage&#x2F;coverage.lcov&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    angularCli: &#123;</span><br><span class="line">      config: &#39;.&#x2F;angular-cli.json&#39;,</span><br><span class="line">      environment: &#39;dev&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    reporters: config.angularCli &amp;&amp; config.angularCli.codeCoverage</span><br><span class="line">      ? [&#39;mocha&#39;, &#39;karma-remap-istanbul&#39;]</span><br><span class="line">      : [&#39;mocha&#39;],</span><br><span class="line">    port: 9876,</span><br><span class="line">    colors: true,</span><br><span class="line">    logLevel: config.LOG_INFO,</span><br><span class="line">    autoWatch: true,</span><br><span class="line">    browsers: [&#39;Chrome&#39;],</span><br><span class="line">    singleRun: false</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h2><p>在 tests 目录下面创建 <code>tsconfig.spec.json</code> 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    &quot;baseUrl&quot;: &quot;&quot;,</span><br><span class="line">    &quot;declaration&quot;: false,</span><br><span class="line">    &quot;emitDecoratorMetadata&quot;: true,</span><br><span class="line">    &quot;experimentalDecorators&quot;: true,</span><br><span class="line">    &quot;lib&quot;: [</span><br><span class="line">      &quot;es6&quot;,</span><br><span class="line">      &quot;dom&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;mapRoot&quot;: &quot;.&#x2F;&quot;,</span><br><span class="line">    &quot;module&quot;: &quot;es6&quot;,</span><br><span class="line">    &quot;moduleResolution&quot;: &quot;node&quot;,</span><br><span class="line">    &quot;outDir&quot;: &quot;..&#x2F;dist&#x2F;out-tsc&quot;,</span><br><span class="line">    &quot;sourceMap&quot;: true,</span><br><span class="line">    &quot;target&quot;: &quot;es5&quot;,</span><br><span class="line">    &quot;typeRoots&quot;: [</span><br><span class="line">      &quot;..&#x2F;node_modules&#x2F;@types&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="step4"><a href="#step4" class="headerlink" title="step4"></a>step4</h2><p>在 tests 目录下面创建 <code>polyfills.ts</code> 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &#39;core-js&#x2F;es6&#x2F;symbol&#39;;</span><br><span class="line">import &#39;core-js&#x2F;es6&#x2F;object&#39;;</span><br><span class="line">import &#39;core-js&#x2F;es6&#x2F;function&#39;;</span><br><span class="line">import &#39;core-js&#x2F;es6&#x2F;parse-int&#39;;</span><br><span class="line">import &#39;core-js&#x2F;es6&#x2F;parse-float&#39;;</span><br><span class="line">import &#39;core-js&#x2F;es6&#x2F;number&#39;;</span><br><span class="line">import &#39;core-js&#x2F;es6&#x2F;math&#39;;</span><br><span class="line">import &#39;core-js&#x2F;es6&#x2F;string&#39;;</span><br><span class="line">import &#39;core-js&#x2F;es6&#x2F;date&#39;;</span><br><span class="line">import &#39;core-js&#x2F;es6&#x2F;array&#39;;</span><br><span class="line">import &#39;core-js&#x2F;es6&#x2F;regexp&#39;;</span><br><span class="line">import &#39;core-js&#x2F;es6&#x2F;map&#39;;</span><br><span class="line">import &#39;core-js&#x2F;es6&#x2F;set&#39;;</span><br><span class="line">import &#39;core-js&#x2F;es6&#x2F;reflect&#39;;</span><br><span class="line">import &#39;core-js&#x2F;es7&#x2F;reflect&#39;;</span><br><span class="line"></span><br><span class="line">import &#39;reflect-metadata&#39;;</span><br><span class="line">import &#39;zone.js&#39;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="step5"><a href="#step5" class="headerlink" title="step5"></a>step5</h2><p>在 tests 目录下面创建 <code>test.ts</code> 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">import &#39;.&#x2F;polyfills&#39;;</span><br><span class="line"></span><br><span class="line">import &#39;zone.js&#x2F;dist&#x2F;long-stack-trace-zone&#39;;</span><br><span class="line"></span><br><span class="line">import &#39;zone.js&#x2F;dist&#x2F;proxy.js&#39;;</span><br><span class="line"></span><br><span class="line">import &#39;zone.js&#x2F;dist&#x2F;sync-test&#39;;</span><br><span class="line"></span><br><span class="line">import &#39;zone.js&#x2F;dist&#x2F;jasmine-patch&#39;;</span><br><span class="line"></span><br><span class="line">import &#39;zone.js&#x2F;dist&#x2F;async-test&#39;;</span><br><span class="line"></span><br><span class="line">import &#39;zone.js&#x2F;dist&#x2F;fake-async-test&#39;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import &#123;getTestBed, TestBed&#125; from &#39;@angular&#x2F;core&#x2F;testing&#39;;</span><br><span class="line"></span><br><span class="line">import &#123;BrowserDynamicTestingModule, platformBrowserDynamicTesting&#125; from &#39;@angular&#x2F;platform-browser-dynamic&#x2F;testing&#39;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Unfortunately there&#39;s no typing for the &#96;__karma__&#96; variable. Just declare it as any.</span><br><span class="line"></span><br><span class="line">declare let __karma__: any;</span><br><span class="line"></span><br><span class="line">declare let require: any;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Prevent Karma from running prematurely.</span><br><span class="line"></span><br><span class="line">__karma__.loaded &#x3D; function (): void &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; noop</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; First, initialize the Angular testing environment.</span><br><span class="line"></span><br><span class="line">getTestBed().initTestEnvironment(</span><br><span class="line">  BrowserDynamicTestingModule,</span><br><span class="line"></span><br><span class="line">  platformBrowserDynamicTesting()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Then we find all the tests.</span><br><span class="line"></span><br><span class="line">let context: any &#x3D; require.context(&#39;.&#x2F;&#39;, true, &#x2F;\.spec\.ts&#x2F;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; And load the modules.</span><br><span class="line"></span><br><span class="line">context.keys().map(context);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Finally, start Karma to run the tests.</span><br><span class="line"></span><br><span class="line">__karma__.start();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="step6"><a href="#step6" class="headerlink" title="step6"></a>step6</h2><p>在 <code>tests</code> 目录下面创建 <code>environments</code> 目录，在这个目录中创建两个文件，内容分别如下</p><ol><li>environment.ts</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export const environment: any &#x3D; &#123;</span><br><span class="line">  production: false,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>environment.prod.ts</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export const environment: any &#x3D; &#123;</span><br><span class="line">  production: true,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Final-step"><a href="#Final-step" class="headerlink" title="Final step"></a>Final step</h2><p>在 <code>package.json</code> 中添加一个 <code>scripts</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;test&quot;: &quot;ng test&quot;</span><br></pre></td></tr></table></figure><p>至此，karma + jasmine 的测试环境已经配置完成了，执行 <code>npm test</code> 就可以开始执行测试用例了。</p><p>测试用例要放到 <code>tests</code> 目录下。我为我项目中的一个管道写的测试用例类似这个样子：</p><p>message-date.spec.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import &#123;MessageDatePipe&#125; from &quot;..&#x2F;..&#x2F;src&#x2F;pipes&#x2F;message-date&#x2F;message-date&quot;;</span><br><span class="line">import &#123;DATE_UNIT&#125; from &quot;..&#x2F;..&#x2F;src&#x2F;constants&#x2F;date-cons&quot;;</span><br><span class="line">import moment &#x3D; require(&quot;moment&quot;);</span><br><span class="line"></span><br><span class="line">describe(&#39;test all cases of message date&#39;, () &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">  let messageDatePipe: MessageDatePipe;</span><br><span class="line">  const today &#x3D; moment();</span><br><span class="line">  const oneMinuteAgo &#x3D; today.clone().add(-1, DATE_UNIT.MINUTES).format(&#39;x&#39;);</span><br><span class="line">  const oneDayAgo &#x3D; today.clone().add(-1, DATE_UNIT.DAYS).format(&#39;x&#39;);</span><br><span class="line">  const oneWeekAgo &#x3D; today.clone().add(-7, DATE_UNIT.DAYS).format(&#39;x&#39;);</span><br><span class="line"></span><br><span class="line">  beforeEach(() &#x3D;&gt; &#123;</span><br><span class="line">    messageDatePipe &#x3D; new MessageDatePipe();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&#39;one week ago&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    expect(messageDatePipe.transform(oneWeekAgo)).toMatch(&#x2F;[0-9]&#123;4&#125;-[0-9]&#123;2&#125;-[0-9]&#123;2&#125;&#x2F;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&#39;one day ago&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    expect(messageDatePipe.transform(oneDayAgo)).toMatch(&#x2F;[0-9]&#123;2&#125;-[0-9]&#123;2&#125;&#x2F;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&#39;within current day&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    expect(messageDatePipe.transform(oneMinuteAgo)).toMatch(&#x2F;(A|P)M [0-9]&#123;2&#125;:[0-9]&#123;2&#125;&#x2F;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&#39;one week ago num&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    expect(messageDatePipe.transform(parseInt(oneWeekAgo))).toMatch(&#x2F;[0-9]&#123;4&#125;-[0-9]&#123;2&#125;-[0-9]&#123;2&#125;&#x2F;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&#39;one day ago num&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    expect(messageDatePipe.transform(parseInt(oneDayAgo))).toMatch(&#x2F;[0-9]&#123;2&#125;-[0-9]&#123;2&#125;&#x2F;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&#39;within current day num&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    expect(messageDatePipe.transform(parseInt(oneMinuteAgo))).toMatch(&#x2F;(A|P)M [0-9]&#123;2&#125;:[0-9]&#123;2&#125;&#x2F;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行后结果如图所示</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fkeksaim7gj30hs0lumxq.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个配置教程，关于 karma 和 jasmine 的知识请参考 &lt;a href=&quot;https://karma-runner.github.io/1.0/index.html&quot;&gt;karma doc&lt;/a&gt; 和 &lt;a href=&quot;https://jasmine.github.io/&quot;&gt;jasmine doc&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;开始之前先看一下我们的目录结构&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;├── angular-cli.json&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── config.xml&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── ionic.config.json&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── node_modules&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── package.json&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── resources&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── src&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── tests&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── tsconfig.json&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── tslint.json&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── typings&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── typings.json&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;└── www&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这是一个直接使用 &lt;code&gt;ionic-cli&lt;/code&gt; 创建的 &lt;code&gt;ionic3.x&lt;/code&gt; 项目&lt;/p&gt;
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="UnitTest" scheme="https://ufolux.github.io/tags/UnitTest/"/>
    
      <category term="ionic" scheme="https://ufolux.github.io/tags/ionic/"/>
    
  </entry>
  
  <entry>
    <title>ionic3.x LazyLDoad 实现方法的探究</title>
    <link href="https://ufolux.github.io/2017/09/28/Front_End/ionic/research-of-ionic3-x-lazy-load-implementation/"/>
    <id>https://ufolux.github.io/2017/09/28/Front_End/ionic/research-of-ionic3-x-lazy-load-implementation/</id>
    <published>2017-09-28T12:12:38.000Z</published>
    <updated>2021-03-11T07:20:00.096Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是-Lazy-Load"><a href="#什么是-Lazy-Load" class="headerlink" title="什么是 Lazy Load"></a>什么是 Lazy Load</h2><p>LazyLoad 就是懒加载，Angular2 对懒加载提供了很好的支持，只需要在根模块的路由上写一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; app.module.ts</span><br><span class="line">export const ROUTES: Routes &#x3D; [</span><br><span class="line">  &#123; path: &#39;reports&#39;, loadChildren: &#39;..&#x2F;reports&#x2F;reports.module#ReportsModule&#39; &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>只要提供 loadChildren 字段应用初始化的时候就不会加载 <code>report</code> 这个模块，而是会在用到它的时候才加载它，这会缩减应用初始化时需要加载的文件大小，以此来提升应用的启动速度。</p><span id="more"></span><h3 id="LazyLoad-Page-在-ionic3-x-中的用法"><a href="#LazyLoad-Page-在-ionic3-x-中的用法" class="headerlink" title="LazyLoad Page 在 ionic3.x 中的用法"></a>LazyLoad Page 在 ionic3.x 中的用法</h3><h4 id="step1："><a href="#step1：" class="headerlink" title="step1："></a>step1：</h4><p>为需要懒加载的组件添加 <code>IonicPage</code> 装饰器，例如这个 <code>HomePage</code> 组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; home-page.ts</span><br><span class="line">import &#123; Component &#125; from &#39;@angular&#x2F;core&#39;;</span><br><span class="line">import &#123; IonicPage &#125; from &#39;ionic-angular&#39;;</span><br><span class="line">@IonicPage()</span><br><span class="line">@Component(... )</span><br><span class="line">export class HomePage &#123; ... &#125;</span><br></pre></td></tr></table></figure><h4 id="step2"><a href="#step2" class="headerlink" title="step2:"></a>step2:</h4><p>为这个组件添加一个 <code>IonicPageModule</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; home-page.module.ts</span><br><span class="line">import &#123; NgModule &#125; from &#39;@angular&#x2F;core&#39;;</span><br><span class="line">import &#123; IonicPageModule &#125; from &#39;ionic-angular&#39;;</span><br><span class="line">import &#123; HomePage &#125; from &#39;.&#x2F;home&#39;;</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  declarations: [HomePage],</span><br><span class="line">  imports: [IonicPageModule.forChild(HomePage)],</span><br><span class="line">&#125;)</span><br><span class="line">export class HomePageModule &#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="Angular-4-x-Lazy-Load-的实现方式"><a href="#Angular-4-x-Lazy-Load-的实现方式" class="headerlink" title="Angular 4.x Lazy Load 的实现方式"></a>Angular 4.x Lazy Load 的实现方式</h2><h3 id="1-使用-SystemJS-实现（不使用-webpack-的方式）"><a href="#1-使用-SystemJS-实现（不使用-webpack-的方式）" class="headerlink" title="1. 使用 SystemJS 实现（不使用 webpack 的方式）"></a>1. 使用 SystemJS 实现（不使用 webpack 的方式）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; packages&#x2F;core&#x2F;src&#x2F;linker&#x2F;system_js_ng_module_factory_loader.ts</span><br><span class="line">private loadAndCompile(path: string): Promise&lt;NgModuleFactory&lt;any&gt;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  return System.import(module) &#x2F;&#x2F; 采用 System.import 来加载</span><br><span class="line">    .then((module: any) &#x3D;&gt; module[exportName])</span><br><span class="line">    .then((type: any) &#x3D;&gt; checkNotEmpty(type, module, exportName))</span><br><span class="line">    .then((type: any) &#x3D;&gt; this._compiler.compileModuleAsync(type));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果应用是基于 SystemJS 而不是使用 angular-cli 来构建的，这里直接调用 <code>System.import</code> 来异步加载所需要的模块。</p><h4 id="2-使用-ngtools-webpack-实现"><a href="#2-使用-ngtools-webpack-实现" class="headerlink" title="2. 使用 @ngtools/webpack 实现"></a>2. 使用 <code>@ngtools/webpack</code> 实现</h4><p>webpack 其实是支持把 <code>System.import()</code> 作为一个代码切分点，但仅支持某些动态情景（如 <code>System.import(&#39;routes/&#39; + module + &#39;.js&#39;)</code>），webpack会根据 <code>&#39;routes/&#39; + module + &#39;.js&#39;</code> 里的 <code>routes/</code> 和 <code>.js</code> 等静态信息推测所有情景，并生成对应的 context module 负责加载这些动态模块。不过对于纯表达式（如 <code>System.import(module)</code>），没有任何已知信息，webpack 就没有办法切分代码了，而这也就是我们遇到的情况。既然 webpack 自身无法预处理，那就是由开发者来告诉 webpack 如何处理，这就是 <code>@ngtools/webpack</code> 的处理思路，它同过分析 <code>loadChildren</code> 的值，抽取需要懒加载的模块信息，打包这些模块，并生成对应的 context module，建立映射对象，映射对象大概是下面这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var map &#x3D; &#123;</span><br><span class="line">&quot;.&#x2F;lazy&#x2F;lazy.module&quot;: [</span><br><span class="line">267, &#x2F;&#x2F; module id</span><br><span class="line">0 &#x2F;&#x2F; index</span><br><span class="line">]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>动将这些文件打包成单独的代码块，并用即使执行函数对它们进行包装，<code>System.import</code> 会被webpack 替换为 <code>__webpack_require__</code> 方法。在运行时通过这个方法来加载所需要的模块。</p><h2 id="Ionic-3-x-基于-ionic-cli-的实现方式"><a href="#Ionic-3-x-基于-ionic-cli-的实现方式" class="headerlink" title="Ionic 3.x 基于 ionic-cli 的实现方式"></a>Ionic 3.x 基于 ionic-cli 的实现方式</h2><h3 id="deep-link-system"><a href="#deep-link-system" class="headerlink" title="deep link system"></a>deep link system</h3><p><strong>deep link system</strong> 是一个用于在 ionic App 中进行导航的系统，他会维护 app 内部的页面的名称和组件的对应关系，</p><p>首先创建一个 NgModule</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; my-page.module.ts</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  declarations: [</span><br><span class="line">    MyPage</span><br><span class="line">  ],</span><br><span class="line">  imports: [</span><br><span class="line">    IonicPageModule.forChild(MyPage)</span><br><span class="line">  ],</span><br><span class="line">  entryComponents: [</span><br><span class="line">    MyPage</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line">export class MyPageModule &#123;&#125;</span><br></pre></td></tr></table></figure><p>然后为页面组件添加 @ionicPage 装饰器，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; my-page.ts</span><br><span class="line">@IonicPage()</span><br><span class="line">@Component(&#123;</span><br><span class="line">  templateUrl: &#39;main.html&#39;</span><br><span class="line">&#125;)</span><br><span class="line">export class MyPage &#123;&#125;</span><br></pre></td></tr></table></figure><p>ionic-cli 会自动为这个页面创建一个 deep link，链接的名称默认与组件名称一致，我们在 App 中可以使用 ‘MyPage’ 字符串进行页面导航。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">  templateUrl: &#39;another-page.html&#39;</span><br><span class="line">&#125;)</span><br><span class="line">export class AnotherPage &#123;</span><br><span class="line">  constructor(public navCtrl: NavController) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  goToMyPage() &#123;</span><br><span class="line">    &#x2F;&#x2F; go to the MyPage component</span><br><span class="line">    this.navCtrl.push(&#39;MyPage&#39;); &#x2F;&#x2F; use a string</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒加载正是基于这种方式实现的，下面来说一下过程</p><h3 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h3><ol><li><p>遍历所有的 ts 文件</p></li><li><p>解析 ts 文件的语法树，获取语法树中的 class declaration 节点</p></li><li><p>遍历 class declaration 节点上的 decorators 节点取得 IonicPage 节点</p></li><li><p>解析 IonicPage 装饰器的元数据，(一个页面中只允许存在一个 Ionicpage 装饰器)</p></li><li><p>根据被 IonicPage 所在的文件名，按照 ionic-cli 定义的规则获得 Component 对应的 PageModule 文件路径</p></li><li><p>如果是 AOT 模式则将 Module 的文件名修改为 <code>.ngfactory.ts</code></p></li><li><p>将路径信息和 Module 的元数据（<code>DeepLinkDecoratorData</code> 类型）添加到 <code>deepLinkConfigEntries</code> 数组中</p></li><li><p>将这个数组中的信息转换成以下格式的字符串，并缓存</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  links: [</span><br><span class="line">    &#123;</span><br><span class="line">       loadChildren: &#39;..&#x2F;pages&#x2F;xyz&#x2F;xyz-home&#x2F;xyz-home.module#XyzPageModule&#39;,</span><br><span class="line">       name: &#39;XyzPage&#39;,</span><br><span class="line">       segment: &#39;xyz-home&#39;,</span><br><span class="line">       priority: &#39;low&#39;,</span><br><span class="line">       defaultHistory: []</span><br><span class="line">     &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将这段代码插入到 app.module.ts 中</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import &#123;NgModule&#125; from &#39;@angular&#x2F;core&#39;;</span><br><span class="line">import &#123;BrowserModule&#125; from &#39;@angular&#x2F;platform-browser&#39;;</span><br><span class="line">import &#123;IonicApp, IonicModule&#125; from &#39;ionic-angular&#39;;</span><br><span class="line"></span><br><span class="line">import &#123;DrifterApp&#125; from &#39;.&#x2F;app.component&#39;;</span><br><span class="line">import &#123;DECLARATIONS&#125; from &#39;.&#x2F;declarations&#39;;</span><br><span class="line">import &#123;ENTRY_COMPONENTS&#125; from &#39;.&#x2F;entry-component&#39;;</span><br><span class="line">import &#123;PROVIDER&#125; from &#39;.&#x2F;providers&#39;;</span><br><span class="line">import &#123;ComponentsModule&#125; from &#39;..&#x2F;components&#x2F;components.module&#39;;</span><br><span class="line">import &#123;PipesModule&#125; from &#39;..&#x2F;pipes&#x2F;pipes.module&#39;;</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  declarations: DECLARATIONS,</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    IonicModule.forRoot(DrifterApp, &#123;</span><br><span class="line">      backButtonText: &#39;&#39;,</span><br><span class="line">      iconMode: &#39;ios&#39;,</span><br><span class="line">      mode: &#39;ios&#39;,</span><br><span class="line">    &#125;,&#x2F;&#x2F; 插入到这个位置后面</span><br><span class="line">    &#123;</span><br><span class="line">  links: [</span><br><span class="line">     &#123; </span><br><span class="line">       loadChildren: &#39;..&#x2F;pages&#x2F;xyz&#x2F;xyz-home&#x2F;xyz-home.module#XyzPageModule&#39;,</span><br><span class="line">       name: &#39;XyzPage&#39;, </span><br><span class="line">       segment: &#39;xyz-home&#39;, </span><br><span class="line">       priority: &#39;low&#39;, </span><br><span class="line">       defaultHistory: []</span><br><span class="line">     &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;),</span><br><span class="line">    ComponentsModule,</span><br><span class="line">    PipesModule</span><br><span class="line">  ],</span><br><span class="line">  bootstrap: [IonicApp],</span><br><span class="line">  entryComponents: ENTRY_COMPONENTS,</span><br><span class="line">  providers: PROVIDER</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export class AppModule &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个对象被当做 <code>IonicModule.forRoot</code> 的第三个参数 <code>deepLinkConfig</code> 传入<br>，这个参数在后面会被当做一个 <code>ValueProvider</code> （DeepLinkConfigToken:OpaqueToken） 加入到 <code>IonicModule</code> 中</p><p>10.在 webpack 阶段，猜测：使用了和 <code>@ngtools/webpack</code> 工具类似的方法，讲需要懒加载的代码切分成几个单独的文件，以供运行时动态加载。</p><h3 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h3><p>Ionic3.x 中页面路由采用了一种全新的方式，使用了一个叫做 DeepLinker 的服务来维护页面的路由信息</p><p>具体的操作如下：<br>当我们调用 <code>NavController.push</code> 方法，并且传入一个字符串（Page 的名称）的时候，ionic 就会加载这个页面组件</p><ol><li><p>push 会触发 <code>NavControllerBase</code> 中 <code>_loadLazyLoading</code> 的调用，调用时会将页面名称以及参数等信息传入该方法</p></li><li><p>在 <code>_loadLazyLoading</code> 方法中会调用一个叫做 <code>convertToViews</code> 的方法，这个方法会将传入的 PageName 转换为一个可以使用的 Component。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NavControllerBase.prototype._loadLazyLoading &#x3D; function (ti) &#123;</span><br><span class="line">        var _this &#x3D; this;</span><br><span class="line">        var &#x2F;** @type &#123;?&#125; *&#x2F; insertViews &#x3D; ti.insertViews;</span><br><span class="line">        if (insertViews) &#123;</span><br><span class="line">            (void 0) &#x2F;* assert *&#x2F;;</span><br><span class="line">            return convertToViews(this._linker, insertViews).then(function (viewControllers) &#123;</span><br><span class="line">            ...</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        return Promise.resolve();</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></li><li><p>如果传入的是 PageName 字符串，会调用 <code>getComponent</code> 函数将字符串对应的 Component 所在的 js 文件加载进来。</p></li><li><p><code>getComponent</code> 函数使用 <code>deeplinker</code> 中的 <code>getComponentFromName</code> 方法获取这个页面对应的路径。路径保存在上文提到的 <code>linker</code> 对象的 <code>loadChildren</code> 属性中。</p></li><li><p>使用 SystemJS 提供的 <code>System.import</code> 方法来动态加载这些文件，webpack2.x 支持 <code>System.import</code> 的模块，它会将 <code>System.import</code> 替换为 <code>__webpack_require__</code> (但据说在 Webpack3.x 中已经废弃了对 System.import 的支持），同时被单独打包的模块会被即使执行函数表达式（IIFE）包裹，<code>__webpack_require__</code> 这个方法执行后会创建一个 JSONP 请求，也就是在 Header 中插入一个 script 标签使浏览器请求需要的脚本，并立即执行该脚本，这样就得到了需要的模块。</p></li></ol><h2 id="Next-Step"><a href="#Next-Step" class="headerlink" title="Next Step"></a>Next Step</h2><ol><li>上述内容只研究了页面的懒加载方式，至于 Pipe，Directive 以及其他非页面的  Component 的懒加载实现方式还有待实践和研究。</li><li>构建时代码切分的处理还没有找到，看生成的代码中有着和 <code>@ngtools/webpack</code> 生成的代码中相似的结构  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; src lazy 代码块</span><br><span class="line">var map &#x3D; &#123;</span><br><span class="line">&quot;..&#x2F;pages&#x2F;bottle&#x2F;add-bottle&#x2F;add-bottle.module&quot;: [</span><br><span class="line">406,</span><br><span class="line">10</span><br><span class="line">]</span><br><span class="line">&#125;;</span><br><span class="line">function webpackAsyncContext(req) &#123;</span><br><span class="line">var ids &#x3D; map[req];</span><br><span class="line">if(!ids)</span><br><span class="line">return Promise.reject(new Error(&quot;Cannot find module &#39;&quot; + req + &quot;&#39;.&quot;));</span><br><span class="line">return __webpack_require__.e(ids[1]).then(function() &#123;</span><br><span class="line">return __webpack_require__(ids[0]);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br><span class="line">webpackAsyncContext.keys &#x3D; function webpackAsyncContextKeys() &#123;</span><br><span class="line">return Object.keys(map);</span><br><span class="line">&#125;;</span><br><span class="line">webpackAsyncContext.id &#x3D; 155;</span><br><span class="line">module.exports &#x3D; webpackAsyncContext;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; WEBPACK FOOTER</span><br><span class="line">&#x2F;&#x2F; .&#x2F;src lazy</span><br><span class="line">&#x2F;&#x2F; module id &#x3D; 155</span><br><span class="line">&#x2F;&#x2F; module chunks &#x3D; 12</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以推测ionic-cli 同样是实现了和 <code>@ngtools/webpack</code> 类似的能力。</p><h2 id="参见"><a href="#参见" class="headerlink" title="参见"></a>参见</h2><p><a href="https://qiutc.me/post/webpack-2-%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7-What-s-new-in-webpack-2.html">webpack 2 的新特性</a></p><p><a href="https://ionicframework.com/docs/api/IonicModule/#forRoot">DOC IonicModule</a></p><p><a href="https://angular.cn/api/core/Provider">Provider 的种类以及它们的类型定义</a></p><p><a href="https://ionicframework.com/docs/api/navigation/IonicPage/">Deep link system in Ionic Apps</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-Lazy-Load&quot;&gt;&lt;a href=&quot;#什么是-Lazy-Load&quot; class=&quot;headerlink&quot; title=&quot;什么是 Lazy Load&quot;&gt;&lt;/a&gt;什么是 Lazy Load&lt;/h2&gt;&lt;p&gt;LazyLoad 就是懒加载，Angular2 对懒加载提供了很好的支持，只需要在根模块的路由上写一个&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; app.module.ts&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export const ROUTES: Routes &amp;#x3D; [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123; path: &amp;#39;reports&amp;#39;, loadChildren: &amp;#39;..&amp;#x2F;reports&amp;#x2F;reports.module#ReportsModule&amp;#39; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;只要提供 loadChildren 字段应用初始化的时候就不会加载 &lt;code&gt;report&lt;/code&gt; 这个模块，而是会在用到它的时候才加载它，这会缩减应用初始化时需要加载的文件大小，以此来提升应用的启动速度。&lt;/p&gt;
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="ionic" scheme="https://ufolux.github.io/tags/ionic/"/>
    
  </entry>
  
  <entry>
    <title>【持续更新】hexo 报错系列</title>
    <link href="https://ufolux.github.io/2017/09/28/Front_End/vendor/hexoErrorMouduleVerMimatch/"/>
    <id>https://ufolux.github.io/2017/09/28/Front_End/vendor/hexoErrorMouduleVerMimatch/</id>
    <published>2017-09-28T09:18:13.000Z</published>
    <updated>2021-03-11T07:20:00.102Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-Module-version-mismatch-Expected-48-got-51"><a href="#1-Module-version-mismatch-Expected-48-got-51" class="headerlink" title="1. Module version mismatch. Expected 48, got 51"></a>1. Module version mismatch. Expected 48, got 51</h2><p>错误原因：编译 <code>hexo</code> 的 <code>Node.js</code> 版本和执行 <code>hexo</code> 的 <code>Node.js</code> 版本不同。<br>解决办法：进入到 <code>/usr/local/lib/node_modules/hexo/</code> 中执行 <code>npm rebuild</code> 即可解决</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="hexo" scheme="https://ufolux.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Chrome inspect devices 打开空白页面的问题</title>
    <link href="https://ufolux.github.io/2017/09/28/Front_End/tools/emptyPageWhenDebugWithChrome/"/>
    <id>https://ufolux.github.io/2017/09/28/Front_End/tools/emptyPageWhenDebugWithChrome/</id>
    <published>2017-09-28T09:14:49.000Z</published>
    <updated>2021-03-11T07:20:00.098Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近换了个新电脑，发现连手机调试 H5 页面的时候，chrome 可以发现设备，但是点击<code>inspect</code> 按钮之后弹出的调试窗口是一个空白页面。</p><p><img src="/2017/09/28/Front_End/tools/emptyPageWhenDebugWithChrome/empty.png" alt></p><p>这问题搞得人很懵逼，一通搜索之后发现 chrome 项目中的一个 issue 提到：</p><blockquote><p>致中国同胞：如果你按照要求操作最后却得到一个空窗口，翻墙后再试试。不用谢。</p></blockquote><p>无语，翻墙后搞定。致所有中国同胞，遇事先想想是不是墙挡住了你。</p><p>经试验，这个只会在第一次使用 Chrome 调试设备时候出现，应该是第一次调试的时候Chrome会从 Google 那里加载 ChromeDevTool 的页面文件到本地并且将其缓存起来。加载过之后就不会再出现这个情况了。</p><p>参见<br><a href="https://github.com/GoogleChrome/ADBPlugin/issues/14">issue#14</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="工具" scheme="https://ufolux.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Chrome" scheme="https://ufolux.github.io/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>active 伪类在 iOS 中不触发的问题</title>
    <link href="https://ufolux.github.io/2017/08/11/Front_End/css/active-pesudo-class-dosent-work-on-ios/"/>
    <id>https://ufolux.github.io/2017/08/11/Front_End/css/active-pesudo-class-dosent-work-on-ios/</id>
    <published>2017-08-11T02:01:57.000Z</published>
    <updated>2021-03-11T07:20:00.095Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>点击按钮的时候通常会为按钮提供一个按压高亮的处理，这时候我们就会用到 <code>:active</code> 伪类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">button:active &#123;</span><br><span class="line">  background-color: black;</span><br><span class="line">  color: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在安卓手机上当我们按下按钮的时候，<code>:active</code> 的表现和我们的预期是一致的，按钮会呈现按压态。但是在 iOS 设备上却没有效果。</p><p>查阅了一下文档，发现上面写着这句话：</p><blockquote><p>[1] Safari Mobile 默认不使用:active 状态，除非元素上或<body>上有一个touchstart 事件处理器。</body></p></blockquote><p>也就是说在 iOS 设备上只有我们监听了 body 的 touchstart 事件，<code>:active</code> 才会有效果。所以我们这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.body.addEventListener(&#39;touchstart&#39;, () &#x3D;&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure><p>添加上述代码后，<code>:active</code> 就可以被正常触发了。</p><p>参考资料：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:active">:active on MDN web docs</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="css" scheme="https://ufolux.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>JS 将内容导出为文件并下载</title>
    <link href="https://ufolux.github.io/2017/08/10/Front_End/js-fondation/js-export-file/"/>
    <id>https://ufolux.github.io/2017/08/10/Front_End/js-fondation/js-export-file/</id>
    <published>2017-08-10T11:27:19.000Z</published>
    <updated>2021-03-11T07:20:00.097Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原理就是创建一个<code>&lt;a&gt;</code> 标签，创建一个 blob 对象，然后用 js 触发点击事件来下载 blob 对象即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const content &#x3D; &#39;file content&#39;</span><br><span class="line">const aLink &#x3D; document.createElement(&#39;a&#39;);</span><br><span class="line">const blob &#x3D; new Blob([content]);</span><br><span class="line">aLink.download &#x3D; &#39;title of file.ext&#39;;</span><br><span class="line">aLink.href &#x3D; URL.createObjectURL(blob);</span><br><span class="line">aLink.click();</span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob">关于 blob</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="JS" scheme="https://ufolux.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>谷歌不断要求人机验证的解决方案</title>
    <link href="https://ufolux.github.io/2017/08/02/Casual/SolutionForGoogleRecaptcha/"/>
    <id>https://ufolux.github.io/2017/08/02/Casual/SolutionForGoogleRecaptcha/</id>
    <published>2017-08-02T01:43:18.000Z</published>
    <updated>2021-03-11T07:20:00.080Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近发现通过我自己搭的 ss 访问 google 也会出现要求人机验证的页面，怀疑是有人在 vps 所在的网段上面搞爬虫什么的，导致 google 将网段加入了黑名单。不过我发现验证页面的 url 都是以 ipv4 开头的，说明可能是 ss 服务器所在的 ipv4 地址被 google 加入了黑名单，但是 ipv6 可能是没有被限制的。我向 ss 服务器的 /etc/hosts 追加如下的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2607:f8b0:4005:801::200e google.com</span><br><span class="line">2607:f8b0:4005:801::200e www.google.com</span><br><span class="line">2404:6800:4005:807::2003 google.com.hk</span><br><span class="line">2404:6800:4005:807::2003 www.google.com.hk</span><br><span class="line">2404:6800:4005:807::2003 google.com.tw</span><br><span class="line">2404:6800:4005:807::2003 www.google.com.tw</span><br></pre></td></tr></table></figure><p>这样可以强制使用 ipv6 地址来访问 google。验证码就会消失了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="梯子" scheme="https://ufolux.github.io/tags/%E6%A2%AF%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>ReactNative 的远程调试原理</title>
    <link href="https://ufolux.github.io/2017/07/05/Front_End/ReactNative/remote-debug-thoery-of-reactnative/"/>
    <id>https://ufolux.github.io/2017/07/05/Front_End/ReactNative/remote-debug-thoery-of-reactnative/</id>
    <published>2017-07-05T08:20:51.000Z</published>
    <updated>2021-03-11T07:20:00.095Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>众所周知，RN 提供了一个远程调试的功能，在调试的过程中可以自动刷新资源，这极大地方便了开发的过程。但这个方便的功能是如何实现的呢？开发机是如何得知需要从哪里拉取资源的呢？这两天正在搞 RN 方面的研究，正好研究了一下这个问题，感觉这是一个很好的调试思路，以后可能会有用，先在这做个记录。</p><p>在 react-native-xcode.sh 脚本中使用下面的代码获取了作为 debug server 的电脑的 IP 地址<br><code>IP=$(ifconfig | grep &#39;inet &#39; | grep -v 127.0.0.1 | cut -d\   -f2  | awk &#39;NR==1&#123;print $1&#125;&#39;)</code></p><p>然后使用如下语句将 IP 地址写入 <code>ip.txt</code> 文件中，然后将这个文件放到 app 的资源目录下</p><p><code>echo &quot;$IP&quot; &gt; &quot;$DEST/ip.txt&quot;</code></p><p>然后使用 Xcode 构建 APP 的时候，这个 <code>ip.txt</code> 文件会作为资源被打包进 app 安装包中。当 ReactNative 程序开始运行的时候在 <code>RCTBundleURLProvider</code> 的 <code>guessPackagerHost</code> 方法中读取这个文件以获取 IP 地址，然后从这个 IP 地址的 debug server 上获取 jsbundle</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)guessPackagerHost</span><br><span class="line">&#123;</span><br><span class="line">  static NSString *ipGuess;</span><br><span class="line">  static dispatch_once_t onceToken;</span><br><span class="line">  dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    NSString *ipPath &#x3D; [[NSBundle mainBundle] pathForResource:@&quot;ip&quot; ofType:@&quot;txt&quot;];</span><br><span class="line">    ipGuess &#x3D; [[NSString stringWithContentsOfFile:ipPath encoding:NSUTF8StringEncoding error:nil]</span><br><span class="line">               stringByTrimmingCharactersInSet:[NSCharacterSet newlineCharacterSet]];</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  NSString *host &#x3D; ipGuess ?: @&quot;localhost&quot;;</span><br><span class="line">  if ([self isPackagerRunning:host]) &#123;</span><br><span class="line">    return host;</span><br><span class="line">  &#125;</span><br><span class="line">  return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="ReactNative" scheme="https://ufolux.github.io/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>详解 Angular2 的变更检查原理</title>
    <link href="https://ufolux.github.io/2017/07/04/Front_End/Angular/AngularChangeDetection/"/>
    <id>https://ufolux.github.io/2017/07/04/Front_End/Angular/AngularChangeDetection/</id>
    <published>2017-07-04T03:20:51.000Z</published>
    <updated>2021-03-11T07:20:00.093Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>相比 Angular1 而言 Angular2 的变更检查机制更加透明，更加可预测。但是在使用 Angular2 开发的过程中依然存在着一些场景（比如性能优化）需要我们更深入的了解在框架的底层究竟发生了什么。</p><p>本文包含如下内容：</p><ul><li>变化产生于异步操作</li><li>为浏览器打补丁<ul><li>Zone.js</li><li>补丁是如何工作的</li><li>Angular2 中 Zone 的应用<ul><li>自动检查数据变化</li><li>可选的变更检查</li></ul></li></ul></li><li>Angular2.x 变更检查工作原理<ul><li>Angular 的默认变更检查如何工作</li><li>OnPush 模式</li></ul></li><li>总结</li><li>参考资料</li></ul><blockquote><p>本文的描述基于 Angular 2.4.9 版本</p></blockquote><span id="more"></span><p>众所周知，在 Angular1 中我们需要使用 <code>$apply</code> 或者其他框架提供的方法来触发 <code>$digest</code> 循环来进行脏值检查，但是 Angular2 可以自动检查到组件属性的数据变化，并重新渲染视图来更新数据的展示。那么 Angular2 是怎样自动检查到数据变化的呢（比如页面上任意一个文本框的输入或者 Ajax 请求的响应等）。</p><h2 id="变化产生于异步操作"><a href="#变化产生于异步操作" class="headerlink" title="变化产生于异步操作"></a>变化产生于异步操作</h2><p>在组件初始化之后的<strong>一切</strong>数据变化均是由某个异步事件产生的，注意，这里是变化<strong>仅仅</strong>可能由异步事件来产生。因为初始化是一个同步过程，在 Angular2 框架中，组件的初始化对应的就是组件的构造方法被调用，这个构造过程是一个同步的过程。在构造过程之后就只有异步事件才会导致组件中的数据发生变化。这个事件，我们可以理解为鼠标的点击，ajax 请求，Promise，setTimeout 或者 Websocket 等等。</p><h2 id="为浏览器打补丁"><a href="#为浏览器打补丁" class="headerlink" title="为浏览器打补丁"></a>为浏览器打补丁</h2><h3 id="Zone-js"><a href="#Zone-js" class="headerlink" title="Zone.js"></a>Zone.js</h3><p>为了能在这些事件发生的时候及时的检查变化，在 Angular2 应用启动的时候会为许多浏览器的提供的 API 打补丁，使用代理方法来代理浏览器 API 的调用，代理方法不仅会调用监听事件时提供的回调函数，还会执行变更检查以及刷新界面。</p><p>这种为浏览器打补丁的工作，是由一个叫做 Zone.js 的库来完成的，Zone.js 是 Angular 团队在开发 Angular2 时实现的一个独立的库。Angular2 框架直接依赖 Zone.js 来实现变更检查。</p><p>Zone.js 实际上是一个异步操作的执行上下文，它为一组异步操作提供了一个统一的运行环境，并且为这一组异步过程的生命周期提供了钩子方法，方便在异步事件进行的不同阶段执行一些任务。关于 Zone.js 的详细介绍，可以阅读<a href="https://www.cnblogs.com/whitewolf/p/zone-js.html">这篇</a>文章。</p><h3 id="补丁是如何工作的"><a href="#补丁是如何工作的" class="headerlink" title="补丁是如何工作的"></a>补丁是如何工作的</h3><p>为了探究 Zone.js 是如何帮助 Angular2 及时发现数据变化这个问题，首先我们深入源码看下，Zone.js 是如何为浏览器打补丁的。</p><blockquote><p>源码为 Zone.js v0.6.0 版本</p></blockquote><p>举一个例子，<code>addEventListener</code> 是浏览器提供的用于监听事件的 API，在 Angular 启动的时候将它替换成了一个新的版本，在 <code>zone.js</code> 文件中可以看到这样的代码：</p><p>Zone.js patchEventTargetMethods</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchEventTargetMethods</span>(<span class="params">obj, addFnName, removeFnName, metaCreator</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (addFnName === <span class="keyword">void</span> <span class="number">0</span>) &#123; addFnName = ADD_EVENT_LISTENER; &#125;</span><br><span class="line">    <span class="keyword">if</span> (removeFnName === <span class="keyword">void</span> <span class="number">0</span>) &#123; removeFnName = REMOVE_EVENT_LISTENER; &#125;</span><br><span class="line">    <span class="keyword">if</span> (metaCreator === <span class="keyword">void</span> <span class="number">0</span>) &#123; metaCreator = defaultListenerMetaCreator; &#125;</span><br><span class="line">    <span class="keyword">if</span> (obj &amp;&amp; obj[addFnName]) &#123;</span><br><span class="line">        <span class="comment">// 在这里将 addEventListener 和 removeEventListener 分别替换为 makeZoneAwareAddListener 和 makeZoneAwareRemoveListener</span></span><br><span class="line">        patchMethod(obj, addFnName, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> makeZoneAwareAddListener(addFnName, removeFnName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, metaCreator); &#125;);</span><br><span class="line">        patchMethod(obj, removeFnName, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> makeZoneAwareRemoveListener(removeFnName, <span class="literal">true</span>, metaCreator); &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Zone.js 通过在 patchEventTargetMethods 方法中代理了两个事件监听 API。在 patchMethod 方法中，现将原来的 addEventListener 方法保存在 <code>__zone_symbol__addEventListener</code> 属性中，并将 <code>addEventListener</code> 替换为 <code>makeZoneAwareAddListener</code> 方法返回的 <code>zoneAwareAddListener</code> 方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchMethod</span>(<span class="params">target, name, patchFn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> proto = target;</span><br><span class="line">    <span class="comment">// 省略了一些代码</span></span><br><span class="line">    (...)</span><br><span class="line">    <span class="comment">// 获取带前缀的方法名</span></span><br><span class="line">    <span class="keyword">var</span> delegateName = zoneSymbol(name);</span><br><span class="line">    <span class="keyword">var</span> delegate;</span><br><span class="line">    <span class="comment">// 检查是否已经 patch 过</span></span><br><span class="line">    <span class="keyword">if</span> (proto &amp;&amp; !(delegate = proto[delegateName])) &#123;</span><br><span class="line">        delegate = proto[delegateName] = proto[name];</span><br><span class="line">        <span class="comment">// 获取代理方法</span></span><br><span class="line">        <span class="keyword">var</span> patchDelegate_1 = patchFn(delegate, delegateName, name);</span><br><span class="line">        <span class="comment">// 将代理方法赋给对象的 addEventListener 属性</span></span><br><span class="line">        proto[name] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> patchDelegate_1(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 将原来的方法实现作为属性添加到 proto[name] 上面</span></span><br><span class="line">        attachOriginToPatched(proto[name], delegate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回原方法</span></span><br><span class="line">    <span class="keyword">return</span> delegate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来看下 <code>makeZoneAwareAddListener</code> 方法都做了些什么</p><p>Zone.js makeZoneAwareAddListener</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeZoneAwareAddListener</span>(<span class="params">addFnName, removeFnName, useCapturingParam, allowDuplicates, isPrepend, metaCreator</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 省略了一些代码</span></span><br><span class="line">    (...)</span><br><span class="line">    <span class="comment">// 调度事件的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">scheduleEventListener</span>(<span class="params">eventTask</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> meta = eventTask.data;</span><br><span class="line">        attachRegisteredEvent(meta.target, eventTask, isPrepend);</span><br><span class="line">        <span class="keyword">return</span> meta.invokeAddFunc(addFnSymbol, eventTask);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取消事件监听的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">cancelEventListener</span>(<span class="params">eventTask</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> meta = eventTask.data;</span><br><span class="line">        findExistingRegisteredTask(meta.target, eventTask.invoke, meta.eventName, meta.useCapturing, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> meta.invokeRemoveFunc(removeFnSymbol, eventTask);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// self 是被监听的对象， args 是监听的事件，包括事件名称和 callback</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">zoneAwareAddListener</span>(<span class="params">self, args</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 根据事件的名称和回调方法创建封装 ZoneTask 的 data 对象</span></span><br><span class="line">        <span class="keyword">var</span> data = metaCreator(self, args);</span><br><span class="line">        <span class="comment">// 省略了一些代码</span></span><br><span class="line">        (...)</span><br><span class="line">        <span class="comment">// 获取当前的 Zone</span></span><br><span class="line">        <span class="keyword">var</span> zone = Zone.current;</span><br><span class="line">        <span class="keyword">var</span> source = data.target.constructor[<span class="string">&#x27;name&#x27;</span>] + <span class="string">&#x27;.&#x27;</span> + addFnName + <span class="string">&#x27;:&#x27;</span> + data.eventName;</span><br><span class="line">        <span class="comment">// 创建 ZoneTask 并开始调度这个 Task</span></span><br><span class="line">        zone.scheduleEventTask(source, delegate, data, scheduleEventListener, cancelEventListener);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法返回的 <code>zoneAwareAddListener</code> 方法中我们会看到这一句代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zone.scheduleEventTask(source, delegate, data, scheduleEventListener, cancelEventListener)</span><br></pre></td></tr></table></figure><p>它会创建 ZoneTask 并调用 <code>scheduleEventListener</code> 方法。这个方法中又调用了 <code>invokeAddFunc</code> 方法，方法中有如下的语句：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.target[addFnSymbol](<span class="built_in">this</span>.eventName, delegate.invoke, <span class="built_in">this</span>.useCapturing);</span><br></pre></td></tr></table></figure><p>target 是被监听的对象，target[addFnSymbol] 是浏览器提供的原始的 addEventListener 方法，在这里，Zone.js 才真正地将 Task 的 invoke 方法与事件绑定在一起。当事件被触发时候，便会调用 Task.invoke 在 invoke 中响应事件执行操作。</p><p>当事件发生的时候，就会直接调用 invoke 方法来执行用户提供的 callback 以及其他的操作。</p><p>至此也就完成了给 <code>addEventListener</code> 打补丁的工作，Zone.js 在加载的时候便会为浏览器上几乎全部的异步 api 打补丁，流程如下图所示：</p><p><img src="http://www.plantuml.com/plantuml/png/PLDDRzD04BtxL-pHaG9H3tmKBgrQAYg84bMLGDpMpYJTThqsk-DMkL49gKafAeU2K458HQ8S-0Yb4ZGV4dyctePJ_WA37I0kFksyUM_sxSnupY3N60VIGO4Is8DGmULrmwHGm6PchrwvD3Dx_PgJiXnHTt_dMTBfZawExDSZ-xezUliXQRrA-hq2mpLGp6s2AJYClXiPdfQycI4HHt-DLNKO29F7K0IWNGDOyYLmpLOf3cCiicM5e3Uvf5CGG4rmX49EEQz4m564Qhwwp5mD3sCmL8Kh7-I_v9BcmGKXbw2n596PYFYXgWiTv0Ym2GfNkMu0vd2IH2HjBeBnjOWmr4Ms1Pu9_GqWnw6gPWG19gTRaDmOvfPZJ2rLF4Cl0rsy1zuTWV_1IqB22l0QwBplYhSEFh8Qr6b6awkQfLn8DwUAag-16bQY5rIs_jYQyitiYwuzVJuUxANqOV-TFUZOlUsVEq-JpuV3RZivUMCVlHyFMbcXsWANqkF-ndZG_Yiwwu-Ej-tBZjtTpUXsVt_quylvn-FXsQVpmySixMqZrjoZ1RC7NTjwnb37-GNGq126HdrBGa1jdqxTBz-zZHYjPADDC-vKlnShPJRiFHdslnKlK2UBIkq3QO2vAfnivkZxQRBJ8rZLH9sMEumSPuu2-Wz-0G00" alt="Zone.js line 1965-1987|center" title="Zone.js line 1965-1987"></p><p>经过以上的探究，我们发现 Zone 为异步事件的处理提供了代理方法，在所有的异步事件被触发的时候都会先经过 Zone 的代理方法，这样一来，凡是在 Zone 内执行的异步事件的执行过程都在 Zone 的掌控之下，Zone 也就可以知道这一组异步事件在什么时候执行完成。而数据的变化是且仅可能是由于异步事件而产生的，那么 Angular 也就可以通过监听 Zone 的生命周期事件来得知什么时候应该进行变更检查了。</p><h3 id="Angular2-中-Zone-的应用"><a href="#Angular2-中-Zone-的应用" class="headerlink" title="Angular2 中 Zone 的应用"></a>Angular2 中 Zone 的应用</h3><h4 id="自动检查数据变化"><a href="#自动检查数据变化" class="headerlink" title="自动检查数据变化"></a>自动检查数据变化</h4><p>在 ng_zone.js 中可以看到：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NgZone.prototype.onEnter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>._nesting++;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._isStable) &#123;</span><br><span class="line">        <span class="built_in">this</span>._isStable = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>._onUnstable.emit(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NgZone.prototype.onLeave = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>._nesting--;</span><br><span class="line">    <span class="built_in">this</span>.checkStable();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NgZone.prototype.setHasMicrotask = <span class="function"><span class="keyword">function</span> (<span class="params">hasMicrotasks</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>._hasPendingMicrotasks = hasMicrotasks;</span><br><span class="line">    <span class="built_in">this</span>.checkStable();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NgZone.prototype.setHasMacrotask = <span class="function"><span class="keyword">function</span> (<span class="params">hasMacrotasks</span>) </span>&#123; <span class="built_in">this</span>._hasPendingMacrotasks = hasMacrotasks; &#125;;</span><br><span class="line"></span><br><span class="line">NgZone.prototype.triggerError = <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123; <span class="built_in">this</span>._onErrorEvents.emit(error); &#125;;</span><br></pre></td></tr></table></figure><p>Zone.js 暴露了一个 Zone 对象 生命周期中各阶段的钩子方法。这里列出了Angular2 所监听的事件，这些方法都会在 Zone 的各个生命周期钩子中被调用。当 NgZone run 之后，Angular 便会实例化一个叫做 <code>ApplicationRef</code> 的类，关键代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只写出了关键的步骤</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationRef</span> </span>&#123;</span><br><span class="line">    _views:<span class="built_in">Array</span> = [];</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">private zone: NgZone</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.zone.onMicrotaskEmpty.subscribe(<span class="function">() =&gt;</span> <span class="built_in">this</span>.zone.run(<span class="function">() =&gt;</span> <span class="built_in">this</span>.tick());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">tick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._runningTick = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>._views.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">view</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span>  view.ref.detectChanges();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onMicrotaskEmpty</code> 事件会在当前 Zone 中的异步过程都已经完成的时候触发，当监听到这个事件后就去遍历 View 并且调用每个 view 的 <code>detectChanges</code> 方法来进行变更检查。</p><p>基于以上原理，在 Angular2 中我们只要使用标准的浏览器 API 发起异步过程就可以在合适的时机触发变更检查。这避免了像 Angular1.x 中那样需要调用框架提供的方法来触发 <code>$digest</code> 的问题，与此同时也移除了开发者对 <code>$scope</code> 对象的感知。</p><h4 id="可选的变更检查"><a href="#可选的变更检查" class="headerlink" title="可选的变更检查"></a>可选的变更检查</h4><p>并不是所有的异步操作都有必要触发变更检查，比如我们点了一下鼠标，但这个动作并不会引发数据变化，这时我们是不希望变更检查被触发的。由于 Angular2 应用运行在 NgZone 之中，所有在 NgZone 之中的异步操作都会通知框架进行变更检查。针对这个情况，NgZone 提供了一个 <code>runOutsideAngular</code> 方法，只要让我们的方法在 NgZone 之外运行，就不会触发 Angular2 的变更检查了。</p><p><a href="http://plnkr.co/edit/j9W2op4lGezi8eexwHg6?p=preview">这里</a>的代码演示了这个特性。</p><p>当代码不在 NgZone 中运行的时候，异步事件是不会触发变更检查的，所以即使数值更新了，但是界面的显示仍然不变。</p><h2 id="Angular2-x-变更检查工作原理"><a href="#Angular2-x-变更检查工作原理" class="headerlink" title="Angular2.x 变更检查工作原理"></a>Angular2.x 变更检查工作原理</h2><p>上面的的内容解释了 Angular2 的变更检查机制是如何被触发的，那么 Angular2 的变更检查机制是如何检查变更的呢？</p><blockquote><p>以下内容基于 Angular2.4.9</p></blockquote><h3 id="Angular-的默认变更检查如何工作"><a href="#Angular-的默认变更检查如何工作" class="headerlink" title="Angular 的默认变更检查如何工作"></a>Angular 的默认变更检查如何工作</h3><p>非 AOT 模式下 Angular2 将在运行时利用 JIT 机制创建组件的包装类，框架将会为每个组件生成相应的包装类，也就是说，对于每一个组件来讲，Angular 会为其生成至少两个类型 <code>View_ClassName_App</code> 和 <code>Wrapper_ClassName_App</code>，根组件还会生成一个 <code>View_ClassNameApp_Host</code>。 作为应用组件的入口，变更检查也是从这个地方开始的。</p><p><code>View_ClassName_App</code> 类主要做了下面5件事：</p><ol><li>注入依赖</li><li>创建组件中的 DOM 元素渲染页面</li><li>响应绑定的事件</li><li>利用变更检查器执行变更检查</li><li>提供 debug 信息</li></ol><p><code>Wrapper_ClassName_App</code> 类主要是提供了组件的生命周期钩子。</p><p>一个Angular2的应用是由组件组成的树，每个组件又有自己的变更检查器，于是变更检查器们也组成了一颗变更检查器树。无论当哪一个组件的变更检查被触发时 Angular2 都 会采用深度优先遍历的方式从根节点遍历整个变更检查器树，每个组件中都会包含一个类型为 <code>changeDetectorRef</code> 的变更检查器，在 JIT 模式下，这些变更检查器会被编译成为 <code>View_ClassName_App</code> 中的<br><code>detectChangesInternal</code> 方法，在这个方法中组件会对自己内部的数据绑定进行检查，调用自己的 ngOnChanges 生命周期方法，如果有子组件的话还会调用子组件的 <code>internalDetectChanges</code> 方法，将检查沿着树枝的方向进行下去，如下图所示：</p><p><img src="/2017/07/04/Front_End/Angular/AngularChangeDetection/0f1b30a7-328a-4b05-a3a3-c96876583ba7.png" alt="Alt text | center"></p><p>这个树也可以描述 Angular2 中组件的数据流，数据之所以是从上到下流动的，原因是变更检查也是从上到下的，每时每刻，每个组件中数据都是按照这个方向流动，这与 Angular1.x 不同，Angular2 的单向数据流让程序的行为更加可预测。</p><p><img src="/2017/07/04/Front_End/Angular/AngularChangeDetection/af797871-3441-448c-9bce-ac7555dac8b3.png" alt="Alt text|center"></p><p>在上图中我们可以看到，当我们往文本框中输入文字的时候，马上就会触发组件的变更检查，这时调用了 <code>View_InventoryApp0.detectChangesInternal</code> 方法，在方法中找到设置文本框内容的代码如下：<br><img src="/2017/07/04/Front_End/Angular/AngularChangeDetection/8b848add-a3f4-423a-a544-ad81f24caa34.png" alt="Alt text|center"><br>这时会比较新旧两个值是否相同，<code>jit_checkBinding25</code> 方法是框架编译生成的方法，在运行时找到实际上调用的是 <code>view_utils.checkBinding</code> 方法：<br><img src="/2017/07/04/Front_End/Angular/AngularChangeDetection/96ae32a0-a570-432f-addc-9a91d1ff5d4c.png" alt="Alt text|center"><br><code>throwOnChange</code> 的值是 false，所以这里会使用 <code>looseIdentical</code> 来进行新旧值的比较。这个方法存在于 <code>lang.js</code> 中实现如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">looseIdentical</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a === b || <span class="keyword">typeof</span> a === <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> b === <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="built_in">isNaN</span>(a) &amp;&amp; <span class="built_in">isNaN</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只是简单比较了引用或者值是否相同，并没有做深度比较。所以数组或者对象等集合类型内部的值发生变化，Angular 并不能检查到。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (jit_checkBinding24(throwOnChange,self._expr_32,currVal_32)) &#123;</span><br><span class="line">    self.renderer.setText(self._text_5,currVal_32);</span><br><span class="line">    self._expr_32 = currVal_32;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的图中我们还看到了这样的代码，Angular 在检查变更之后立即更新了视图。</p><p><img src="/2017/07/04/Front_End/Angular/AngularChangeDetection/dc3e2fbc-5699-4286-b7d0-e57bf3202252.png" alt="Alt text|center"><br>然后当当前组件所有的变更检查执行完成之后，开始检查子组件的变更，然后变更检查器会按照深度优先的规则遍历整个组件树，直到所有节点的变更检查都完成为止。</p><p>由于单向数据流的原因，变更检查只需要执行一遍就可以稳定下来，如果在第一次检查中产生副作用使得已经检查过的节点发生了变化，Angular 会抛出异常。</p><h3 id="OnPush-模式"><a href="#OnPush-模式" class="headerlink" title="OnPush 模式"></a>OnPush 模式</h3><p>在 Default 模式下，每一组异步操作结束之后都会触发对整个组件树的变更检查，在一些场景下，某些组件是不需要每次都被检查的，可以将它们标记为不可变对象，不可变对象给我们提供的保障是对象不会改变，即当其内部的属性发生变化时，我们将会用新的对象来替代旧的对象。它仅仅依赖初始化时的属性，也就是初始化时候属性没有改变（没有改变即没有产生一份新的引用），Angular将跳过对该组件的全部变化监测，直到有属性的引用发生变化为止。如果需要在Angular2中使用不可变对象，我们需要做的就是设置 <code>changeDetection: ChangeDetectionStrategy.OnPush</code>（如下所示） 启用 OnPush 模式来避免不必要的变更检查以提升程序的性能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  changeDetection: ChangeDetectionStrategy.OnPush</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">InventoryApp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一个<a href="https://plnkr.co/edit/zGNlvnYsPSKbQPv7HxX3?p=preview">例子</a></p><p><img src="/2017/07/04/Front_End/Angular/AngularChangeDetection/4777abca-770b-4d8e-88e2-0813c46f813a.png" alt="Alt text|center"><br>黄色部分是父组件，灰色的部分是子组件，子组件开启了 OnPush 模式。当我们点击黄色部分的时候，虽然改变了 <code>this.person.name</code> 的值，但是这个变化并不能被框架检测到，也就不能反映在视图上。使用了 OnPush 模式的组件，它的变更检查器将会被关闭，它与它的子节点都无法再检查到父组件带来的变更。</p><p>要注意的是，由节点内部产生的变化依然会触发变更检查，还看上面的例子：<br><img src="/2017/07/04/Front_End/Angular/AngularChangeDetection/513fce5b-d017-48e1-acbc-55aad52d5532.png" alt="Alt text|center"><br>点击灰色的部分，也就是被设置为 OnPush 模式的子组件，这时触发了子组件中的 onclick 方法，改变了 <code>this.person.name</code> 的值，由于这个变更是由子组件内部事件导致的，这时将会触发变更检查，视图上的文字也会被更新。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后来总结一下 Angular 变更检查的整个过程</p><ol><li>Zone.js 为浏览器 API 打补丁</li><li>NgZone 初始化，监听当前 Zone 中的异步事件执行是否完成</li><li>异步事件执行结束后出发 tick 方法开始变更检查</li><li>变更检查由根组件开始按照深度优先遍历变更检查器树</li><li>在每个数据绑定的检查结束之后，立即更新视图</li><li>在继续检查子组件直到所有组件检查完成</li></ol><p><img src="http://www.plantuml.com/plantuml/png/FP3BJi9G48RtvodEKZS-G5a8qOqRuzfTWoUbMeifXxW5WwGDnK8QcoeXG4of6xp4ModLf-aCzItiHTtC9VFz_qoctE2Ynfkd2k4oLvXGKQMc8cfqfoQg4gExZBCgb-igoJaY7DPLjdNSe74GufkL-3hStDFAmHv5mqvcNXoqIqJObpACWZu6lmUcKo8QEsCY_qtql2OhZ6x0fmr6d-Pi72pMjns8Bd3XnM4lNhsZuISp4zr76CpXmKHziBr9XCIVWpMaNAwUK7IM-78DKIlROhauUiMx5awyz8AYmEbolUgaNfbr3cIZ57EU4hyBew-i_NY6S1v7Bbpgt-q-N7KB2Kw7XSc_y6zgutXI8amz8kKqfA_x0G00" alt="changeDetect@1-14|center" title="changeDetect@1-14"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.thoughtram.io/angular/2016/01/22/understanding-zones.html#creating-forking-and-extending-zones">Understanding Zones</a><br><a href="https://blog.thoughtram.io/angular/2016/02/22/angular-2-change-detection-explained.html#whats-change-detection-anyways">ANGULAR CHANGE DETECTION EXPLAINED</a><br><a href="https://www.cnblogs.com/whitewolf/p/zone-js.html">Zone.js - 暴力之美</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setImmediate">setImmediate</a><br><a href="https://github.com/angular/zone.js/blob/master/dist/zone.js.d.ts">Zone.js API</a><br><a href="https://juejin.im/entry/58636f198d6d81006500ae27">Angular 2 中的编译器与预编译（AoT）优化</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相比 Angular1 而言 Angular2 的变更检查机制更加透明，更加可预测。但是在使用 Angular2 开发的过程中依然存在着一些场景（比如性能优化）需要我们更深入的了解在框架的底层究竟发生了什么。&lt;/p&gt;
&lt;p&gt;本文包含如下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变化产生于异步操作&lt;/li&gt;
&lt;li&gt;为浏览器打补丁&lt;ul&gt;
&lt;li&gt;Zone.js&lt;/li&gt;
&lt;li&gt;补丁是如何工作的&lt;/li&gt;
&lt;li&gt;Angular2 中 Zone 的应用&lt;ul&gt;
&lt;li&gt;自动检查数据变化&lt;/li&gt;
&lt;li&gt;可选的变更检查&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Angular2.x 变更检查工作原理&lt;ul&gt;
&lt;li&gt;Angular 的默认变更检查如何工作&lt;/li&gt;
&lt;li&gt;OnPush 模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;总结&lt;/li&gt;
&lt;li&gt;参考资料&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;本文的描述基于 Angular 2.4.9 版本&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="Angular" scheme="https://ufolux.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>使用RxJS来构建响应式应用</title>
    <link href="https://ufolux.github.io/2017/03/03/Front_End/vendor/UseRxToBuildRactiveApp/"/>
    <id>https://ufolux.github.io/2017/03/03/Front_End/vendor/UseRxToBuildRactiveApp/</id>
    <published>2017-03-03T06:51:07.000Z</published>
    <updated>2021-03-11T07:20:00.098Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>RxJS is the Reactive-Extensions（ReactiveX） for JS</p><p>ReactiveX 由微软发起并推动，是一个为用于实现异步和基于事件编程的程序库制定的一个标准，RxJS 是对这个标准的 Javascript 实现。</p><p>RP（Reactive Programming）响应式编程的思路是把随时间不断变化的数据、状态、事件等等转成可被观察的序列(Observable Sequence)，然后订阅序列中那些Observable对象的变化，一旦变化，就会执行事先安排好的各种转换和操作。</p><hr><p><img src="/2017/03/03/Front_End/vendor/UseRxToBuildRactiveApp/819744a3-a77d-4a9b-b307-d837ef4aae41.png" alt="ReactiveX"></p><hr><span id="more"></span><blockquote><p>OC 实现的 RAC（ReactiveCocoa） 与 RxJS 执行了两个不同的标准，RAC 遵循的 RP 标准与 Rx 在概念上有一些不同（特别体现在冷热信号上）。</p></blockquote><hr><h2 id="RxJS-提供了什么"><a href="#RxJS-提供了什么" class="headerlink" title="RxJS 提供了什么"></a>RxJS 提供了什么</h2><ol><li>事件管理、调度引擎</li><li>十分丰富的操作符</li><li>流式的数据处理方法</li><li>声明式的编程风格</li></ol><hr><h2 id="重要的概念"><a href="#重要的概念" class="headerlink" title="重要的概念"></a>重要的概念</h2><hr><h3 id="Observable-（信号源）"><a href="#Observable-（信号源）" class="headerlink" title="Observable （信号源）"></a>Observable （信号源）</h3><p><img src="/2017/03/03/Front_End/vendor/UseRxToBuildRactiveApp/1d4bddae-83eb-4276-aa74-e73f65ecf7b7.png" alt="Observable"></p><p>emit 向流（stream）上发射对象（信号）</p><hr><h3 id="Observer-Subscriber-reactor-iterator"><a href="#Observer-Subscriber-reactor-iterator" class="headerlink" title="Observer(Subscriber, reactor,iterator)"></a>Observer(Subscriber, reactor,iterator)</h3><p>Observer 在信号流中是一个观察者（哨兵）的角色，它负责观察任务执行的状态并向流中发射信号</p><h4 id="onNext"><a href="#onNext" class="headerlink" title="onNext"></a>onNext</h4><p>向流中发射一个正常的信号。</p><h4 id="onError"><a href="#onError" class="headerlink" title="onError"></a>onError</h4><p>向流中发射一个错误信号，并终止 Observable 的信号发射。</p><h4 id="onCompleted"><a href="#onCompleted" class="headerlink" title="onCompleted"></a>onCompleted</h4><p>向流中发射一个完成信号，并终止 Observable 的信号发射。</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let responseStream &#x3D; Rx.Observable.create((observer) &#x3D;&gt; &#123;</span><br><span class="line">        fetch(reqUrl).then((data) &#x3D;&gt; &#123;</span><br><span class="line">            observer.onNext(data);</span><br><span class="line">            observer.onCompleted(&#39;completed&#39;);</span><br><span class="line">        &#125;, (err) &#x3D;&gt; &#123;</span><br><span class="line">            observer.onError(err);</span><br><span class="line">        &#125;)</span><br><span class="line">responseStream.subscribe((data)&#x3D;&gt;&#123;...&#125;,</span><br><span class="line"> (err)&#x3D;&gt;&#123;...&#125;,</span><br><span class="line"> (completed)&#x3D;&gt;&#123;...&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="Operators-（操作符）"><a href="#Operators-（操作符）" class="headerlink" title="Operators （操作符）"></a>Operators （操作符）</h3><p>链式的操作符构成了一个容纳信号（数据）流的管道，操作会按照操作符的排列顺序有序执行，RxJS 提供了60多个内置操作符，足以应付数据流处理的绝大部分需求。更为灵活的是，我们还可以在 RxJS 上自定义操作符。</p><hr><ol><li>create 创建 Observable<br>立即创建一个 Observable 对象或者在订阅时才创建 Observable 对象（Lazy load）<br>create</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个 Observable</span><br><span class="line">Rx.Observable.create((observer)&#x3D;&gt;&#123;observer.onNext()&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个空的 Observable</span><br><span class="line">Rx.Observable.empty();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从 Interval 创建</span><br><span class="line">Rx.Observable.interval(100);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从 promise 创建</span><br><span class="line">Rx.Observable.fromPromise(fetch(url));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从数组创建</span><br><span class="line">Rx.Observable.fromArray(array)</span><br></pre></td></tr></table></figure><hr><ol start="2"><li>subscribe/connect Observable<br>只有当 Observable 被订阅或者 connect 后，Observable 才会发射信号。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 订阅事件</span><br><span class="line">let source &#x3D; Rx.Observable.interval(100);</span><br><span class="line">source.subscribe((event)&#x3D;&gt;&#123;</span><br><span class="line">&#x2F;&#x2F; do something</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; connect 事件</span><br><span class="line">let source &#x3D; Rx.Observable.interval(100).publish();</span><br><span class="line">source.connect().subscribe((event)&#x3D;&gt;&#123;</span><br><span class="line">&#x2F;&#x2F; do something</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><ol start="3"><li>transform 变换 Observable 的形式<br>eg: map, pluck, flatmap, publish</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var source &#x3D; Rx.Observable</span><br><span class="line">    .from([</span><br><span class="line">        &#123; value: &#123;index: 0&#125; &#125;,</span><br><span class="line">        &#123; value: &#123;index: 1&#125; &#125;,</span><br><span class="line">        &#123; value: &#123;index: 2&#125; &#125;</span><br><span class="line">    ])</span><br><span class="line">    .pluck(&#39;value&#39;)</span><br><span class="line">    .map(value&#x3D;&gt;&#123;</span><br><span class="line">    return value.index;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(index&#x3D;&gt;&#123;</span><br><span class="line">    console.log(index) &#x2F;&#x2F; Output 0,1,2</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><hr><ol start="4"><li>filter 对 Observable 发射出的对象进行过滤并将对象向管道的后方传递<br><img src="/2017/03/03/Front_End/vendor/UseRxToBuildRactiveApp/3cfa842b-0980-4e1f-86be-250709cfb245.png" alt="filter"><br>eg: debounce, filter, first,</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; filter</span><br><span class="line">var source &#x3D; Rx.Observable</span><br><span class="line">    .from([</span><br><span class="line">        &#123; value: 0 &#125;,</span><br><span class="line">        &#123; value: 1 &#125;,</span><br><span class="line">        &#123; value: 2 &#125;</span><br><span class="line">    ])</span><br><span class="line">    .filter(data&#x3D;&gt;&#123;</span><br><span class="line">    return data.value &gt; 1;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(obj&#x3D;&gt;&#123;</span><br><span class="line">    console.log(obj) &#x2F;&#x2F; Output &#123; value: 2 &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><ol start="5"><li>combine 将多个 Observable 组合成一个 Observalbe<br><img src="/2017/03/03/Front_End/vendor/UseRxToBuildRactiveApp/5dfa656d-ce41-4127-bfd9-7c6a95b2b294.png" alt="Combine"><br>eg: merge, combineLatest, join, switch</li></ol><hr><p>多个请求并发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let responseStream1 &#x3D; Rx.Observable.fromPromise(fetch(reqUrl1));</span><br><span class="line">let responseStream2 &#x3D; Rx.Observable.fromPromise(fetch(reqUrl2));</span><br><span class="line">Rx.Observable</span><br><span class="line">    .combineLatest(responseStream1, responseStream2)</span><br><span class="line">    .subscribe((tuple) &#x3D;&gt; &#123;</span><br><span class="line">        let data1 &#x3D; tuple[0];</span><br><span class="line">        let data2 &#x3D; tuple[1];</span><br><span class="line">    &#125;, (err) &#x3D;&gt; &#123;... &#125;, (completed) &#x3D;&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; or</span><br><span class="line">Rx.Observable</span><br><span class="line">    .combineLatest(responseStream1, responseStream2, (data1, data2) &#x3D;&gt; &#123;</span><br><span class="line">        return processData(data1, data2);</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe((result) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F;do something</span><br><span class="line">    &#125;, (err) &#x3D;&gt; &#123;... &#125;, (completed) &#x3D;&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure><hr><ol start="6"><li>utilities and the other 工具运算符以及其他运算符</li></ol><blockquote><p>参见 <a href="http://reactivex.io/documentation/operators.html">ReactiveX 核心操作符</a></p></blockquote><hr><h3 id="Scheduler-（调度器）"><a href="#Scheduler-（调度器）" class="headerlink" title="Scheduler （调度器）"></a>Scheduler （调度器）</h3><p>可以单独调度某个操作以实现更复杂的异步编程，可以实现让某个操作运行在特定的一个事件循环中。</p><blockquote><p>参见 <a href="http://reactivex.io/documentation/scheduler.html">Scheduler</a></p></blockquote><hr><h3 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h3><p><img src="/2017/03/03/Front_End/vendor/UseRxToBuildRactiveApp/041424ca-db06-4f58-9f65-84d5acd44964.png" alt="Alt text"><br>它是一个代理对象，既是一个 Observable 又是一个 Observer，它可以同时接受 Observable 发射出的数据，也可以向订阅了它的 observer 发射数据。ReaciveX 标准中有四种 Subject</p><blockquote><p>参见 <a href="http://reactivex.io/documentation/subject.html">Subject</a></p></blockquote><hr><h3 id="Cold-Hot-Connectable-Observable"><a href="#Cold-Hot-Connectable-Observable" class="headerlink" title="Cold/Hot/Connectable Observable"></a>Cold/Hot/Connectable Observable</h3><hr><h4 id="Cold-Observable："><a href="#Cold-Observable：" class="headerlink" title="Cold Observable："></a>Cold Observable：</h4><p>这种 Observable 创建之后并不会马上开始向事件流中发射对象，只有当它的 subscribe 方法被调用之后，它才会开始向外发送信号，</p><hr><p>以下代码创建了一个 Cold Observable，这时即使 <code>keyup</code> 事件被触发，这个 Observable 对象也不会发出任何信号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; inputValueStream is a cold Observable</span><br><span class="line">let inputValueStream &#x3D; Rx.Observable.fromEvent(input, &#39;keyup&#39;)</span><br><span class="line">    .pluck(&#39;target&#39;, &#39;value&#39;);</span><br></pre></td></tr></table></figure><p>在调用 subscribe 方法之后这个 Observable 才会被真正触发，这时触发 keyup 事件，input 中的 value 将会被发射到流中进而被后续的操作符处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inputValueStream</span><br><span class="line">.subscribe(data &#x3D;&gt; text.textContent &#x3D; data,</span><br><span class="line">           err&#x3D;&gt;&#123;&#125;,</span><br><span class="line">           complete&#x3D;&gt;&#123;&#125;);</span><br></pre></td></tr></table></figure><p>Rx 规范中通过创建 Observable 操作符创建出来的对象都是冷信号。</p><hr><h4 id="Hot-Connectable-Observable"><a href="#Hot-Connectable-Observable" class="headerlink" title="Hot/Connectable Observable"></a>Hot/Connectable Observable</h4><p>和 Cold Observable 相反，Hot Observable 在创建出来的那一刻就已经开始向流中发射信号，而 Connectable Observable 在创建时候并不会发射信号，直到 <code>connect</code> 方法被调用。</p><hr><p>在 RxJS 中创建这两种 Observable 的方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Hot and Connectable Observable</span><br><span class="line">let input5 &#x3D; document.querySelector(&#39;#i5&#39;);</span><br><span class="line">let p5 &#x3D; document.querySelector(&#39;#p5&#39;);</span><br><span class="line">let input5Stream &#x3D; Rx.Observable.fromEvent(input5, &#39;keyup&#39;)</span><br><span class="line">    .pluck(&#39;target&#39;, &#39;value&#39;)</span><br><span class="line">    .map(data &#x3D;&gt; &#123;</span><br><span class="line">        console.log(data);</span><br><span class="line">        return data;</span><br><span class="line">    &#125;)</span><br><span class="line">    .publish();&#x2F;&#x2F;调用 publish 之后 input5Stream 是一个 Connectable Observable</span><br><span class="line">    input5Stream.connect();&#x2F;&#x2F; 在调用 connect 方法之后，input5Stream 成为了 Hot Observable</span><br><span class="line">window.setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    input5Stream.subscribe(data &#x3D;&gt; &#123;</span><br><span class="line">        p5.textContent &#x3D; data</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, 3000);</span><br></pre></td></tr></table></figure><hr><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><hr><ol><li>可以多次发射信号</li></ol><hr><ol start="2"><li>信号流可以被取消</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Cancel a RxJS Observable</span><br><span class="line">const subscription &#x3D; Rx.Observable.create((observer) &#x3D;&gt; &#123;</span><br><span class="line">    let counter &#x3D; 0;</span><br><span class="line">    setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">        counter++;</span><br><span class="line">        if (counter &gt; 10) &#123;</span><br><span class="line">            observer.onCompleted();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            observer.onNext(counter);&#x2F;&#x2F;can be called many times</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, 500);</span><br><span class="line">&#125;).subscribe(counter &#x3D;&gt; p2.textContent &#x3D; counter,</span><br><span class="line">    (err) &#x3D;&gt; &#123;&#125;,</span><br><span class="line">    (completed) &#x3D;&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">Rx.Observable.fromEvent(stopBtn, &#39;click&#39;)</span><br><span class="line">    .subscribe((event) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; cancel Observable</span><br><span class="line">        subscription.dispose();&#x2F;&#x2F; AutoDetachObserver-&gt;AbstractObserver-&gt;Observer</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><hr><ol start="3"><li>提供了极其丰富的操作符来对异步数据流进行操作</li><li>可以精确控制事件的进行过程</li></ol><ul><li>可以在需要的时候才触发过程的执行和信号的发射</li><li>可以在执行失败的时候重试等等</li></ul><ol start="5"><li>有序的流式操作符合人类的思维模式</li><li>提供了很多类似数组方法（<a href="https://www.google.com.tw/url?sa=t&rct=j&q=&esrc=s&source=web&cd=6&ved=0ahUKEwil7JCoh67SAhUIspQKHfJcCOIQFghJMAU&url=https%3a%2f%2fblogs%2emsdn%2emicrosoft%2ecom%2fie%2f2010%2f12%2f13%2fecmascript-5-part-2-array-extras%2f&usg=AFQjCNGT0T6C9tvVNhNo0_P3Ajy1Nu99JA">Array Extras</a>）的操作符，类比数组的方式对信号（数据）流进行处理。</li><li>操作符具有比较清晰的语义（相比 Promise 的 then）</li><li>无任何依赖，可以和多种框架良好的配合</li></ol><hr><h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><ol><li>内容和概念较多，学习成本较高</li><li>链式操作很长，代码提示不好（Rx 很适合在强类型语境下使用）</li><li>需要引入额外的库 （相比原生 Promise）</li></ol><hr><h3 id="与-Promise对比的例子："><a href="#与-Promise对比的例子：" class="headerlink" title="与 Promise对比的例子："></a>与 Promise对比的例子：</h3><p>网络请求的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; example promise net work</span><br><span class="line">let requestPromise &#x3D; function() &#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        requestUrl(url).then(data &#x3D;&gt; resolve(data), err &#x3D;&gt; reject(failed));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">requestPromise().then(data &#x3D;&gt; &#123;</span><br><span class="line">    let temp &#x3D; data.ret_data;</span><br><span class="line">    &#x2F;&#x2F; 过滤数据</span><br><span class="line">    if (temp &amp;&amp; temp.length) &#123;</span><br><span class="line">        &#x2F;&#x2F;处理数据</span><br><span class="line">        let result &#x3D; processRtnData(temp);</span><br><span class="line">        displayData(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, err &#x3D;&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>Promise 实现<br>更关注控制流<br>描述怎么做的命令式编程风格</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; example rxjs net work</span><br><span class="line">Rx.Observable.fromPromise(requestUrl(url))</span><br><span class="line">    .filter(data &#x3D;&gt; data.ret_data &amp;&amp; data.ret_data.length &gt; 0)</span><br><span class="line">    .map(data &#x3D;&gt; processRtnData(data.ret_data))</span><br><span class="line">    .subscribe(data &#x3D;&gt; displayData(data));</span><br></pre></td></tr></table></figure><hr><p>RxJS 实现<br>更关注数据本身的流动，且流动是有序的<br>描述做什么的声明式代码<br>简洁直观，符合人的自然思维</p><hr><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><hr><h3 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h3><ol><li>多个网络请求并发</li><li>取消对进行中的网络请求</li><li>实时搜索的节流功能</li></ol><hr><h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><ol><li>允许在一<br>个过程中多次发出信号（密码框）</li><li>将 UI 事件直接转换为信号进行流式处理</li></ol><hr><h2 id="Angular2-中-Rx-js-的应用"><a href="#Angular2-中-Rx-js-的应用" class="headerlink" title="Angular2 中 Rx.js 的应用;"></a>Angular2 中 Rx.js 的应用;</h2><p>Angular2 在框架级别集成了 RxJS</p><ol><li>facade 模块中的 async.js<br> |EventEmitter 用于为 components 提供自定义事件的支持</li><li>forms 模块</li><li>Http 模块</li></ol><hr><p>参考：<br><a href="http://reactivex.io/">ReactiveX</a><br><a href="https://github.com/Reactive-Extensions/RxJS">RxJS</a><br><a href="http://reactivex.io/documentation/operators.html">ReactiveX 核心操作符</a><br><a href="https://yuyang041060120.github.io/2016/05/16/observable-vs-promise/">Promise vs Observable</a><br><a href="http://www.jianshu.com/p/07266f30ce5f">Subject详解</a><br><a href="http://reactivex.io/documentation/scheduler.html">Scheduler</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;RxJS is the Reactive-Extensions（ReactiveX） for JS&lt;/p&gt;
&lt;p&gt;ReactiveX 由微软发起并推动，是一个为用于实现异步和基于事件编程的程序库制定的一个标准，RxJS 是对这个标准的 Javascript 实现。&lt;/p&gt;
&lt;p&gt;RP（Reactive Programming）响应式编程的思路是把随时间不断变化的数据、状态、事件等等转成可被观察的序列(Observable Sequence)，然后订阅序列中那些Observable对象的变化，一旦变化，就会执行事先安排好的各种转换和操作。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;/2017/03/03/Front_End/vendor/UseRxToBuildRactiveApp/819744a3-a77d-4a9b-b307-d837ef4aae41.png&quot; alt=&quot;ReactiveX&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://ufolux.github.io/tags/javascript/"/>
    
      <category term="库" scheme="https://ufolux.github.io/tags/%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>使用内存缓存需要注意的一个问题</title>
    <link href="https://ufolux.github.io/2017/02/05/Front_End/js-fondation/notice-of-memory-cache/"/>
    <id>https://ufolux.github.io/2017/02/05/Front_End/js-fondation/notice-of-memory-cache/</id>
    <published>2017-02-05T13:38:07.000Z</published>
    <updated>2021-03-11T07:20:00.097Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近做需求的时候遇到一个坑，对这个问题的思考在这里记录一下</p><p>在应用中为了使得数据尽快展示出来，在网络请求的数据回来之前都会先显示内存中缓存的数据。存取缓存的方法大概是这个样子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var setCacheInfo &#x3D; function(key, value) &#123;</span><br><span class="line">    key &amp;&amp; (cacheWebData[key] &#x3D; value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var getCacheInfo &#x3D; function(key) &#123;</span><br><span class="line">    return cacheWebData[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cacheWebData</code> 是一个内存中的对象，读取缓存就是直接反悔了对象中 <code>key</code> 对应的 <code>value</code>。然后将取出来的值进行传递。</p><p>先说下问题的现象，在调试的时候我发现，从内存缓存中取出来的值会莫名其妙的改变。比如：在 A 页面中使用<code>key</code>取到的值是<code>&#123;a:1,b:2&#125;</code>，但是在进入过 B 页面之后同样使用<code>key</code>取到的值却变成了 <code>&#123;a:1,b:2,c:3&#125;</code>，这过程中没有调用<code>setCacheInfo</code>方法来修改缓存中的值。</p><p>难不成他还自己变了？</p><p>这显然是不可能的，查找了好半天，我发现取出这个缓存的值以后，这个值被传递了好几层，最终被 <code>$.extend(obj,&#123;c:1&#125;)</code> 了一次。这一改不要紧，由于传递的是缓存中对象的引用，这下直接将缓存里面的值也修改了，到下次再使用缓存的时候取出来的值就已经不是原来的值了。然而在 extend 的地方，使用者是完全不知道这个对象引用的是什么地方的数据，这里是一个隐患。</p><p>避免出现这个问题有三个办法；</p><ol><li>将 <code>getCacheInfo</code> 方法改为以下的实现</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var getCacheInfo &#x3D; function(key) &#123;</span><br><span class="line">    return $.extend(true, &#123;&#125;, cacheWebData[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是将传出的值进行深拷贝，切断与缓存内部对象的引用关系。<br>2. 模仿 localStorage 的接口，令缓存对象只接受字符串类型的 value，那么读取方法要这样实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var setCacheInfo &#x3D; function(key, value) &#123;</span><br><span class="line">    key &amp;&amp; (cacheWebData[key] &#x3D; JSON.stringify(value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var getCacheInfo &#x3D; function(key) &#123;</span><br><span class="line">    return JSON.parse(cacheWebData[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>直接规定不允许直接 extend 对象…，或者只允许为空对象扩展属性（并不能完全排除隐患）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.extend(&#123;&#125;, obj, &#123;c:3&#125;)</span><br></pre></td></tr></table></figure><p>于是我想看下 jquery，node-cache 之类的框架中是如何处理缓存读写的。<br>jQuery.data 的实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get: function (owner, key) &#123;</span><br><span class="line">    return (key &#x3D;&#x3D;&#x3D; undefined) ? (this.cache (owner)): (owner[this.expando] &amp;&amp; owner[this.expando][jQuery.camelCase (key)]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样存在这个问题。</p><p>node-cache 的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">exports.get &#x3D; function(key) &#123;</span><br><span class="line">  var data &#x3D; cache[key];</span><br><span class="line">  if (typeof data !&#x3D; &quot;undefined&quot;) &#123;</span><br><span class="line">    if (isNaN(data.expire) || data.expire &gt;&#x3D; Date.now()) &#123;</span><br><span class="line">      if (debug) hitCount++;</span><br><span class="line">      return data.value;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; free some space</span><br><span class="line">      if (debug) missCount++;</span><br><span class="line">      size--;</span><br><span class="line">      delete cache[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (debug) &#123;</span><br><span class="line">    missCount++;</span><br><span class="line">  &#125;</span><br><span class="line">  return null;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>蛤，也有这个问题。。</p><p>看来主流框架告诉我们是不应该随意地对对象进行扩展了，不然一不留神就会出现这种问题…想要防患于未然最好还是使用深拷贝或者只存字符串类型值的方法吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="JS" scheme="https://ufolux.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Chrome Dev Tool 编辑本地文件</title>
    <link href="https://ufolux.github.io/2017/01/28/Front_End/wechat-dev/hack-wechat-devtool-to-debug-fileprotocol-page/"/>
    <id>https://ufolux.github.io/2017/01/28/Front_End/wechat-dev/hack-wechat-devtool-to-debug-fileprotocol-page/</id>
    <published>2017-01-28T12:00:30.000Z</published>
    <updated>2021-03-11T07:20:00.102Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们在前端开发中经常需要使用 ChromeDevTool 来进行调试，我想大家经常会遇到这种场景：</p><ul><li>这里有一个字符串写错了，改一下就好了</li><li>这里加个 if 判断保护一下就好了</li><li>这里变量名写错了<br>等等</li></ul><p>在这些情况下我们往往只需要进行很少量的修改就可以修复一个 bug，但是切到编辑其中修复之后，我们又要跑一遍脚本或者在浏览器中打下一串地址（没有 hot-reload 的项目中），如果是混合移动的开发，我们还需要打包到真机上。这就是一个比较耗时的过程。何况当页面加载出来之后我们还要登陆，恢复现场才能调试一个小小的 bug。如果能在浏览器里面直接改动代码，马上恢复现场跑一下不就可以省去很多麻烦，chrome 的这个功能就会帮到你。</p><h3 id="步骤如下"><a href="#步骤如下" class="headerlink" title="步骤如下"></a>步骤如下</h3><ol><li>首先打开 ChromeDevTool，切换到 Sources Tab</li><li>在任意文件上单击右键 Add Folder to Folder，将包含所需要代码文件夹包含到工程中（这时 Chrome 会提示需要获得该文件夹的完全控制权限，这里点击 Allow）</li><li>在任意文件上单击右键，点击 Map to File System Resources</li><li>这时 Chrome 会提示用户重新载入开发者工具，点击 Ok 重新启动开发者工具。</li><li>然后就可以看到目录结构已经变成了我们的本地目录。command+p 搜索文件的时候也可以看到文件的路径变成本地路径了。这时在文件上进行修改，改动就会直接作用于本地的文件。而且修改后的文件可以直接用于调试而无需重新启动应用（浏览器调试和真机调试均是如此）。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="wechat" scheme="https://ufolux.github.io/tags/wechat/"/>
    
  </entry>
  
  <entry>
    <title>yargs处理异常参数的坑</title>
    <link href="https://ufolux.github.io/2017/01/24/Front_End/tools/bull-shit-of-yargs-exception-handler/"/>
    <id>https://ufolux.github.io/2017/01/24/Front_End/tools/bull-shit-of-yargs-exception-handler/</id>
    <published>2017-01-24T07:57:11.000Z</published>
    <updated>2021-03-11T07:20:00.098Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>yargs（<a href="https://www.npmjs.com/package/yargs">官方地址</a>） 是一个比较好用的 node 命令行参数处理工具。他可以让我们摆脱处理参数的麻烦。最近做一个项目的工作流改进用到了这个库，遇到了一个坑，在这里记录一下。</p><p>接受用户输入的参数时候需要对必要的参数进行检查，如果没有输入则需要结束流程，并提示用户传入所需参数。按照 yargs 的文档来看应该这样做</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var argv &#x3D; require(&#39;yargs&#39;)</span><br><span class="line">    .usage(&#39;Usage: $0 &lt;command&gt; [options]&#39;)</span><br><span class="line">    .demandOption(&#39;p&#39;, &#39;command -p is needed&#39;)</span><br><span class="line">    .demandCommand(1, &#39;command -p is needed&#39;)</span><br><span class="line">    .help(&#39;h&#39;)</span><br><span class="line">    .alias(&#39;h&#39;, &#39;help&#39;)</span><br><span class="line">    .argv;</span><br></pre></td></tr></table></figure><p>但是这样做并不起作用，当我们不传参数直接执行命令的时候，依然直接跑了下去。这并不符合我们的预期，在多方查找之后，终于在 yargs 的 issue 里面发现了<a href="https://github.com/yargs/yargs/issues/566">这个</a>解决方案。</p><p>简单来讲，这个解决方案就是叫我们在配置的时候加一个选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.global(&#39;p&#39;)</span><br></pre></td></tr></table></figure><p>这个选项的意思是，在命令执行后继续保留这个参数（蛤？），这样就可以解决这个问题了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="工具" scheme="https://ufolux.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>ChromeDevTool修改本地文件</title>
    <link href="https://ufolux.github.io/2017/01/19/Front_End/tools/modify-native-files-withe-chrome-dev-tool/"/>
    <id>https://ufolux.github.io/2017/01/19/Front_End/tools/modify-native-files-withe-chrome-dev-tool/</id>
    <published>2017-01-19T08:19:57.000Z</published>
    <updated>2021-03-11T07:20:00.098Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>这次记录一个在 Chrome Dev Tool 中直接修改本地的源代码文件的方法。</p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们在前端开发中经常需要使用 ChromeDevTool 来进行调试，我想大家经常会遇到这种场景：</p><ul><li>这里有一个字符串写错了，改一下就好了</li><li>这里加个 if 判断保护一下就好了</li><li>这里变量名写错了<br>等等</li></ul><p>在这些情况下我们往往只需要进行很少量的修改就可以修复一个 bug，但是切到编辑其中修复之后，我们又要跑一遍脚本或者在浏览器中打下一串地址（没有 hot-reload 的项目中），如果是混合移动的开发，我们还需要打包到真机上。这就是一个比较耗时的过程。何况当页面加载出来之后我们还要登陆，恢复现场才能调试一个小小的 bug。如果能在浏览器里面直接改动代码，马上恢复现场跑一下不就可以省去很多麻烦，chrome 的这个功能就会帮到你。</p><h3 id="步骤如下"><a href="#步骤如下" class="headerlink" title="步骤如下"></a>步骤如下</h3><ol><li>首先打开 ChromeDevTool，切换到 Sources Tab</li><li>在任意文件上单击右键 Add Folder to Folder，将包含所需代码的文件夹包含到工程中（这时 Chrome 会提示需要获得该文件夹的完全控制权限，这里点击 Allow）</li><li>在任意文件上单击右键，点击 Map to File System Resources</li><li>这时 Chrome 会提示用户重新载入开发者工具，点击 Ok 重新启动开发者工具。</li><li>然后就可以看到目录结构已经变成了我们的本地目录。command+p 搜索文件的时候也可以看到文件的路径变成本地路径了。这时在文件上进行修改，改动就会直接作用于本地的文件。而且修改后的文件可以直接用于调试而无需重新启动应用（浏览器调试和真机调试均是如此）。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="chrome" scheme="https://ufolux.github.io/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript+React 实践</title>
    <link href="https://ufolux.github.io/2016/12/20/Front_End/react/practice-on-react-with-ts/"/>
    <id>https://ufolux.github.io/2016/12/20/Front_End/react/practice-on-react-with-ts/</id>
    <published>2016-12-20T13:56:38.000Z</published>
    <updated>2021-03-11T07:20:00.097Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h3><p>强类型的 javascript</p><h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><p>利用 jsx 实现 web 开发的组件化。</p><h3 id="d-ts-文件"><a href="#d-ts-文件" class="headerlink" title="d.ts 文件"></a>d.ts 文件</h3><p>d.ts 文件是 typescript 的类型定义文件，ts 依靠这个文件来为 js 代码中的类型添加类型说明并提供类型检查<br>所有的类型定义文件基本都可以在<a href="https://github.com/DefinitelyTyped/DefinitelyTyped">这里</a>找到</p><h3 id="typings"><a href="#typings" class="headerlink" title="typings"></a>typings</h3><p><a href="https://github.com/typings/typings">https://github.com/typings/typings</a><br>typings 是一个 typescript 的类型定义管理工具，可以使用它来安装 js 框架的 d.ts 类型定义文件，这样在 ts 项目中使用 js 框架时候就会得到准确的类型定义。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><blockquote><p>材料<br><code>node</code><br><code>npm</code></p></blockquote><span id="more"></span><h3 id="建立项目的目录结构"><a href="#建立项目的目录结构" class="headerlink" title="建立项目的目录结构"></a>建立项目的目录结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proj&#x2F;</span><br><span class="line">   ├─ src&#x2F;</span><br><span class="line">   |    └─ components&#x2F;</span><br><span class="line">   |</span><br><span class="line">   └─ dist&#x2F;</span><br></pre></td></tr></table></figure><h3 id="初始化-npm"><a href="#初始化-npm" class="headerlink" title="初始化 npm"></a>初始化 npm</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm init&#96;</span><br></pre></td></tr></table></figure><h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><h3 id="0x01-安装-typescript-和-webpack"><a href="#0x01-安装-typescript-和-webpack" class="headerlink" title="0x01 安装 typescript 和 webpack"></a>0x01 安装 typescript 和 webpack</h3><p>在全局安装 typescript 和 webpack</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g typescript webpack</span><br></pre></td></tr></table></figure><h3 id="0x02-安装-react-和-react-dom"><a href="#0x02-安装-react-和-react-dom" class="headerlink" title="0x02 安装 react 和 react-dom"></a>0x02 安装 react 和 react-dom</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save react react-dom @types&#x2F;react @types&#x2F;react-dom</span><br></pre></td></tr></table></figure><h3 id="0x03-安装开发依赖"><a href="#0x03-安装开发依赖" class="headerlink" title="0x03 安装开发依赖"></a>0x03 安装开发依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev ts-loader source-map-loader</span><br><span class="line">$ npm link typescript</span><br></pre></td></tr></table></figure><p>这里安装 <code>ts-loader</code> 用于调用 <code>tsc</code> 来根据 <code>tsconfig.json</code> 编译 .ts 文件，输出 .js 文件，<code>source-map-loader</code> 它会根据 tsc 编译生成的 ts&lt;-&gt;js sourcemap 文件生成 webpack 的 sourcemap 文件。</p><p>npm link 可以让 ts-loader 直接使用全局的 tsc 来编译 ts 文件，这样就无须在项目目录下单独安装 typescript。</p><h3 id="0x04-HelloWorld"><a href="#0x04-HelloWorld" class="headerlink" title="0x04 HelloWorld"></a>0x04 HelloWorld</h3><p>在 src 目录下新建 index.tsx 文件，键入如下内容</p><p>index.tsx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line">import * as ReactDOM from &quot;react-dom&quot;;</span><br><span class="line"></span><br><span class="line">import &#123; Hello &#125; from &quot;.&#x2F;components&#x2F;Hello&quot;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Hello compiler&#x3D;&quot;TypeScript&quot; framework&#x3D;&quot;React&quot; &#x2F;&gt;,</span><br><span class="line">    document.getElementById(&quot;example&quot;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在 src/components 目录下新建一个 Hello 组件</p><p>Hello.tsx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">export interface HelloProps &#123; compiler: string; framework: string; &#125;</span><br><span class="line"></span><br><span class="line">export class Hello extends React.Component&lt;HelloProps, &#123;&#125;&gt; &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;h1&gt;Hello from &#123;this.props.compiler&#125; and &#123;this.props.framework&#125;!&lt;&#x2F;h1&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在根目录下面创建 index.html 文件<br>index.html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;</span><br><span class="line">        &lt;title&gt;Hello React!&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div id&#x3D;&quot;example&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;script src&#x3D;&quot;.&#x2F;node_modules&#x2F;react&#x2F;dist&#x2F;react.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">        &lt;script src&#x3D;&quot;.&#x2F;node_modules&#x2F;react-dom&#x2F;dist&#x2F;react-dom.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">        &lt;script src&#x3D;&quot;.&#x2F;dist&#x2F;bundle.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="0x05-编写-tsconfig-json"><a href="#0x05-编写-tsconfig-json" class="headerlink" title="0x05 编写 tsconfig.json"></a>0x05 编写 tsconfig.json</h3><p>在根目录下新建 <code>tsconfig.json</code> 文件，键入以下内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;outDir&quot;: &quot;.&#x2F;dist&#x2F;&quot;,</span><br><span class="line">        &quot;sourceMap&quot;: true,</span><br><span class="line">        &quot;noImplicitAny&quot;: true,</span><br><span class="line">        &quot;module&quot;: &quot;commonjs&quot;,</span><br><span class="line">        &quot;target&quot;: &quot;es5&quot;,</span><br><span class="line">        &quot;jsx&quot;: &quot;react&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;files&quot;: [</span><br><span class="line">        &quot;.&#x2F;src&#x2F;components&#x2F;Hello.tsx&quot;,</span><br><span class="line">        &quot;.&#x2F;src&#x2F;index.tsx&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x06-配置-webpack"><a href="#0x06-配置-webpack" class="headerlink" title="0x06 配置 webpack"></a>0x06 配置 webpack</h3><p>同样在根目录下创建 webpack.config.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: &quot;.&#x2F;src&#x2F;index.tsx&quot;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &quot;bundle.js&quot;,</span><br><span class="line">        path: __dirname + &quot;&#x2F;dist&quot;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    devtool: &quot;source-map&quot;,</span><br><span class="line"></span><br><span class="line">    resolve: &#123;</span><br><span class="line">        extensions: [&quot;&quot;, &quot;.webpack.js&quot;, &quot;.web.js&quot;, &quot;.ts&quot;, &quot;.tsx&quot;, &quot;.js&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    module: &#123;</span><br><span class="line">        loaders: [</span><br><span class="line">            &#123; test: &#x2F;\.tsx?$&#x2F;, loader: &quot;ts-loader&quot; &#125;</span><br><span class="line">        ],</span><br><span class="line"></span><br><span class="line">        preLoaders: [</span><br><span class="line">            &#123; test: &#x2F;\.js$&#x2F;, loader: &quot;source-map-loader&quot; &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    externals: &#123;</span><br><span class="line">        &quot;react&quot;: &quot;React&quot;,</span><br><span class="line">        &quot;react-dom&quot;: &quot;ReactDOM&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="0x07-run"><a href="#0x07-run" class="headerlink" title="0x07 run"></a>0x07 run</h3><p>执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ webpack</span><br></pre></td></tr></table></figure><h2 id="一些坑"><a href="#一些坑" class="headerlink" title="一些坑"></a>一些坑</h2><h3 id="没有-d-ts"><a href="#没有-d-ts" class="headerlink" title="没有 d.ts"></a>没有 d.ts</h3><p>有一些开源的 js 框架没有现成的 d.ts 类型定义文件，这就导致在 ts 中使用这些框架会编译不通过。</p><p>如果框架是类似 jQuery 这种内容都被封装在一个全局变量中的框架来讲，以 jquery 为例只需要在html中引用文件，并在使用到框架的地方为对象添加 any 的类型说明就可以使用了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#39;jquery&#39;</span><br><span class="line"></span><br><span class="line">declare var jquery: any, $: any;</span><br></pre></td></tr></table></figure><p>但是对于非封装到一个全局变量中的框架，就比较麻烦了。需要自己编写类型说明，这里还没有比较好的办法。编写类型定义文件的方法在<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/declaration%20files/Introduction.html">这里</a></p><h3 id="使用-npm-安装的-types-会报错"><a href="#使用-npm-安装的-types-会报错" class="headerlink" title="使用 npm 安装的 types 会报错"></a>使用 npm 安装的 types 会报错</h3><p>问题：<br>“@types/react”: “^0.14.44”,<br>“@types/react-dom”: “^0.14.18”,<br>在项目中使用这两个版本的类型定义文件编译时会报错。</p><p>解决方案：<br>不要使用 npm 安装 types 直接使用 typings 安装需要的 js 框架的类型定义文件，然后在编译选项中引入这些声明文件。<br>参见: <a href="http://hao.jser.com/archive/10416/">TYPESCRIPT项目和TSCONFIG.JSON</a><br>或者直接升级至以下版本<br>“@types/react”: “^0.14.52”,<br>“@types/react-dom”: “^0.14.19”,</p><p>参考：</p><ol><li><a href="http://to-u.xyz/2016/05/26/webpack-react-multiplePage/">http://to-u.xyz/2016/05/26/webpack-react-multiplePage/</a></li><li><a href="https://react-bootstrap.github.io/components.html">https://react-bootstrap.github.io/components.html</a></li><li><a href="https://www.typescriptlang.org/docs/handbook/react-&amp;-webpack.html">https://www.typescriptlang.org/docs/handbook/react-&amp;-webpack.html</a></li><li><a href="http://blog.csdn.net/kinfey/article/details/50387534">http://blog.csdn.net/kinfey/article/details/50387534</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一些概念&quot;&gt;&lt;a href=&quot;#一些概念&quot; class=&quot;headerlink&quot; title=&quot;一些概念&quot;&gt;&lt;/a&gt;一些概念&lt;/h2&gt;&lt;h3 id=&quot;TypeScript&quot;&gt;&lt;a href=&quot;#TypeScript&quot; class=&quot;headerlink&quot; title=&quot;TypeScript&quot;&gt;&lt;/a&gt;TypeScript&lt;/h3&gt;&lt;p&gt;强类型的 javascript&lt;/p&gt;
&lt;h3 id=&quot;React&quot;&gt;&lt;a href=&quot;#React&quot; class=&quot;headerlink&quot; title=&quot;React&quot;&gt;&lt;/a&gt;React&lt;/h3&gt;&lt;p&gt;利用 jsx 实现 web 开发的组件化。&lt;/p&gt;
&lt;h3 id=&quot;d-ts-文件&quot;&gt;&lt;a href=&quot;#d-ts-文件&quot; class=&quot;headerlink&quot; title=&quot;d.ts 文件&quot;&gt;&lt;/a&gt;d.ts 文件&lt;/h3&gt;&lt;p&gt;d.ts 文件是 typescript 的类型定义文件，ts 依靠这个文件来为 js 代码中的类型添加类型说明并提供类型检查&lt;br&gt;所有的类型定义文件基本都可以在&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;这里&lt;/a&gt;找到&lt;/p&gt;
&lt;h3 id=&quot;typings&quot;&gt;&lt;a href=&quot;#typings&quot; class=&quot;headerlink&quot; title=&quot;typings&quot;&gt;&lt;/a&gt;typings&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/typings/typings&quot;&gt;https://github.com/typings/typings&lt;/a&gt;&lt;br&gt;typings 是一个 typescript 的类型定义管理工具，可以使用它来安装 js 框架的 d.ts 类型定义文件，这样在 ts 项目中使用 js 框架时候就会得到准确的类型定义。&lt;/p&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;材料&lt;br&gt;&lt;code&gt;node&lt;/code&gt;&lt;br&gt;&lt;code&gt;npm&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="react" scheme="https://ufolux.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>利用highchart绘制图表</title>
    <link href="https://ufolux.github.io/2016/11/24/Front_End/vendor/make-chart-by-highchart/"/>
    <id>https://ufolux.github.io/2016/11/24/Front_End/vendor/make-chart-by-highchart/</id>
    <published>2016-11-24T00:59:15.000Z</published>
    <updated>2021-03-11T07:20:00.102Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="几个基本的概念"><a href="#几个基本的概念" class="headerlink" title="几个基本的概念"></a>几个基本的概念</h2><center>![Highchart](../../../images/highchart-highchart.png)</center><table><thead><tr><th align="left">名词</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Title</td><td align="left">图表的标题</td></tr><tr><td align="left">Axis</td><td align="left">坐标轴</td></tr><tr><td align="left">Series</td><td align="left">数据列，表现为图表上呈现数据的形状</td></tr><tr><td align="left">Tooltip</td><td align="left">鼠标悬停在数据点上的时候显示的一个提示框</td></tr><tr><td align="left">Legend</td><td align="left">图例</td></tr><tr><td align="left">Credits</td><td align="left">版权信息</td></tr><tr><td align="left">Exporting</td><td align="left">导出图标的按钮</td></tr><tr><td align="left">PlotLines</td><td align="left">图表上的辅助线，比如图表背景的网格或者标识出某一点数据的指示线。</td></tr><tr><td align="left">PlotBands</td><td align="left">在某些数据区域上画出的分辨带</td></tr><tr><td align="left">Crosshair</td><td align="left">跟随鼠标在图表上显示的标线，是一个隶属于坐标轴的属性</td></tr><tr><td align="left">Marker</td><td align="left">用于标识数据的点，可以设置普通状态和悬浮状态的样式</td></tr></tbody></table><h2 id="一些-hack-的手段"><a href="#一些-hack-的手段" class="headerlink" title="一些 hack 的手段"></a>一些 hack 的手段</h2><p>在真实工作中，有些设计稿里面描绘的样式不能通过简单的调整 highchart 配置或者直接使用 highchart 的绘图接口进行绘图来实现（比如调整折线图中 crosshair 和 marker 的位置）。<br>通过阅读源代码，我 hook 到了一个十分好用的方法， 这个方法是 <code>chart.tooltip.refresh</code>，每当鼠标移动到图表范围内的时候，这个方法都会被调用，我们只需要 hook 这个方法，然后再其内部对 point 的数据进行更改就可以实现我们大部分的需求了。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><center>![Highchart](../../../images/highchart-chart.png)</center><p>这个是在我们需求中设计的一个图表样式，乍一看像是直方图，但又是个折线图。这里我们使用 area 面积图也就是折线图的样式来进行图表的配置。<br>我们注意到，这个图中 crosshair 和 marker 的位置和标准的 area 图中是有所区别的。标准的 area 图中这两东西都会显示在数据点的位置上，而在我们的图中，它们显示在了两个数据点的中间，这时候，我们 hook <code>refresh</code> 方法，在里面修改 point 的 plotX 值，再hook XAxis 的 drawCrosshair 方法，修改传入 drawCrosshair 中的 point 对象的 plotX 值。最后实现了居中的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var offset &#x3D; chart.plotWidth &#x2F; (chart.pointCount - 1) &#x2F; 2;</span><br><span class="line">var offsetCorsshair &#x3D; function(e, point) &#123;</span><br><span class="line">    if (point) &#123;</span><br><span class="line">        var originX &#x3D; point.plotX;</span><br><span class="line">        point.plotX +&#x3D; offset;</span><br><span class="line">        __drawCrosshair.call(this, e, point);</span><br><span class="line">        point.plotX &#x3D; originX;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">chart.tooltip.refresh &#x3D; function(point, mouseEvent) &#123;</span><br><span class="line">    var __setState;</span><br><span class="line">    if (point.length &gt; 0) &#123;</span><br><span class="line">        var myPoint &#x3D; point[0];</span><br><span class="line">        __setState &#x3D; myPoint.setState;</span><br><span class="line"></span><br><span class="line">        var originX &#x3D; myPoint.plotX;</span><br><span class="line">        if (myPoint.x !&#x3D; 5) &#123;</span><br><span class="line">            myPoint.plotX +&#x3D; offset;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            myPoint.plotX +&#x3D; offset * 2;</span><br><span class="line">        &#125;</span><br><span class="line">        myPoint.setState &#x3D; __setState;</span><br><span class="line">        __refresh.call(this, point, mouseEvent);</span><br><span class="line">        myPoint.plotX &#x3D; originX;</span><br><span class="line">        __xAxis.drawCrosshair &#x3D; offsetCorsshair;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://ufolux.github.io/tags/javascript/"/>
    
      <category term="库" scheme="https://ufolux.github.io/tags/%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Emmet代码生成神器</title>
    <link href="https://ufolux.github.io/2016/10/09/Front_End/tools/emmet-zencoding/"/>
    <id>https://ufolux.github.io/2016/10/09/Front_End/tools/emmet-zencoding/</id>
    <published>2016-10-09T06:55:41.000Z</published>
    <updated>2021-03-11T07:20:00.098Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Emmet 的前身是 Zen Coding，它提供了一套简单的语法来帮助前端开发快速地生成代码。最近有空学习了一下，这里做下记录。</p><h2 id="体验一把"><a href="#体验一把" class="headerlink" title="体验一把"></a>体验一把</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;logo&quot;&gt;</span><br><span class="line">        &lt;ul class&#x3D;&quot;list&quot;&gt;</span><br><span class="line">            &lt;li class&#x3D;&quot;item&quot;&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt;Baidu 1&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;li class&#x3D;&quot;item&quot;&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt;Baidu 2&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;li class&#x3D;&quot;item&quot;&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt;Baidu 3&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;li class&#x3D;&quot;item&quot;&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt;Baidu 4&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;li class&#x3D;&quot;item&quot;&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt;Baidu 5&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>如何写出上面这段代码？使用 Emmet，只要下面这一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!&gt;.logo&gt;ul.list&gt;li.item*5&gt;a[href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;]&#123;Baidu $&#125;</span><br></pre></td></tr></table></figure><p>把这段指令 copy 到 VSCode 中，光标移动到指令的末尾后按下 tab 就可以生成出以上的代码了，是不是很方便。</p><span id="more"></span><h2 id="HTML-快速编写指令"><a href="#HTML-快速编写指令" class="headerlink" title="HTML 快速编写指令"></a>HTML 快速编写指令</h2><h3 id="和-html-指令"><a href="#和-html-指令" class="headerlink" title="! 和 html 指令"></a>! 和 html 指令</h3><p>快速生成 Html 文档结构</p><ul><li><code>!</code> 或 <code>html:5</code> 可以生成 html5 版本的文档结构。</li><li><code>html:xt</code> 可以生成 xhtml 版本的文档结构。</li><li><code>html:4s</code> 可以生成标准的 html4.0 版本文档结构。</li></ul><h3 id="选择器指令"><a href="#选择器指令" class="headerlink" title="选择器指令"></a>选择器指令</h3><ul><li><code>.</code> 指明要生成的 class 名称。</li><li><code>#</code> 指明要生成的 id 名称。</li><li><code>Tag</code> 用 Tag 表示标签名称，直接使用 Tag+Tab 就可以生成对应的标签代码。</li></ul><p>生成一个 div</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div</span><br></pre></td></tr></table></figure><p>生成一个 id 为 page1 的 div 标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div#page1</span><br></pre></td></tr></table></figure><p>生成一个 class 为 item 的 li 标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">li#item</span><br></pre></td></tr></table></figure><blockquote><p>Emmet 默认的标签是 div，如果我们不给出标签名称的话就默认生成 div 标签。生成 id 为 container 的 div 标签，我们只需要编写下面指令：<br><code>div#container</code> 或者 <code>#container</code>。<br>或者生成 class 为 page 的标签：<br><code>div.page</code> 或 <code>.page</code></p></blockquote><h3 id="隐式标签"><a href="#隐式标签" class="headerlink" title="隐式标签"></a>隐式标签</h3><p>隐式标签表示 Emmet 可以省略某些标签名，例如，声明一个带类的div，只需输入.item，就会生成<div class="item"></div>。另外，Emmet 还会根据父标签进行判定，例如，在中输入ul&gt;.item*5，就可以生成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li class&#x3D;&quot;item&quot;&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;li class&#x3D;&quot;item&quot;&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;li class&#x3D;&quot;item&quot;&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;li class&#x3D;&quot;item&quot;&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;li class&#x3D;&quot;item&quot;&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure><p>下面是所有的隐式标签名称：<br>li：用于 ul 和 ol 中<br>tr：用于 table、tbody、thead 和 tfoot 中<br>td：用于 tr 中<br>option：用于 select 和 optgroup 中<br>div：除以上之外位置的默认标签</p><h3 id="设置属性-attr-value"><a href="#设置属性-attr-value" class="headerlink" title="设置属性 [attr=value]"></a>设置属性 [attr=value]</h3><p>给 a 标签设置 href 属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[href&#x3D;http:&#x2F;&#x2F;www.qq.com]</span><br></pre></td></tr></table></figure><p>给 div 添加自定义属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div[data-type&#x3D;json]</span><br></pre></td></tr></table></figure><h3 id="设置标签内容"><a href="#设置标签内容" class="headerlink" title="设置标签内容 {}"></a>设置标签内容 {}</h3><p>设置 p 标签的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p&#123;Hello World!&#125;</span><br></pre></td></tr></table></figure><h3 id="兄弟指令"><a href="#兄弟指令" class="headerlink" title="兄弟指令 +"></a>兄弟指令 +</h3><p>使用 <code>+</code> 可以生成几个同级别的指令，比如生成两个同级别的 p 标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.text1+p.text2</span><br></pre></td></tr></table></figure><p>生成的代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class&#x3D;&quot;text1&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p class&#x3D;&quot;text2&quot;&gt;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><h3 id="后代指令-gt"><a href="#后代指令-gt" class="headerlink" title="后代指令 &gt;"></a>后代指令 &gt;</h3><p>使用 <code>&gt;</code> 可以生成嵌套的子标签。比如在 ul 中嵌入 li</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ul&gt;li</span><br></pre></td></tr></table></figure><p>生成的代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure><h3 id="向上一级指令"><a href="#向上一级指令" class="headerlink" title="向上一级指令 ^"></a>向上一级指令 ^</h3><p>使用指令 <code>^</code> 可以使当前的指令所生成的代码的层级向上提升一级，比如当我们使用指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div&gt;ul</span><br></pre></td></tr></table></figure><p>的时候，生成的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;ul&gt;&lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>这时候指令生成的代码级别是 div 的下一级，这是我们又想在 div 的同级别插入一个 div，就需要使用 <code>^</code> 指令嵌套层级向上移一级</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div&gt;ul^div</span><br></pre></td></tr></table></figure><p>的时候，生成的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;ul&gt;&lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><blockquote><p>可以多次连续使用这个指令来调整指令作用的级别。</p></blockquote><h3 id="分组指令"><a href="#分组指令" class="headerlink" title="分组指令 ()"></a>分组指令 ()</h3><p>用括号进行分组，表示一个代码块，分组内部的嵌套和层级关系和分组外部无关，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div&gt;(header&gt;ul&gt;li*2&gt;a)+footer&gt;p</span><br></pre></td></tr></table></figure><p>生成了如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href&#x3D;&quot;&quot;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href&#x3D;&quot;&quot;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;&#x2F;header&gt;</span><br><span class="line">    &lt;footer&gt;</span><br><span class="line">        &lt;p&gt;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;footer&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h3 id="重复"><a href="#重复" class="headerlink" title="重复 *"></a>重复 *</h3><p>很简单，重复生成一个类型的标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ul.list&gt;li.item*5</span><br></pre></td></tr></table></figure><p>生成的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class&#x3D;&quot;list&quot;&gt;</span><br><span class="line">    &lt;li class&#x3D;&quot;item&quot;&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li class&#x3D;&quot;item&quot;&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li class&#x3D;&quot;item&quot;&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li class&#x3D;&quot;item&quot;&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li class&#x3D;&quot;item&quot;&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure><h3 id="编号"><a href="#编号" class="headerlink" title="编号"></a>编号</h3><p>使用 <code>$</code> 可以获取当前重复元素的编号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ul.list&gt;li.item*5&gt;a&#123;item $&#125;</span><br></pre></td></tr></table></figure><p>生成代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class&#x3D;&quot;list&quot;&gt;</span><br><span class="line">    &lt;li class&#x3D;&quot;item&quot;&gt;&lt;a href&#x3D;&quot;&quot;&gt;item 1&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li class&#x3D;&quot;item&quot;&gt;&lt;a href&#x3D;&quot;&quot;&gt;item 2&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li class&#x3D;&quot;item&quot;&gt;&lt;a href&#x3D;&quot;&quot;&gt;item 3&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li class&#x3D;&quot;item&quot;&gt;&lt;a href&#x3D;&quot;&quot;&gt;item 4&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li class&#x3D;&quot;item&quot;&gt;&lt;a href&#x3D;&quot;&quot;&gt;item 5&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure><p>还可以通过使用 <code>@</code> 来指定开始的序号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ul.list&gt;li.item*5&gt;a&#123;item $@2&#125;</span><br></pre></td></tr></table></figure><p>然后序号是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class&#x3D;&quot;list&quot;&gt;</span><br><span class="line">    &lt;li class&#x3D;&quot;item&quot;&gt;&lt;a href&#x3D;&quot;&quot;&gt;item 2&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li class&#x3D;&quot;item&quot;&gt;&lt;a href&#x3D;&quot;&quot;&gt;item 3&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li class&#x3D;&quot;item&quot;&gt;&lt;a href&#x3D;&quot;&quot;&gt;item 4&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li class&#x3D;&quot;item&quot;&gt;&lt;a href&#x3D;&quot;&quot;&gt;item 5&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li class&#x3D;&quot;item&quot;&gt;&lt;a href&#x3D;&quot;&quot;&gt;item 6&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure><p>倒序，也可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ul.list&gt;li.item*5&gt;a&#123;item $@-2&#125;</span><br></pre></td></tr></table></figure><p>倒序输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class&#x3D;&quot;list&quot;&gt;</span><br><span class="line">    &lt;li class&#x3D;&quot;item&quot;&gt;&lt;a href&#x3D;&quot;&quot;&gt;item 6&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li class&#x3D;&quot;item&quot;&gt;&lt;a href&#x3D;&quot;&quot;&gt;item 5&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li class&#x3D;&quot;item&quot;&gt;&lt;a href&#x3D;&quot;&quot;&gt;item 4&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li class&#x3D;&quot;item&quot;&gt;&lt;a href&#x3D;&quot;&quot;&gt;item 3&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li class&#x3D;&quot;item&quot;&gt;&lt;a href&#x3D;&quot;&quot;&gt;item 2&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure><h2 id="HTML-简写规则总结"><a href="#HTML-简写规则总结" class="headerlink" title="HTML 简写规则总结"></a>HTML 简写规则总结</h2><p>　　1. E 代表HTML标签。<br>　　2. E#id 代表id属性。<br>　　3. E.class 代表class属性。<br>　　4. E[attr=foo] 代表某一个特定属性。<br>　　5. E{foo} 代表标签包含的内容是foo。<br>　　6. E&gt;N 代表N是E的子元素。<br>　　7. E+N 代表N是E的同级元素。<br>　　8. E^N 代表N是E的上级元素。</p><blockquote><p>注意<br><strong>不能 Emmet 指令中使用空格</strong></p></blockquote><p>关于 CSS 的简写，后面再更。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Emmet 的前身是 Zen Coding，它提供了一套简单的语法来帮助前端开发快速地生成代码。最近有空学习了一下，这里做下记录。&lt;/p&gt;
&lt;h2 id=&quot;体验一把&quot;&gt;&lt;a href=&quot;#体验一把&quot; class=&quot;headerlink&quot; title=&quot;体验一把&quot;&gt;&lt;/a&gt;体验一把&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;html lang&amp;#x3D;&amp;quot;en&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;meta charset&amp;#x3D;&amp;quot;UTF-8&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;title&amp;gt;Document&amp;lt;&amp;#x2F;title&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;&amp;#x2F;head&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;div class&amp;#x3D;&amp;quot;logo&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;ul class&amp;#x3D;&amp;quot;list&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;lt;li class&amp;#x3D;&amp;quot;item&amp;quot;&amp;gt;&amp;lt;a href&amp;#x3D;&amp;quot;http:&amp;#x2F;&amp;#x2F;www.baidu.com&amp;quot;&amp;gt;Baidu 1&amp;lt;&amp;#x2F;a&amp;gt;&amp;lt;&amp;#x2F;li&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;lt;li class&amp;#x3D;&amp;quot;item&amp;quot;&amp;gt;&amp;lt;a href&amp;#x3D;&amp;quot;http:&amp;#x2F;&amp;#x2F;www.baidu.com&amp;quot;&amp;gt;Baidu 2&amp;lt;&amp;#x2F;a&amp;gt;&amp;lt;&amp;#x2F;li&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;lt;li class&amp;#x3D;&amp;quot;item&amp;quot;&amp;gt;&amp;lt;a href&amp;#x3D;&amp;quot;http:&amp;#x2F;&amp;#x2F;www.baidu.com&amp;quot;&amp;gt;Baidu 3&amp;lt;&amp;#x2F;a&amp;gt;&amp;lt;&amp;#x2F;li&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;lt;li class&amp;#x3D;&amp;quot;item&amp;quot;&amp;gt;&amp;lt;a href&amp;#x3D;&amp;quot;http:&amp;#x2F;&amp;#x2F;www.baidu.com&amp;quot;&amp;gt;Baidu 4&amp;lt;&amp;#x2F;a&amp;gt;&amp;lt;&amp;#x2F;li&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;lt;li class&amp;#x3D;&amp;quot;item&amp;quot;&amp;gt;&amp;lt;a href&amp;#x3D;&amp;quot;http:&amp;#x2F;&amp;#x2F;www.baidu.com&amp;quot;&amp;gt;Baidu 5&amp;lt;&amp;#x2F;a&amp;gt;&amp;lt;&amp;#x2F;li&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;&amp;#x2F;ul&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;&amp;#x2F;div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;&amp;#x2F;body&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;&amp;#x2F;html&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;如何写出上面这段代码？使用 Emmet，只要下面这一行&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;!&amp;gt;.logo&amp;gt;ul.list&amp;gt;li.item*5&amp;gt;a[href&amp;#x3D;&amp;quot;http:&amp;#x2F;&amp;#x2F;www.baidu.com&amp;quot;]&amp;#123;Baidu $&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;把这段指令 copy 到 VSCode 中，光标移动到指令的末尾后按下 tab 就可以生成出以上的代码了，是不是很方便。&lt;/p&gt;
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="工具" scheme="https://ufolux.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>坑爹的focus事件</title>
    <link href="https://ufolux.github.io/2016/09/26/Front_End/ionic/bull-shit-focus-event-on-ios/"/>
    <id>https://ufolux.github.io/2016/09/26/Front_End/ionic/bull-shit-focus-event-on-ios/</id>
    <published>2016-09-26T08:19:20.000Z</published>
    <updated>2021-03-11T07:20:00.095Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>搜索列表页面里面自动聚焦搜索框，键盘自动弹出，这个交互简直再正常不过了。给用户，尤其对于<br>iPhone 的 plus 系列用户来说，在操作上带来了很大的便利。但是在 iOS 的 UIWebview<br>十分坑爹，focus<br>事件不能在代码中触发。美其名曰防止用户被干扰，简直坑爹，导致这个需求在非原生的页面中根本无法实现，所以用户必须去点击一下搜索框才可以聚焦。</p><p>网上统一供了几种解决方案，我一一尝试过了，无效。看样子只有在 click<br>里面使用一个同步的方式才能触发 focus 事件，否则无效（在里面添加 timeout<br>异步触发也是失败）。</p><p>这时候我想起了 cordova Keyboard<br>插件，当我翻开他的源码时候，只见一位开发者绝望的写道：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void) show:(CDVInvokedUrlCommand*)command &#123;</span><br><span class="line">    NSLog(@&quot;Showing keyboard not supported in iOS due to platform limitations.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>呵呵！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="javascript,ionic" scheme="https://ufolux.github.io/tags/javascript-ionic/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序初体验</title>
    <link href="https://ufolux.github.io/2016/09/25/Front_End/wechat-dev/introduce-wechat-mina-framwork/"/>
    <id>https://ufolux.github.io/2016/09/25/Front_End/wechat-dev/introduce-wechat-mina-framwork/</id>
    <published>2016-09-25T06:02:48.000Z</published>
    <updated>2021-03-11T07:20:00.102Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>上周微信发布了<strong>微信·小程序</strong>功能，通过这个功能，开发者可以直接依托微信开发一个具有堪比原生 APP 体验的 WEB 应用。由于这个功能目前还处于邀请体验阶段，未受到邀请的开发者并不能直接看到 API 文档，不过热心的开发者已经将文档爬取下来并且在<a href="http://wxopen.notedown.cn/">这里</a>提供浏览。下面我们来看一下这个小程序是一个怎样的东西。</p><span id="more"></span><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>正如文档中描述的，微信·小程序使用了微信自家研发的 MINA 框架开发，阅读了文档后发现这个框架相对轻量，框架提供了自己的视图描述语言 WXML 和样式描述语言 WXSS，使用 Javascript 进行逻辑层的开发。框架还提供了数据传输和事件系统，便于开发者对数据和逻辑的处理。</p><h4 id="简单明了的生命周期"><a href="#简单明了的生命周期" class="headerlink" title="简单明了的生命周期"></a>简单明了的生命周期</h4><p>框架提供了简单明晰的应用生命周期，这一点对于事件驱动的开发来讲是很重要的，清楚地生命周期可以使开发者很清楚当前程序运行的状态，并在合适的时机执行想要的逻辑。</p><h4 id="单向数据绑定"><a href="#单向数据绑定" class="headerlink" title="单向数据绑定"></a>单向数据绑定</h4><p>框架并没有像 angular 那样为我们提供双向数据绑定，但这也给框架减轻了很大的负担，在获取用户输入方面，我们需要手动将控件的值和 model 对象绑定在一起，这样用户在界面上的输入就可以实时的更新到数据对象上。</p><p>wxml代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id&#x3D;&quot;myInput&quot; bindchange&#x3D;&quot;bindChange&quot; &#x2F;&gt;</span><br><span class="line">&lt;checkbox id&#x3D;&quot;myCheckbox&quot; bindchange&#x3D;&quot;bindChange&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>javascript 代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var inputContent &#x3D; &#123;&#125;</span><br><span class="line">Page(&#123;</span><br><span class="line">    data:&#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    bindChange:function(e)&#123;</span><br><span class="line">        inputContent[e.currentTarget.id] &#x3D; e.detail.value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="能力"><a href="#能力" class="headerlink" title="能力"></a>能力</h3><p>支持许多原生能力的调用，比如照机，相册，音频录制和播放，GPS，系统信息，网络状态，罗盘等。</p><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p>微信同时提供了一个小程序专属的开发工具，目前的版本是 v0.9.092100</p><p>由于目前仍然是邀请加入时期，开发者工具并不对未接入小程序的开发者开放使用，但是网上已经有人对工具进行了破解，下载和破解教程<a href="https://github.com/gavinkwoe/weapp-ide-crack">在此</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周微信发布了&lt;strong&gt;微信·小程序&lt;/strong&gt;功能，通过这个功能，开发者可以直接依托微信开发一个具有堪比原生 APP 体验的 WEB 应用。由于这个功能目前还处于邀请体验阶段，未受到邀请的开发者并不能直接看到 API 文档，不过热心的开发者已经将文档爬取下来并且在&lt;a href=&quot;http://wxopen.notedown.cn/&quot;&gt;这里&lt;/a&gt;提供浏览。下面我们来看一下这个小程序是一个怎样的东西。&lt;/p&gt;
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="MINA,wechat" scheme="https://ufolux.github.io/tags/MINA-wechat/"/>
    
  </entry>
  
  <entry>
    <title>使用AOP来改善JavaScript代码</title>
    <link href="https://ufolux.github.io/2016/09/21/Front_End/js-fondation/aop-make-a-better-js-code/"/>
    <id>https://ufolux.github.io/2016/09/21/Front_End/js-fondation/aop-make-a-better-js-code/</id>
    <published>2016-09-21T12:10:10.000Z</published>
    <updated>2021-03-11T07:20:00.096Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在 javscript 中 AOP 的使用会带来很多方便，在程序的结构上实现了解耦，代码逻辑更加清晰。使用 AOP 我们还可以对逻辑进行非侵入性的改造，下面来看下用法：</p><h3 id="用于非侵入的插入逻辑"><a href="#用于非侵入的插入逻辑" class="headerlink" title="用于非侵入的插入逻辑"></a>用于非侵入的插入逻辑</h3><p>before 函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.before &#x3D; function(func) &#123;</span><br><span class="line">    var __self &#x3D; this;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        if (func.apply(this, arguments) &#x3D;&#x3D; false) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return __self.apply(this, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>after 函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.after &#x3D; function(func) &#123;</span><br><span class="line">    var __self &#x3D; this;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        var ret &#x3D; __self.apply(this, arguments);</span><br><span class="line">        if (ret &#x3D;&#x3D;&#x3D; false) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        func.apply(this, arguments);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>考虑这种情形，我们需要在 onload 方法之后或者之前执行一些代码<br>比如，我们需要在 alert(1)之前 alert(0)，在之后 alert(2)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.onload &#x3D; function() &#123;</span><br><span class="line">    alert(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们考虑如下三种手段：</p><ol><li>直接修改 onload 中的代码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.onload &#x3D; function() &#123;</span><br><span class="line">    alert(0);</span><br><span class="line">    alert(1);</span><br><span class="line">    alert(2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无疑这种方式是耦合度最高，最具侵入性的方法。<br>2. 使用中间变量保存 onload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">window.onload &#x3D; function() &#123;</span><br><span class="line">    alert(1);</span><br><span class="line">&#125;</span><br><span class="line">var __onlaod &#x3D; window.onload;</span><br><span class="line"></span><br><span class="line">window.onload &#x3D; function() &#123;</span><br><span class="line">    alert(0);</span><br><span class="line">    if(__onlaod) &#123;</span><br><span class="line">        __onload();</span><br><span class="line">    &#125;</span><br><span class="line">    alert(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种方式较上一种好一些，但是这里需要维护一个中间变量，维护中间变量还是需要一些成本的，而且代码冗长不够优雅也不够通用。<br>3. 使用 AOP 的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">window.onload &#x3D; function() &#123;</span><br><span class="line">    alert(1);</span><br><span class="line">&#125;;</span><br><span class="line">window.onload &#x3D; (window.onload || function()&#123;&#125;).before(function()&#123;</span><br><span class="line">    alert(0);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">window.onload &#x3D; (window.onload || function()&#123;&#125;).after(function()&#123;</span><br><span class="line">    alert(2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用 AOP 的方式显然是耦合度最低的非侵入式做法，代码也优雅很多，那我们来分析一下这两个函数的实现原理，以便今后我们可以自己写出这样的方法。</p><p>下面我们来逐行地分析一下这两个方法，首先来看 <code>before</code> 函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.before &#x3D; function(func) &#123;</span><br><span class="line">    var __self &#x3D; this; &#x2F;&#x2F;使用中间变量 __self 保存了 this 指针，此时的 this 指向调用者，也就是 onload 方法</span><br><span class="line">    return function() &#123; &#x2F;&#x2F;返回一个函数</span><br><span class="line">        if (func.apply(this, arguments) &#x3D;&#x3D;&#x3D; false) &#123;</span><br><span class="line">            &#x2F;&#x2F;使用 apply 函数用 this 指针调用 func，因为这时候这个函数已经被赋值给 window.onload，所以这时候的 this 指向的是 window 对象，</span><br><span class="line">            &#x2F;&#x2F;这里其实是 window.func(arguments);</span><br><span class="line">            &#x2F;&#x2F;如果返回值是非 false 的返回值，就继续执行下一步，这个 false 是应该在 before 函数中返回的，用于控制是否继续执行原始的 onload 方法。</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return __self.apply(this, arguments); &#x2F;&#x2F;如果返回值不是 flase，这里就直接使用 this 指向的 window 对象调用保存的 onload 方法，实现对原始 window.onload 的调用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Function.prototype.after &#x3D; function(func) &#123;</span><br><span class="line">    var __self &#x3D; this; &#x2F;&#x2F;使用中间变量 __self 保存了 this 指针，此时的 this 指向调用者，也就是 onload 方法</span><br><span class="line">    return function() &#123; &#x2F;&#x2F;返回一个函数</span><br><span class="line">        var ret &#x3D; __self.apply(this, arguments); &#x2F;&#x2F;直接使用 this 指针指向的 window 对象调用 onload 方法，实现 window 对 onload 方法的原始调用。并取方法调用的返回值。</span><br><span class="line">        if (ret &#x3D;&#x3D;&#x3D; false) &#123; &#x2F;&#x2F;如果onload 方法中没有返回 false，则说明，onload 方法中允许执行后续的方法。继续执行后续步骤</span><br><span class="line">            return false; &#x2F;&#x2F;否则就终止方法调用并且返回 false；</span><br><span class="line">        &#125;</span><br><span class="line">        func.apply(this, arguments); &#x2F;&#x2F;这时的 this 指针指向 window 对象，使用 window 对象调用 func</span><br><span class="line">        &#x2F;&#x2F;其实是 window.func(arguments);</span><br><span class="line">        return ret; &#x2F;&#x2F;返回返回值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在本例中我们又一次看到了 ES 中 apply 的强大动态特性，很类似于 OC 中的 Swizzle<br>，动态的交换方法的实现，来实现非侵入的在方法的前后插入逻辑的动态装饰功能。</p><p>其实 AOP 实现的是一个拦截程序生命周期的方法，通过拦截程序的生命周期来对不同的功能实现解耦。它的实现依赖动态语言的运行时特性，通过使用这些特性来让代码变得更加优雅，可维护性更好。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 javscript 中 AOP 的使用会带来很多方便，在程序的结构上实现了解耦，代码逻辑更加清晰。使用 AOP 我们还可以对逻辑进行非侵入性的改造，下面来看下用法：&lt;/p&gt;
&lt;h3 id=&quot;用于非侵入的插入逻辑&quot;&gt;&lt;a href=&quot;#用于非侵入的插入逻辑&quot; class=&quot;headerlink&quot; title=&quot;用于非侵入的插入逻辑&quot;&gt;&lt;/a&gt;用于非侵入的插入逻辑&lt;/h3&gt;&lt;p&gt;before 函数&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Function.prototype.before &amp;#x3D; function(func) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var __self &amp;#x3D; this;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (func.apply(this, arguments) &amp;#x3D;&amp;#x3D; false) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return __self.apply(this, arguments);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;after 函数&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Function.prototype.after &amp;#x3D; function(func) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var __self &amp;#x3D; this;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var ret &amp;#x3D; __self.apply(this, arguments);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (ret &amp;#x3D;&amp;#x3D;&amp;#x3D; false) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        func.apply(this, arguments);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return ret;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://ufolux.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Webpack入门</title>
    <link href="https://ufolux.github.io/2016/08/26/Front_End/tools/introduce-webpack/"/>
    <id>https://ufolux.github.io/2016/08/26/Front_End/tools/introduce-webpack/</id>
    <published>2016-08-26T09:49:57.000Z</published>
    <updated>2021-03-11T07:20:00.098Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="如何使用-Webpack"><a href="#如何使用-Webpack" class="headerlink" title="如何使用 Webpack"></a>如何使用 Webpack</h2><ol><li>首先安装 Webpack 和 webpack-dev-server<br><code>$ npm i -g webpack webpack-dev-server</code>（webpack-dev-server 是用来在本地启动服务器方便本地调试而安装的）</li><li>运行 <code>$ webpack -h</code> 命令可以显示帮助信息，说明 webpack 已经安装完成。</li></ol><blockquote><p>在常规项目开发中，更好的做法是将 webpack 直接写入 package.json 中方便维护<br><code>$ npm init$ npm i webpack --save-dev</code></p></blockquote><span id="more"></span><h2 id="Webpack是个啥？"><a href="#Webpack是个啥？" class="headerlink" title="Webpack是个啥？"></a>Webpack是个啥？</h2><p>webpack 是一个类似 Gulp 和 Grunt 的前端构建工具，它可以用来进行代码和资源的模块化，使用者可以使用它对项目方便地进行依赖管理；可以使用 <a href="http://madscript.com/html5/datauri-best-practice/">Data URI</a> 来替换体积较小的图片文件，来提升图片的加载速度。除此之外，还可以使用自定义的插件对项目进行自动化构建操作。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>每个项目下都必须配置有一个 webpack.config.js，它的作用如同 gulpfile.js/Gruntfile.js ，告诉 webpack 它需要做什么。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">var webpack &#x3D; require(&#39;webpack&#39;);</span><br><span class="line">var commonsPlugin &#x3D; new webpack.optimize.CommonsChunkPlugin(&#39;common.js&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F;插件项</span><br><span class="line">    plugins: [commonsPlugin],</span><br><span class="line">    &#x2F;&#x2F;页面入口文件配置</span><br><span class="line">    entry: &#123;</span><br><span class="line">        page1 : &#39;.&#x2F;src&#x2F;js&#x2F;page&#x2F;page1.js&#39;,&#x2F;&#x2F;支持数组类型</span><br><span class="line">        page2 : [&#39;.&#x2F;src&#x2F;js&#x2F;page&#x2F;page2.js&#39;,&#39;.&#x2F;src&#x2F;js&#x2F;page&#x2F;page3.js&#39;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F;入口文件输出配置</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: &#39;dist&#x2F;js&#x2F;page&#39;,&#x2F;&#x2F;可以省略，默认输出在配置文件的目录下</span><br><span class="line">        filename: &#39;[name].js&#39;&#x2F;&#x2F;name就是entry中的key</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        &#x2F;&#x2F;加载器配置</span><br><span class="line">        loaders: [</span><br><span class="line">            &#x2F;&#x2F;test配置要匹配的文件后缀，loader配置要是用的加载器（用!来分割多个加载器，以下代码中的-loader可以不写，?来为加载器传入参数）</span><br><span class="line">            &#123; test: &#x2F;\.css$&#x2F;, loader: &#39;style-loader!css-loader&#39; &#125;,</span><br><span class="line">            &#x2F;&#x2F;.js 文件使用 jsx-loader 来编译处理</span><br><span class="line">            &#123; test: &#x2F;\.js$&#x2F;, loader: &#39;jsx-loader?harmony&#39; &#125;,</span><br><span class="line">            &#x2F;&#x2F;.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理</span><br><span class="line">            &#123; test: &#x2F;\.scss$&#x2F;, loader: &#39;style!css!sass?sourceMap&#39;&#125;,</span><br><span class="line">            &#x2F;&#x2F;图片文件使用 url-loader 来处理，小于8kb的直接转为base64</span><br><span class="line">            &#123; test: &#x2F;\.(png|jpg)$&#x2F;, loader: &#39;url-loader?limit&#x3D;8192&#39;&#125;</span><br><span class="line">            </span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F;其它解决方案配置</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        &#x2F;&#x2F;配置查找 module 的根路径</span><br><span class="line">        root: &#39;&#x2F;User&#x2F;github&#x2F;example&#x2F;src&#39;, &#x2F;&#x2F;绝对路径</span><br><span class="line">        &#x2F;&#x2F;配置支持自动扩展的文件名后缀，require 的时候就不需要写这些文件的后缀名了</span><br><span class="line">        extensions: [&#39;&#39;, &#39;.js&#39;, &#39;.json&#39;, &#39;.scss&#39;],</span><br><span class="line">        &#x2F;&#x2F;配置模块的别名，方便直接进行加载,</span><br><span class="line">        &#x2F;&#x2F;eg: require(&#39;AppStore&#39;) &#x3D; require(&#39;js&#x2F;stores&#x2F;AppStores.js&#39;)</span><br><span class="line">        alias: &#123;</span><br><span class="line">            AppStore : &#39;js&#x2F;stores&#x2F;AppStores.js&#39;,</span><br><span class="line">            ActionType : &#39;js&#x2F;actions&#x2F;ActionType.js&#39;,</span><br><span class="line">            AppAction : &#39;js&#x2F;actions&#x2F;AppAction.js&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F;如果需要使用外部资源的时候，先在HTML里面加入script标签引入外部资源，然后在externals里面进行配置</span><br><span class="line">    externals: &#123;</span><br><span class="line">        &#x2F;&#x2F; jquery 引用自外部模块的，在这里配置了之后就可以直接在代码里面使用 require(&#39;jquery&#39;) 了</span><br><span class="line">        &#x2F;&#x2F; 但是要注意使用外部资源的 js 需要放在外部资源加载之后再进行加载</span><br><span class="line">        &#x2F;&#x2F; 对应全局变量 jQuery</span><br><span class="line">        &quot;jquery&quot;: &quot;jQuery&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用到加载器的时候需要先进行安装，比如我们用到的 <code>url-loader</code> 需要使用<br><code>$ npm i url-loader --save-dev</code> 来安装之后再可以在 webpack 中使用。</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>直接执行 <code>$ webpack --display-error-details</code> 命令就可以运行 webpack 了，后面的参数是用来显示错误信息而添加的，方便 debug 的时候查找错误的来源。</p><p>其他主要的参数有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ webpack --config XXX.js   &#x2F;&#x2F;使用另一份配置文件（比如webpack.config2.js）来打包</span><br><span class="line"></span><br><span class="line">$ webpack --watch   &#x2F;&#x2F;监听变动并自动打包</span><br><span class="line"></span><br><span class="line">$ webpack -p    &#x2F;&#x2F;生产版本构建，压缩混淆脚本</span><br><span class="line"></span><br><span class="line">$ webpack -d    &#x2F;&#x2F;生成map映射文件，告知哪些模块被最终打包到哪里了</span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>github 上有一个外国人做的 webpack demo，栗子很多，适合入门学习<br>地址：<a href="https://github.com/ruanyf/webpack-demos">https://github.com/ruanyf/webpack-demos</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://madscript.com/html5/datauri-best-practice/">Data URI</a> 一种加快图片加载的方式（基于 base64 编码数据和 cpu 实时演算）</li><li><a href="http://www.cnblogs.com/vajoy/p/4650467.html">一小时包教会 —— webpack 入门指南</a></li><li><a href="http://www.cnblogs.com/sunshq/p/5073301.html">Webpack打包进阶</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;如何使用-Webpack&quot;&gt;&lt;a href=&quot;#如何使用-Webpack&quot; class=&quot;headerlink&quot; title=&quot;如何使用 Webpack&quot;&gt;&lt;/a&gt;如何使用 Webpack&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;首先安装 Webpack 和 webpack-dev-server&lt;br&gt;&lt;code&gt;$ npm i -g webpack webpack-dev-server&lt;/code&gt;（webpack-dev-server 是用来在本地启动服务器方便本地调试而安装的）&lt;/li&gt;
&lt;li&gt;运行 &lt;code&gt;$ webpack -h&lt;/code&gt; 命令可以显示帮助信息，说明 webpack 已经安装完成。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;在常规项目开发中，更好的做法是将 webpack 直接写入 package.json 中方便维护&lt;br&gt;&lt;code&gt;$ npm init
$ npm i webpack --save-dev&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="工具" scheme="https://ufolux.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中4种常见的内存泄露陷阱</title>
    <link href="https://ufolux.github.io/2016/05/19/Front_End/js-fondation/four-memory-leak-situation-in-js-code/"/>
    <id>https://ufolux.github.io/2016/05/19/Front_End/js-fondation/four-memory-leak-situation-in-js-code/</id>
    <published>2016-05-19T07:01:59.000Z</published>
    <updated>2021-03-11T07:20:00.096Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>了解 JavaScript 的内存泄露和解决方式！</p><p>在这篇文章中我们将要探索客户端 JavaScript 代码中常见的一些内存泄漏的情况，并且学习如何使用 Chrome 的开发工具来发现他们。我们继续这个旅程！</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>内存泄露是每个开发者最终都不得不面对的问题。即便使用自动内存管理的语言，你还是会碰到一些内存泄漏的情况。内存泄露往往是其他一票问题的元凶，比如：运行缓慢，崩溃，高延迟，甚至一些与其他应用相关的问题。</p><span id="more"></span><h2 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h2><p>本质上来讲，内存泄露是当一块内存不再被应用使用的时候，出于某种原因，这块内存没有返还给操作系统或者被送入可用内存池中的现象。编程语言使用不同的方式来管理内存。这些方式可能可以减少内存泄露的机会。然而，判断某一块具体的内存是否被使用实际上是一个不可判定问题（undecidable problem）。换句话说，只有开发者可以搞清楚一块内存是否应该被操作系统回收。某些编程语言提供了帮助开发者来处理这件事情的特性。维基百科上有几篇写的不错的讲述<a href="https://en.wikipedia.org/wiki/Manual_memory_management">手动</a>和<a href="https://en.wikipedia.org/wiki/Manual_memory_management">自动</a>内存管理的文章。</p><h2 id="Javascript-的内存管理"><a href="#Javascript-的内存管理" class="headerlink" title="Javascript 的内存管理"></a>Javascript 的内存管理</h2><p>Javascript 是那些被称作垃圾收集语言当中的一员。垃圾收集语言通过周期性地检查那些之前被分配出去的内存是否可以从应用的其他部分到达来帮助开发者管理内存。换句话说，垃圾收集语言将内存管理的问题从“什么样的内存是仍然被使用的？”简化成为“什么样的内存时仍然可以从应用的其他部分到达的？”。两者的区别是细微的，但是很重要：开发者只需要知道一块已分配的内存是否会在将来被使用，而不可达的内存可以通过算法确定并标记以便返还给操作系统。</p><blockquote><p>非垃圾收集的语言通常使用其他的技术来管理内存，包括：显式内存管理，程序员显式地告诉编译器在何时不再需要某块内存；引用计数，一个计数器关联着每个内存块（当计数器的计数变为0的时候，这块内存就被操作系统回收）。这些技术都有它们的折中考虑（也就是说都有潜在的内存泄漏风险）。</p></blockquote><h2 id="Javascript-中的内存泄露"><a href="#Javascript-中的内存泄露" class="headerlink" title="Javascript 中的内存泄露"></a>Javascript 中的内存泄露</h2><p>引起垃圾收集语言内存泄露的主要原因是不需要的引用。想要理解什么是不需要的引用，首先我们需要理解一个垃圾收集器是怎样决定一块内存是否可达的。</p><h3 id="Mark-and-sweep"><a href="#Mark-and-sweep" class="headerlink" title="Mark-and-sweep"></a>Mark-and-sweep</h3><p>大多数的垃圾收集器使用一个叫做 mark-and-sweep 的算法。这个算法由以下的几个步骤组成：</p><p>垃圾收集器建立了一个“根节点”列表。根节点通常是那些引用被保留在代码中的全局变量。对于 Javascript 而言，“Window” 对象就是一个能作为根节点的全局变量例子。window 对象是一直都存在的（即：不是垃圾）。所有根节点都是检查过的并且被标记为活动的（即：不是垃圾）。所有的孩子节点也都被递归地检查过。每块可以从根节点到达的内存都不会被视为垃圾。<br>所有没有被标记为垃圾的内存现在可以被当做垃圾，而垃圾收集器也可以释放这些内存并将它们返还给操作系统。现代垃圾收集器使用不同的方式来改进这些算法，但是它们都有相同的本质：可以到达的内存块被标记为非垃圾而其余的就被视为垃圾。</p><p>不需要的引用是那些程序员知道不再需要这块内存了，但是出于某种原因这块内存依然存在于活跃的根节点发出的节点树中。对于 Javascript 来讲，不需要的引用是那些被某些不再会被使用的代码持有的变量。这些变量指向了一块内存，否则就会被释放。一些人认为这是程序员的失误。</p><p>所以想要理解什么是 Javascript 中最常见的内存泄露，我们需要知道在什么情况下引用会被忘记。</p><h2 id="3-种常见的-Javascript-内存泄露"><a href="#3-种常见的-Javascript-内存泄露" class="headerlink" title="3 种常见的 Javascript 内存泄露"></a>3 种常见的 Javascript 内存泄露</h2><h3 id="1-意外的全局变量"><a href="#1-意外的全局变量" class="headerlink" title="1: 意外的全局变量"></a>1: 意外的全局变量</h3><p>Javascript 语言的设计目标之一是开发一种类似于 Java 但是对初学者十分友好的语言。体现 JavaScript 宽容性的一点表现在它处理未声明变量的方式上：一个未声明变量的引用会在全局对象中创建一个新的变量。在浏览器的环境下，全局对象就是 window，也就是说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function foo(arg) &#123;</span><br><span class="line">    bar &#x3D; &quot;this is a hidden global variable&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function foo(arg) &#123;</span><br><span class="line">    window.bar &#x3D; &quot;this is an explicit global variable&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 bar 是一个应该指向 foo 函数作用域内变量的引用，但是你忘记使用 var 来声明这个变量，这时一个全局变量就会被创建出来。在这个例子中，泄露一个简单的字符串不会造成很大的害处，但这无疑是错误的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    this.variable &#x3D; &quot;potential accidental global&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Foo called on its own, this points to the global object (window)</span><br><span class="line">&#x2F;&#x2F; rather than being undefined.</span><br><span class="line">&#x2F;&#x2F; 函数自身发生了调用，this 指向全局对象（window），（译者注：这时候会为全局对象 window 添加一个 variable 属性）而不是 undefined。</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><blockquote><p>为了防止这种错误的发生，可以在你的 JavaScript 文件开头添加 <code>&#39;use strict&#39;;</code> 语句。这个语句实际上开启了解释 JavaScript 代码的严格模式，这种模式可以避免创建意外的全局变量。</p></blockquote><p><strong>全局变量的注意事项</strong></p><p>尽管我们在讨论那些隐蔽的全局变量，但是也有很多被显式的全局变量污染的代码的例子。按照定义来讲，这些都是不会被回收的变量（除非置 null 或者被重新赋值）。特别需要注意的是那些被用来临时存储和处理一些大量的信息的全局变量。如果你必须使用全局变量来存储很多的数据，请确保在使用过后将它置为 null 或者将它重新赋值。常见的和全局变量相关的引发内存消耗增长的原因就是缓存。缓存存储着可复用的数据。为了让这种做法更高效，必须为缓存的容量规定一个上界。由于缓存不能被及时回收的缘故，缓存无限制地增长会导致很高的内存消耗。</p><h3 id="2-被遗忘的-timer-和回调"><a href="#2-被遗忘的-timer-和回调" class="headerlink" title="2: 被遗忘的 timer 和回调"></a>2: 被遗忘的 timer 和回调</h3><p>在 JavaScript 中 setInterval 的使用十分常见。其他的库也经常会提供观察者和其他需要回调的功能。这些库中的绝大部分都会关注一点，就是当它们本身的实例被销毁之前销毁所有指向回调的引用。在 setInterval 这种情况下，一般情况下的代码是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var someResource &#x3D; getData();</span><br><span class="line">setInterval(function() &#123;</span><br><span class="line">    var node &#x3D; document.getElementById(&#39;Node&#39;);</span><br><span class="line">    if(node) &#123;</span><br><span class="line">        &#x2F;&#x2F; Do stuff with node and someResource.</span><br><span class="line">        node.innerHTML &#x3D; JSON.stringify(someResource));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure><p>这个例子说明了悬垂的 timer 会让这里发生什么：保留了节点或者数据的引用的 timer 失效了，那些节点表示的对象在将来会被移除掉。所以将整个代码块放在 interval 的处理函数中并不是必要的。然而，由于 interval 仍然没有失效，处理函数并不会被回收（只有 interval 停止运行之后才会开始回收内存）。如果 interval 的处理函数不能被回收，它的依赖们也同样无法被回收。这意味着一些资源，也许是一些相当大的数据都也无法被回收。</p><p>下面举一个观察者的例子，当它们不再被需要的时候（或者关联对象将要失效的时候）显式地将他们移除是十分重要的。在以前，尤其是对于某些浏览器（IE6 你懂得）是一个至关重要的步骤，因为它们不能很好地管理循环引用（下面的代码描述了更多的细节）。现在，当观察者对象失效的时候便会被回收，即便 listener 没有被显式的移除，绝大多数的浏览器可以或者将会支持这个特性。尽管如此，在对象被销毁之前移除观察者依然是一个好的实践。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var element &#x3D; document.getElementById(&#39;button&#39;);</span><br><span class="line"></span><br><span class="line">function onClick(event) &#123;</span><br><span class="line">    element.innerHtml &#x3D; &#39;text&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">element.addEventListener(&#39;click&#39;, onClick);</span><br><span class="line">&#x2F;&#x2F; Do stuff</span><br><span class="line">element.removeEventListener(&#39;click&#39;, onClick);</span><br><span class="line">element.parentNode.removeChild(element);</span><br><span class="line">&#x2F;&#x2F; Now when element goes out of scope,</span><br><span class="line">&#x2F;&#x2F; both element and onClick will be collected even in old browsers that don&#39;t</span><br><span class="line">&#x2F;&#x2F; handle cycles well.</span><br></pre></td></tr></table></figure><p><strong>对象观察者和循环引用中一些需要注意的点</strong></p><p>观察者和循环引用常常会让 JavaScript 开发者踩坑。以前在 IE 浏览器的垃圾回收器上会导致一个 bug（或者说是浏览器设计上的问题）。旧版本的 IE 浏览器不会发现 DOM 节点和 JavaScript 代码之间的循环引用。这是一种观察者的典型情况，观察者通常保留着一个被观察者的引用（正如上述例子中描述的那样）。换句话说，在 IE 浏览器中，每当一个观察者被添加到一个节点上时，就会发生一次内存泄漏。这也就是开发者在节点或者空的引用被添加到观察者中之前显式移除处理方法的原因。目前，现代的浏览器（包括 IE 和 Microsoft Edge）都使用了可以发现这些循环引用并正确的处理它们的现代化垃圾回收算法。换言之，严格地讲，在废弃一个节点之前调用 removeEventListener 不再是必要的操作。</p><p>像是 jQuery 这样的框架和库（当使用一些特定的 API 时候）都在废弃一个结点之前都做将了监听者移除的操作。它们在内部就已经处理了这些事情，并且保证不会产生内存泄露，即便程序运行在那些问题很多的浏览器中，比如老版本的 IE。</p><h3 id="3-DOM-之外的引用"><a href="#3-DOM-之外的引用" class="headerlink" title="3: DOM 之外的引用"></a>3: DOM 之外的引用</h3><p>有些情况下将 DOM 结点存储到数据结构中会十分有用。假设你想要快速地更新一个表格中的几行，如果你把每一行的引用都存储在一个字典或者数组里面会起到很大作用。如果你这么做了，程序中将会保留同一个结点的两个引用：一个引用存在于 DOM 树中，另一个被保留在字典中。如果在未来的某个时刻你决定要将这些行移除，则需要将所有的引用清除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var elements &#x3D; &#123;</span><br><span class="line">    button: document.getElementById(&#39;button&#39;),</span><br><span class="line">    image: document.getElementById(&#39;image&#39;),</span><br><span class="line">    text: document.getElementById(&#39;text&#39;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function doStuff() &#123;</span><br><span class="line">    image.src &#x3D; &#39;http:&#x2F;&#x2F;some.url&#x2F;image&#39;;</span><br><span class="line">    button.click();</span><br><span class="line">    console.log(text.innerHTML);</span><br><span class="line">    &#x2F;&#x2F; Much more logic</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function removeButton() &#123;</span><br><span class="line">    &#x2F;&#x2F; The button is a direct child of body.</span><br><span class="line">    document.body.removeChild(document.getElementById(&#39;button&#39;));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; At this point, we still have a reference to #button in the global</span><br><span class="line">    &#x2F;&#x2F; elements dictionary. In other words, the button element is still in</span><br><span class="line">    &#x2F;&#x2F; memory and cannot be collected by the GC.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以要这么做的，还考虑到另一种情况，假设你在 JavaScript 代码中保留了一个表格中特定单元格(一个 <td> 标签)的引用。在将来你决定将这个表格从 DOM 中移除，但是仍旧保留这个单元格的引用。凭直觉，你可能会认为 GC 会回收除了这个单元格之外所有的东西，但是实际上这并不会发生：单元格是表格的一个子节点且所有子节点都保留着它们父节点的引用。换句话说，JavaScript 代码中对单元格的引用导致整个表格被保留在内存中。所以当你想要保留 DOM 元素的引用时，要仔细的考虑清除这一点。</td></p><h3 id="4-闭包"><a href="#4-闭包" class="headerlink" title="4: 闭包"></a>4: 闭包</h3><p>JavaScript 开发中一个重要的内容就是闭包，它是可以捕获父作用域的匿名函数。Meteor 的开发者发现一个特殊的情况下有可能会以一种很微妙的方式产生内存泄漏，这取决于 JavaScript 运行时的实现细节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var theThing &#x3D; null;</span><br><span class="line">var replaceThing &#x3D; function () &#123;</span><br><span class="line">  var originalThing &#x3D; theThing;</span><br><span class="line">  var unused &#x3D; function () &#123;</span><br><span class="line">    if (originalThing)</span><br><span class="line">      console.log(&quot;hi&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">  theThing &#x3D; &#123;</span><br><span class="line">    longStr: new Array(1000000).join(&#39;*&#39;),</span><br><span class="line">    someMethod: function () &#123;</span><br><span class="line">      console.log(someMessage);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">setInterval(replaceThing, 1000);</span><br></pre></td></tr></table></figure><p>这段代码做了一件事：每次调用 <code>replaceThing</code> 时，<code>theThing</code> 都会得到新的包含一个大数组和新的闭包（<code>someMethod</code>）的对象。同时，没有用到的那个变量持有一个引用了 <code>originalThing</code>（<code>replaceThing</code> 调用之前的 <code>theThing</code>）闭包。哈，是不是已经有点晕了？关键的问题是每当在同一个父作用域下创建闭包作用域的时候，这个作用域是被共享的。在这种情形下，<code>someMethod</code> 的闭包作用域和 <code>unused</code> 的作用域是共享的。<code>unused</code> 持有一个 <code>originalThing</code> 的引用。尽管 <code>unused</code> 从来没有被使用过，<code>someMethod</code> 可以在 <code>theThing</code> 之外被访问。而且 <code>someMethod</code> 和 <code>unused</code> 共享了闭包作用域，即便 <code>unused</code> 从来都没有被使用过，它对 <code>originalThing</code> 的引用还是强制它保持活跃状态（阻止它被回收）。当这段代码重复地运行时，将可以观察到内存消耗稳定地上涨，并且不会因为 GC 的存在而下降。本质上来讲，创建了一个闭包链表（根节点是 <code>theThing</code> 形式的变量），而且每个闭包作用域都持有一个对大数组的间接引用，这导致了一个巨大的内存泄露。</p><blockquote><p>这是一个由人来决定的实现。可以想到一个能够解决这个问题的不同的闭包实现，就像 Metero 的<a href="http://info.meteor.com/blog/an-interesting-kind-of-javascript-memory-leak">博客</a>里面说的那样。</p></blockquote><h2 id="垃圾收集器的直观行为"><a href="#垃圾收集器的直观行为" class="headerlink" title="垃圾收集器的直观行为"></a>垃圾收集器的直观行为</h2><p>尽管垃圾收集器是便利的，但是使用它们也需要有一些利弊权衡。其中之一就是不确定性。也就是说，GC 的行为是不可预测的。通常情况下都不能确定什么时候会发生垃圾回收。这意味着在一些情形下，程序会使用比实际需要更多的内存。有些的情况下，在很敏感的应用中可以观察到明显的卡顿。尽管不确定性意味着你无法确定什么时候垃圾回收会发生，不过绝大多数的 GC 实现都会在内存分配时遵从通用的垃圾回收过程模式。如果没有内存分配发生，大部分的 GC 都会保持静默。考虑以下的情形：</p><ol><li>大量内存分配发生时。</li><li>大部分（或者全部）的元素都被标记为不可达（假设我们讲一个指向无用缓存的引用置 null 的时候）。</li><li>没有进一步的内存分配发生。</li></ol><p>这个情形下，GC 将不会运行任何进一步的回收过程。也就是说，尽管有不可达的引用可以触发回收，但是收集器并不要求回收它们。严格的说这些不是内存泄露，但仍然导致高于正常情况的内存空间使用。</p><p>Google 在它们的 JavaScript 内存分析文档中提供一个关于这个行为的优秀例子，见<a href="https://developer.chrome.com/devtools/docs/demos/memory/example2">例子#2</a>.</p><h2 id="Chrome-内存分析工具简介"><a href="#Chrome-内存分析工具简介" class="headerlink" title="Chrome 内存分析工具简介"></a>Chrome 内存分析工具简介</h2><p>Chrome 提供了一套很好的工具用来分析 JavaScript 的内存适用。这里有两个与内存相关的重要视图：timeline 视图和 profiles 视图。</p><h3 id="Timeline-view"><a href="#Timeline-view" class="headerlink" title="Timeline view"></a>Timeline view</h3><p><img src="http://skyfly.xyz/images/4TypesLeakInJS/timeline.png" alt="timeline"></p><p>timeline 视图是我们用于发现不正常内存模式的必要工具。当我们寻找严重的内存泄漏时，内存回收发生后产生的周期性的不会消减的内存跳跃式增长会被一面红旗标记。在这个截图里面我们可以看到，这很像是一个稳定的对象内存泄露。即便最后经历了一个很大的内存回收，它占用的内存依旧比开始时多得多。节点数也比开始要高。这些都是代码中某处 DOM 节点内存泄露的标志。</p><h3 id="Profiles-视图"><a href="#Profiles-视图" class="headerlink" title="Profiles 视图"></a>Profiles 视图</h3><p><img src="http://skyfly.xyz/images/4TypesLeakInJS/profiles.png" alt="Profiles"></p><p>你将会花费大部分的时间在观察这个视图上。profiles 视图让你可以对 JavaScript 代码运行时的内存进行快照，并且可以比较这些内存快照。它还让你可以记录一段时间内的内存分配情况。在每一个结果视图中都可以展示不同类型的列表，但是对我们的任务最有用的是 summary 列表和 comparison 列表。</p><h2 id="栗子-使用-Chrome-来发现内存泄露"><a href="#栗子-使用-Chrome-来发现内存泄露" class="headerlink" title="栗子: 使用 Chrome 来发现内存泄露"></a>栗子: 使用 Chrome 来发现内存泄露</h2><p>有两个重要类型的内存泄露：引起内存周期性增长的泄露和只发生一次且不引起更进一步内存增长的泄露。显而易见的是，寻找周期性的内存泄漏是更简单的。这些也是最麻烦的事情：如果内存会按时增长，泄露最终将导致浏览器变慢或者停止执行脚本。很明显的非周期性大量内存泄露可以很容易的在其他内存分配中被发现。但是实际情况并不如此，往往这些泄露都是不足以引起注意的。这种情况下，小的非周期性内存泄露可以被当做一个优化点。然而那些周期性的内存泄露应该被视为 bug 并且必须被修复。</p><p>为了举例，我们将会使用 Chrome 的文档中提供的一个例子。完整的代码在下面可以找到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; [];</span><br><span class="line"></span><br><span class="line">function createSomeNodes() &#123;</span><br><span class="line">    var div,</span><br><span class="line">        i &#x3D; 100,</span><br><span class="line">        frag &#x3D; document.createDocumentFragment();</span><br><span class="line">    for (;i &gt; 0; i--) &#123;</span><br><span class="line">        div &#x3D; document.createElement(&quot;div&quot;);</span><br><span class="line">        div.appendChild(document.createTextNode(i + &quot; - &quot;+ new Date().toTimeString()));</span><br><span class="line">        frag.appendChild(div);</span><br><span class="line">    &#125;</span><br><span class="line">    document.getElementById(&quot;nodes&quot;).appendChild(frag);</span><br><span class="line">&#125;</span><br><span class="line">function grow() &#123;</span><br><span class="line">    x.push(new Array(1000000).join(&#39;x&#39;));</span><br><span class="line">    createSomeNodes();</span><br><span class="line">    setTimeout(grow,1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用 grow 的时候，它会开始创建 div 节点并且把他们追加到 DOM 上。它将会分配一个大数组并将它追加到一个全局数组中。这将会导致内存的稳定增长，使用上面提到的工具可以观察到这一点。</p><blockquote><p>垃圾收集语言通常表现出内存用量的抖动。如果代码在一个发生分配的循环中运行时，这是很常见的。我们将要寻找那些在内存分配之后周期性且不会回落的内存增长。</p></blockquote><h3 id="查看内存是否周期性增长"><a href="#查看内存是否周期性增长" class="headerlink" title="查看内存是否周期性增长"></a>查看内存是否周期性增长</h3><p>对于这个问题，timeline 视图最合适不过了。在 Chrome 中运行这个例子，打开开发者工具，定位到 timeline，选择内存并且点击记录按钮。然后去到那个页面点击按钮开始内存泄露。一段时间后停止记录，然后观察结果：</p><p><img src="http://skyfly.xyz/images/4TypesLeakInJS/example-timeline.png" alt="Memory leaks in the timeline view"></p><blockquote><p>这个例子中每秒都会发生一次内存泄露。记录停止后，在 grow 函数中设置一个断点来防止 Chrome 强制关闭这个页面。</p></blockquote><p>在图中有两个明显的标志表明我们正在泄漏内存。节点的图表（绿色的线）和 JS 堆内存（蓝色的线）。节点数稳定地增长并且从不减少。这是一个明显的警告标志。</p><p>JS 堆内存表现出稳定的内存用量增长。由于垃圾回收器的作用，这很难被发现。你能看到一个初始内存的增长的图线，紧接着有一个很大的回落，接着又有一段增长然后出现了一个峰值，接着又是一个回落。这个情况的关键是在于一个事实，即每次内存用量回落时候，堆内存总是比上一次回落后的内存占用量更多。也就是说，尽管垃圾收集器成功地回收了很多的内存，还是有一部分内存周期性的泄露了。</p><p>我们现在确定程序中有一个泄露，让我们一起找到它。</p><h3 id="拍两个快照"><a href="#拍两个快照" class="headerlink" title="拍两个快照"></a>拍两个快照</h3><p>为了找到这个内存泄漏，我们将使用 Chrome 开发者工具红的 profiles 选项卡。为了保证内存的使用在一个可控制的范围内，在做这一步之前刷新一下页面。我们将使用 Take Heap Snapshot 功能。</p><p>刷新页面，在页面加载结束后为堆内存捕获一个快照。我们将要使用这个快照作为我们的基准。然后再次点击按钮，等几秒，然后再拍一个快照。拍完照后，推荐的做法是在脚本中设置一个断点来停止它的运行，防止更多的内存泄露。</p><p><img src="http://skyfly.xyz/images/4TypesLeakInJS/example-snapshots-1.png" alt="Heap Snapshots"></p><p>有两个方法来查看两个快照之间的内存分配情况，其中一种方法需要选择 Summary 然后在右面选取在快照1和快照2之间分配的对象，另一种方法，选择 Comparison 而不是 Summary。两种方法下，我们都将会看到一个列表，列表中展示了在两个快照之间分配的对象。</p><p>本例中，我们很容易就可以找到内存泄露：它们很明显。看一下（string）构造器的 Size Delta。58个对象占用了8 MB 内存。这看起来很可疑：新的对象被创建，但是没有被释放导致了8 MB 的内存消耗。</p><p>如果我们打开（string）构造器分配列表，我们会注意到在很多小内存分配中掺杂着的几个大量的内存分配。这些情况立即引起了我们的注意。如果我们选择它们当中的任意一个，我们将会在下面的 retainer 选项卡中得到一些有趣的结果。</p><p><img src="http://skyfly.xyz/images/4TypesLeakInJS/example-snapshots-2.png" alt="Retainers for selected object"></p><p>我们发现我们选中的内存分配信息是一个数组的一部分。作为回报，数组被变量 x 在全局 window 对象内部引用。这给我们指引了一条从我们的大对象到不会被回收的根节点（window）的完整的路径。我们也就找到了潜在的泄漏点以及它在哪里被引用。</p><p>到现在为止，一切都很不错。但是我们的例子太简单了：像例子中这样大的内存分配并不是很常见。幸运的是我们的例子中还存在着细小的 DOM 节点内存泄漏。使用上面的内存快照可以很容易地找到这些节点，但是在更大的站点中，事情变得复杂起来。最近，新的 Chrome 的版本中提供了一个附加的工具，这个工具十分适合我们的工作，这就是堆内存分配记录（Record Heap Allocations）功能</p><h3 id="通过记录堆内存分配来发现内存泄露"><a href="#通过记录堆内存分配来发现内存泄露" class="headerlink" title="通过记录堆内存分配来发现内存泄露"></a>通过记录堆内存分配来发现内存泄露</h3><p>取消掉你之前设置的断点让脚本继续运行，然后回到开发者工具的 Profiles 选项卡。现在点击 Record Heap Allocations。当工具运行时候你将注意到图表顶部的蓝色突起。这些代表着内存分配。我们的代码导致每秒钟都有一个大的内存分配发生。让它运行几秒然后让程序停止（不要忘记在此设置断点来防止 Chrome 吃掉过多的内存）。</p><p><img src="http://skyfly.xyz/images/4TypesLeakInJS/example-recordedallocs-overview.png" alt="Recorded heap allocations"></p><p>在这张图中你能看到这个工具的杀手锏：选择时间线中的一片来观察在这段时间片中内存分配发生在什么地方。我们将时间片设置的尽量与凸起接近。只有三个构造器在这个列表中显示出来：一个是与我们的大泄露有关的（string），一个是和 DOM 节点的内存分配相关的，另一个是 Text 构造器（DOM 节点中的文本的构造器）。</p><p>从列表中选择一个 HTMLDivElement 构造器然后选择一个内存分配堆栈。</p><p><img src="http://skyfly.xyz/images/4TypesLeakInJS/example-recordedallocs-selected.png" alt="Selected element in heap allocation results"></p><p>啊哈！我们现在知道那些元素在什么地方被分配了（grow -&gt; createSomeNodes）。如果我们集中精神观察图像中的每个凸起，还会注意到 HTMLDivElement 的构造器被调用了很多次。如果我们回到快照比较视图就不难发现这个构造器分配了很多次内存但是没有从未释放它们。也就是说，它不断地分配内存空间，但却没有允许 GC 回收它们。种种迹象表明这是一个泄露，加上我们确切地知道这些对象被分配到了什么地方（createSomeNodes 函数）。现在应该去研究代码，并修复这个泄漏。</p><h3 id="其他有用的特性"><a href="#其他有用的特性" class="headerlink" title="其他有用的特性"></a>其他有用的特性</h3><p>在堆内存分配结果视图中我们可以使用比 Summary 更好的 Allocation 视图。</p><p><img src="http://skyfly.xyz/images/4TypesLeakInJS/example-recordedallocs-list.png" alt="Allocations in heap allocations results"></p><p>这个视图为我们呈现了一个函数的列表，同时也显示了与它们相关的内存分配情况。我们能立即看到 grow 和 createSomeNodes 凸显了出来。当选择 grow 我们看到了与它相关的对象构造器被调用的情况。我们注意到了（string），HTMLDivElement 和 Text 而现在我们已经知道是对象的构造函数被泄露了。</p><p>这些工具的组合对找到泄漏有很大帮助。和它们一起工作。为你的生产环境站点做不同的分析（最好用非最小化或未混淆代码）。看看你能不能找到那些持有了比正常情况更多内存的对象吧（提示：这些很难被找到）。</p><blockquote><p>要使用这个特性，请到Dev Tools -&gt; Settings 然后将 “record heap allocation stack traces” 启用。在记录之前必须要做这一步。</p></blockquote><h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management">Memory Management - Mozilla Developer Network</a></li><li><a href="http://javascript.crockford.com/memory/leak.html">JScript Memory Leaks - Douglas Crockford (old, in relation to Internet Explorer 6 leaks)</a></li><li><a href="https://developer.chrome.com/devtools/docs/javascript-memory-profiling">JavaScript Memory Profiling - Chrome Developer Docs</a></li><li><a href="https://developers.google.com/web/tools/chrome-devtools/profile/memory-problems/memory-diagnosis">Memory Diagnosis - Google Developers</a></li><li><a href="http://info.meteor.com/blog/an-interesting-kind-of-javascript-memory-leak">An Interesting Kind of JavaScript Memory Leak - Meteor blog</a></li><li><a href="http://mrale.ph/blog/2012/09/23/grokking-v8-closures-for-fun.html">Grokking V8 closures</a></li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在垃圾回收语言中，如 JavaScript，确实会发生内存泄露。一些情况下我们都不会意识到这些泄露，最终它们将会带来毁灭性的灾难。正是由于这个原因，使用内存分析工具来发现内存泄露是十分重要的。运行分析工具应该成为开发周期中的一部分，特别是对于中型或大型应用来讲。现在就开始这么做，尽可能地为你的用户提供最好的体验。动手吧！</p><p><a href="https://auth0.com/blog/2016/01/26/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/">查看原文</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解 JavaScript 的内存泄露和解决方式！&lt;/p&gt;
&lt;p&gt;在这篇文章中我们将要探索客户端 JavaScript 代码中常见的一些内存泄漏的情况，并且学习如何使用 Chrome 的开发工具来发现他们。我们继续这个旅程！&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;内存泄露是每个开发者最终都不得不面对的问题。即便使用自动内存管理的语言，你还是会碰到一些内存泄漏的情况。内存泄露往往是其他一票问题的元凶，比如：运行缓慢，崩溃，高延迟，甚至一些与其他应用相关的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://ufolux.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>js动态调用特性</title>
    <link href="https://ufolux.github.io/2016/04/25/Front_End/js-fondation/js-dynamic-feature/"/>
    <id>https://ufolux.github.io/2016/04/25/Front_End/js-fondation/js-dynamic-feature/</id>
    <published>2016-04-25T09:02:53.000Z</published>
    <updated>2021-03-11T07:20:00.096Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>JS 的动态调用特性是 JS 动态特性中重要的组成部分，提到这个特性就需要讲明白<code>bind</code>，<code>call</code>，<code>apply</code>这三个函数</p><h2 id="JS函数的调用机制"><a href="#JS函数的调用机制" class="headerlink" title="JS函数的调用机制"></a>JS函数的调用机制</h2><p>js 里函数调用有 4 种模式：方法调用、正常函数调用、构造器函数调用、apply/call 调用。无论哪种函数调用除了你声明时定义的形参外，还会<strong>自动添加</strong> 2 个形参，分别是 this 和 arguments。<strong>arguments 是一个 array-like 类型对象</strong>，提供了 length 和下标操作符访问元素的方法，但是却没有提供其他任何数组对象应有的方法。</p><p>this 到对象的绑定是一个超级延迟绑定，这个绑定发生在函数调用的时候，this 代表的也就是主调方对象。这实现了 JS 的强大动态特性。</p><span id="more"></span><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>如果函数是对象的属性，那么对函数的调用成为方法调用。通过对象点语法调用方法时，函数内部的 this 指针将指向对象本身。</p><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>如果函数不是对象的属性，那么对函数的调用就叫做函数调用，内部的 this 指针指向任何调用这个函数的对象，如果有如下情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function a(m) &#123;</span><br><span class="line">    this.x &#x3D; m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a(2);</span><br></pre></td></tr></table></figure><p>按照 JS 的坑爹尿性这样的调用会导致，window 对象被添加上 x 属性并被赋值为 m，这里需要谨慎。</p><h3 id="构造器函数调用"><a href="#构造器函数调用" class="headerlink" title="构造器函数调用"></a>构造器函数调用</h3><p>按照约定，构造器函数如下方式定义，通过 <code>new</code> 关键字进行调用。因为构造器函数调用会导致与其他函数调用不同的效果，所以<strong>构造器函数的首字母需要大写</strong>来和普通函数进行区分，这非常重要。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Cons &#x3D; function () &#123;</span><br><span class="line">    &#x2F;&#x2F;do something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var cons &#x3D; new Cons();</span><br></pre></td></tr></table></figure><p>使用<code>new</code>关键字调用构造器函数且返回值不是对象时，函数会背地里生成一个链接到函数 prototype 成员的新对象，同时将 this 指针绑定到这个对象上面。new 关键字也会改变 return 的语义，如果构造器函数返回值不是对象，则会返回 this 指针（即新对象）。</p><h2 id="来看这三个函数"><a href="#来看这三个函数" class="headerlink" title="来看这三个函数"></a>来看这三个函数</h2><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p>apply 接受两个参数，第一个参数是想要让 this 绑定到的对象，第二个参数是一个数组，里面存放想要传递个函数的参数。<br>使用 apply 函数，你就可以把任意的对象赋给被调函数内部的 this 指针，这样一来动态性就有变态般的提升了。<br>第一个参数为 null 时，this 指针已然是当前的 this 指向的1对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function a(xx) &#123;        </span><br><span class="line">    this.b &#x3D; xx;</span><br><span class="line">&#125;</span><br><span class="line">var o &#x3D; &#123;&#125;;</span><br><span class="line">a.apply(o, [5]);</span><br><span class="line">alert(a.b);    &#x2F;&#x2F; undefined</span><br><span class="line">alert(o.b);    &#x2F;&#x2F; 5</span><br></pre></td></tr></table></figure><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>call 和 apply 几乎相同，只是 call 的参数是不定参数，第一个参数代表的依然和 apply 一样，只是参数数组变成了多个参数的形式传入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function a(xx，yy) &#123;        </span><br><span class="line">    this.b &#x3D; xx + yy;</span><br><span class="line">&#125;</span><br><span class="line">var o &#x3D; &#123;&#125;;</span><br><span class="line">a.call(o, 5, 6);</span><br><span class="line">alert(a.b);    &#x2F;&#x2F; undefined</span><br><span class="line">alert(o.b);    &#x2F;&#x2F; 11</span><br></pre></td></tr></table></figure><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>bind 的参数和以上两个函数一致，只是不会像他们一样马上发生函数调用，bind 只是将对象绑定给 this 指针，然后返回新的函数，想什么时候调就什么时候调。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var m &#x3D; &#123;   </span><br><span class="line">    &quot;x&quot; : 1</span><br><span class="line">&#125;;</span><br><span class="line">function foo(y) &#123;</span><br><span class="line">    alert(this.x + y);</span><br><span class="line">&#125;</span><br><span class="line">foo.apply(m, [5]);</span><br><span class="line">foo.call(m, 5);</span><br><span class="line">var foo1 &#x3D; foo.bind(m, 5);</span><br><span class="line">foo1();</span><br></pre></td></tr></table></figure><p>应用：</p><p>apply，call 可以用到构造函数的继承上。<br>使用方法参见：<br><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html">http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS 的动态调用特性是 JS 动态特性中重要的组成部分，提到这个特性就需要讲明白&lt;code&gt;bind&lt;/code&gt;，&lt;code&gt;call&lt;/code&gt;，&lt;code&gt;apply&lt;/code&gt;这三个函数&lt;/p&gt;
&lt;h2 id=&quot;JS函数的调用机制&quot;&gt;&lt;a href=&quot;#JS函数的调用机制&quot; class=&quot;headerlink&quot; title=&quot;JS函数的调用机制&quot;&gt;&lt;/a&gt;JS函数的调用机制&lt;/h2&gt;&lt;p&gt;js 里函数调用有 4 种模式：方法调用、正常函数调用、构造器函数调用、apply/call 调用。无论哪种函数调用除了你声明时定义的形参外，还会&lt;strong&gt;自动添加&lt;/strong&gt; 2 个形参，分别是 this 和 arguments。&lt;strong&gt;arguments 是一个 array-like 类型对象&lt;/strong&gt;，提供了 length 和下标操作符访问元素的方法，但是却没有提供其他任何数组对象应有的方法。&lt;/p&gt;
&lt;p&gt;this 到对象的绑定是一个超级延迟绑定，这个绑定发生在函数调用的时候，this 代表的也就是主调方对象。这实现了 JS 的强大动态特性。&lt;/p&gt;
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://ufolux.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>js作用域</title>
    <link href="https://ufolux.github.io/2016/04/25/Front_End/js-fondation/js-scope/"/>
    <id>https://ufolux.github.io/2016/04/25/Front_End/js-fondation/js-scope/</id>
    <published>2016-04-25T07:46:20.000Z</published>
    <updated>2021-03-11T07:20:00.097Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>先说结论，在 JavaScript 中，作用域只有两种。<strong>全局作用域（window）</strong>和<strong>局部作用域（函数）</strong>。<br>全局作用域中的所有对象均为 window 对象的属性。局部作用域（函数）中的所有对象在整个函数范围内均是可见的，也就是说 JavaScript 没有类似其他语言中的块级作用域。</p><span id="more"></span><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>当发生变量的调用时，调用方先在当前局部作用域（作用域链的第一个对象）寻找变量，没有的话沿着作用域链向着外层局部作用域（作用域链的第二个对象）寻找变量，还没有的话就继续沿着链寻找全局变量（作用域链的最后一个对象）。</p><p>下述代码中涉及到的作用域对象分别是inner-&gt;outter-&gt;window</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> world = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> innerVar = <span class="number">4</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(hello);</span><br><span class="line">    &#125;</span><br><span class="line">    inner();    <span class="comment">//调用inner函数</span></span><br><span class="line">&#125;</span><br><span class="line">outter();    <span class="comment">//调用outter函数</span></span><br><span class="line">outter.na = <span class="string">&quot;as&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*outpout</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="函数体内部局部变量的优先级高于全局变量"><a href="#函数体内部局部变量的优先级高于全局变量" class="headerlink" title="函数体内部局部变量的优先级高于全局变量"></a>函数体内部局部变量的优先级高于全局变量</h2><p>这一点和其他语言类似，如以下代码所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="number">1</span>;    <span class="comment">//定义全局变量 hello</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> hello = <span class="number">100</span>;    <span class="comment">//定义局部变量hello</span></span><br><span class="line">    <span class="built_in">console</span>.log( hello );       <span class="comment">//打印 100</span></span><br><span class="line">&#125;</span><br><span class="line">check();</span><br><span class="line"><span class="built_in">console</span>.log( hello ); <span class="comment">//打印 1</span></span><br><span class="line"><span class="comment">/*output:</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>但需要注意的是以下代码所示的这种情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( x );        <span class="comment">//&#x27;undefined&#x27;，不是1</span></span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">&#x27;skyfly&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( x );        <span class="comment">//&#x27;skyfly&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure><p>由于 JavaScript 的解释执行机制分为两步，分别是预编译（预处理）和解释执行，在预处理的时候已经发现了局部变量 x，由于同名局部变量的优先级高于全局变量。所以在执行的时候，func 中局部变量 x 的优先级最高。预编译时期也只进行变量和函数的声明，后续的定义在执行时期才能发生。于是这里的第一个 x 是 ‘undefined’。</p><h2 id="JavaScript-不存在块级作用域"><a href="#JavaScript-不存在块级作用域" class="headerlink" title="JavaScript 不存在块级作用域"></a>JavaScript 不存在块级作用域</h2><p>如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> j = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，在函数之内的所有非嵌套函数内声明的变量均是可见的，说明 JavaScript 没有传统意义上的块级作用域。这也说明，JavaScript 只有<strong>函数</strong>和 <strong>window</strong> 作用域</p><h2 id="不以-var-声明的变量是全局变量"><a href="#不以-var-声明的变量是全局变量" class="headerlink" title="不以 var 声明的变量是全局变量"></a>不以 <code>var</code> 声明的变量是全局变量</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">100</span> <span class="comment">//在node中这个是局部变量，作用域在模块内。在浏览器中，这个是全局变量，属于window</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rain</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        b = <span class="number">100</span>;    <span class="comment">//声明了全局变量x并进行赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    rain();</span><br><span class="line">    alert( b );    <span class="comment">//会弹出100</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>没有使用 <code>var</code> 声明的变量，均为 window 作用域的全局变量，即便声明存在于函数中。</p><blockquote><p>注<br>在Node.js 的 REPL 环境下，a 是全局变量，被挂载在 global 对象之下。在 Node.js 的模块环境之下，全局变量必须<strong>显式</strong>声明称 global 对象的属性。或者不使用 var 修饰。<br>browser 下两者都会被视为全局变量。</p></blockquote><h2 id="标签的作用域"><a href="#标签的作用域" class="headerlink" title="标签的作用域"></a>标签的作用域</h2><p>标签的作用域只限于本代码块内，在全局作用域无效，也不会被块内函数继承，以下代码将报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">list: &#123;</span><br><span class="line">function breakFun () &#123;</span><br><span class="line"> break list;</span><br><span class="line"> &#125; </span><br><span class="line"> console.log(cars[0] + &quot;&lt;br&gt;&quot;);</span><br><span class="line"> console.log(cars[1] + &quot;&lt;br&gt;&quot;);</span><br><span class="line"> console.log(cars[2] + &quot;&lt;br&gt;&quot;);</span><br><span class="line"> console.log(cars[3] + &quot;&lt;br&gt;&quot;);</span><br><span class="line"> breakFun();</span><br><span class="line"> console.log(cars[4] + &quot;&lt;br&gt;&quot;);</span><br><span class="line"> console.log(cars[5] + &quot;&lt;br&gt;&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"> &#x2F;&#x2F;ERR: Undefined label &#39;list&#39;</span><br></pre></td></tr></table></figure><p>正确的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">list: &#123;</span><br><span class="line"> console.log(cars[0] + &quot;&lt;br&gt;&quot;);</span><br><span class="line"> console.log(cars[1] + &quot;&lt;br&gt;&quot;);</span><br><span class="line"> console.log(cars[2] + &quot;&lt;br&gt;&quot;);</span><br><span class="line"> console.log(cars[3] + &quot;&lt;br&gt;&quot;);</span><br><span class="line"> break list;</span><br><span class="line"> console.log(cars[4] + &quot;&lt;br&gt;&quot;);</span><br><span class="line"> console.log(cars[5] + &quot;&lt;br&gt;&quot;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>其他参见：<br><a href="http://blog.cnbang.net/tech/2025/">js函数作用域和对象作用域里变量的不同</a><br><a href="http://f2e.souche.com/blog/a-js-problem-about-global/">Node.js 启动方式：一道关于全局变量的题目引发的思考</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先说结论，在 JavaScript 中，作用域只有两种。&lt;strong&gt;全局作用域（window）&lt;/strong&gt;和&lt;strong&gt;局部作用域（函数）&lt;/strong&gt;。&lt;br&gt;全局作用域中的所有对象均为 window 对象的属性。局部作用域（函数）中的所有对象在整个函数范围内均是可见的，也就是说 JavaScript 没有类似其他语言中的块级作用域。&lt;/p&gt;
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://ufolux.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>浅析 jQuery deferred 对象</title>
    <link href="https://ufolux.github.io/2016/04/24/Front_End/js-fondation/introduce-jQuery-deferred-object/"/>
    <id>https://ufolux.github.io/2016/04/24/Front_End/js-fondation/introduce-jQuery-deferred-object/</id>
    <published>2016-04-24T09:09:29.000Z</published>
    <updated>2021-03-11T07:20:00.096Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是-deferred-对象"><a href="#什么是-deferred-对象" class="headerlink" title="什么是 deferred 对象"></a>什么是 deferred 对象</h2><p>deferred 对象是 jQuery 为操作的回调函数提供的解决方案。deferred 对象提供了链式操作来对操作进行回调处理。</p><p>deferred 对象引入了“执行状态”这个概念，一个 deferred 对象的执行状态分为三种</p><ol><li>未完成（unresolve）</li><li>已完成（resolved）</li><li>已失败（rejected）</li></ol><p>通过 deferred 对象的 resolve，reject 方法来改变执行状态从而调用与该状态绑定的回调函数（们）。</p><span id="more"></span><blockquote><p>注意：deferred 对象状态一旦被 resolve 或 reject 便不再次修改。也就是说，resolve 或者 reject 方法只能调用一次。多次调用只执行一次（jQuery 的实现是这样的，不代表所有的 deferred 实现都是如此，此行为不可预测，可能导致崩溃）</p></blockquote><h2 id="deferred-有什么好处"><a href="#deferred-有什么好处" class="headerlink" title="deferred 有什么好处"></a>deferred 有什么好处</h2><ol><li>避免了层层嵌套的“回调地狱”</li><li>提供了可以安排顺序的回调处理方式</li><li>链式操作可以让回调处理更加的自由，可添加任意个数的回调函数</li></ol><h2 id="deferred-用法"><a href="#deferred-用法" class="headerlink" title="deferred 用法"></a>deferred 用法</h2><p>定义一个 deferred 对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var wait &#x3D; function(dtd) &#123;</span><br><span class="line">var dtd &#x3D; $.Deferred();</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">this.time &#x3D; 1;</span><br><span class="line">dtd.resolve();</span><br><span class="line">&#125;, 1000);</span><br><span class="line">dtd.progress(processing);</span><br><span class="line">for (var i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">dtd.notify()</span><br><span class="line">&#125;</span><br><span class="line">return dtd.promise();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="提供-proimise"><a href="#提供-proimise" class="headerlink" title="提供 proimise()"></a>提供 proimise()</h3><p>promise() 方法实际上是在原来的 deferred 基础上返回一个只开放不能改变执行状态的方法（如 done() 和 fail() ）的 deferred 对象，使得执行状态无法被非执行者改变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var wait &#x3D; function(dtd) &#123;</span><br><span class="line">var dtd &#x3D; $.Deferred();</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">dtd.resolve();</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">return dtd.promise();</span><br><span class="line">&#125;;</span><br><span class="line">$.when(wait())</span><br><span class="line">.done(function() &#123;</span><br><span class="line">console.log(&quot;哈哈，成功了！&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.fail(function() &#123;</span><br><span class="line">console.log(&quot;出错啦！&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="为同一操作提供多种状态的回调处理"><a href="#为同一操作提供多种状态的回调处理" class="headerlink" title="为同一操作提供多种状态的回调处理"></a>为同一操作提供多种状态的回调处理</h3><p>done 处理 resolved 状态<br>fail 处理 rejected 状态</p><p>他们都可以接受参数，通过 resolve() 或者 reject() 方法将数据传递给回调方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.when(wait())</span><br><span class="line">　　.done(function()&#123; alert(&quot;哈哈，成功了！&quot;); &#125;)</span><br><span class="line">　　.fail(function()&#123; alert(&quot;出错啦！&quot;); &#125;);</span><br></pre></td></tr></table></figure><h3 id="控制回调处理的先后顺序"><a href="#控制回调处理的先后顺序" class="headerlink" title="控制回调处理的先后顺序"></a>控制回调处理的先后顺序</h3><p>这里分为两种情况：</p><ol><li>回调处理是同步的</li></ol><p>直接使用多个 then 或者 done 方法的链接就可以实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$.when(wait())</span><br><span class="line">.done(function() &#123;</span><br><span class="line">console.log(&quot;1 return!&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.done(function(time) &#123;</span><br><span class="line">console.log(&quot;2 return!&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.done(function(time) &#123;</span><br><span class="line">for (var i &#x3D; 0; i &lt; 1000000000; i++) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(&quot;3 return!&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$.when(wait())</span><br><span class="line">.then(function() &#123;</span><br><span class="line">console.log(&quot;1 return!&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(time) &#123;</span><br><span class="line">console.log(&quot;2 return!&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(time) &#123;</span><br><span class="line">for (var i &#x3D; 0; i &lt; 1000000000; i++) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(&quot;3 return!&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是：使用 done 方法的场景是几种回调的处理是在同一层次上的，done 方法不能通过 return 来将值传递给后续的 done 方法。<br>then 方法的使用场景是几个回调在不同层次上处理返回的数据，then 方法中的参数可以通过 return 语句将处理过的数据传递到下一级 then() 中的回调函数中。</p></blockquote><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$.when(wait())</span><br><span class="line">.then(function() &#123;</span><br><span class="line">console.log(&quot;1 return!&quot;);</span><br><span class="line">return 1;</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(time) &#123;</span><br><span class="line">console.log(&quot;2 return!&quot;+time);</span><br><span class="line">return 2;</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(time) &#123;</span><br><span class="line">console.log(&quot;3 return!&quot;+time);</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 输出:</span><br><span class="line"> * 1 return!</span><br><span class="line"> * 2 return1!</span><br><span class="line"> * 3 return2!</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><ol start="2"><li>回调处理是异步的</li></ol><p>这时需要使用 then 方法，并在每个 then 方法中传入 deferred 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$.when(wait())</span><br><span class="line">.then(function() &#123;</span><br><span class="line">var dtd &#x3D; $.Deferred();</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">console.log(&quot;1 return!&quot;);</span><br><span class="line">dtd.resolve();</span><br><span class="line">&#125;, 1000);</span><br><span class="line">return dtd.promise()</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(time) &#123;</span><br><span class="line">var dtd &#x3D; $.Deferred();</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">console.log(&quot;2 return!&quot;);</span><br><span class="line">dtd.resolve();</span><br><span class="line">&#125;, 1000);</span><br><span class="line">return dtd.promise()</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(time) &#123;</span><br><span class="line">var dtd &#x3D; $.Deferred();</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">console.log(&quot;3 return!&quot;);</span><br><span class="line">dtd.resolve();</span><br><span class="line">&#125;, 1000);</span><br><span class="line">return dtd.promise()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="为多个操作提供统一的回调处理"><a href="#为多个操作提供统一的回调处理" class="headerlink" title="为多个操作提供统一的回调处理"></a>为多个操作提供统一的回调处理</h3><p>将多个操作合并返回，只有当全部操作都 resolved 之后才会执行 done 函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.when(wait1(), wait2()</span><br><span class="line">　　.done(function()&#123; alert(&quot;哈哈，成功了！&quot;); &#125;)</span><br><span class="line">　　.fail(function()&#123; alert(&quot;出错啦！&quot;); &#125;);</span><br></pre></td></tr></table></figure><h3 id="为普通操作提供回调函数"><a href="#为普通操作提供回调函数" class="headerlink" title="为普通操作提供回调函数"></a>为普通操作提供回调函数</h3><p>使用 deferred 对象不仅可以为异步过程提供回调，也可以为同步过程提供回调。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var wait2 &#x3D; function(dtd) &#123;</span><br><span class="line">var dtd &#x3D; $.Deferred();</span><br><span class="line">syncOp()</span><br><span class="line">dtd.progress(processing);</span><br><span class="line">return dtd.promise();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="在处理过程中返回信息"><a href="#在处理过程中返回信息" class="headerlink" title="在处理过程中返回信息"></a>在处理过程中返回信息</h3><p>使用 deferred 对象的 progress() 方法指定回调函数。在过程执行中调用 deferred 对象的 notify() 方法可以调用这个回调函数。</p><p>使用场景如：网络请求数据之前先取缓存数据，取到数据后通知控制器更新视图。然后发起网络请求，请求返回后 resolve() 将数据传递给控制器再次更新视图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var wait &#x3D; function(dtd) &#123;</span><br><span class="line">var dtd &#x3D; $.Deferred();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;TODO: 取网络数据</span><br><span class="line">dtd.progress(processing);</span><br><span class="line">dtd.notify()&#x2F;&#x2F;通知控制器更新视图</span><br><span class="line">&#x2F;&#x2F;模拟发起网络请求</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">this.time &#x3D; 1;</span><br><span class="line">dtd.resolve();&#x2F;&#x2F;返回数据后 resolve()</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">return dtd.promise();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$.when(wait())</span><br><span class="line">　　.done(function()&#123; alert(&quot;哈哈，成功了！，用网络数据再次更新视图&quot;); &#125;)</span><br><span class="line">　　.fail(function()&#123; alert(&quot;出错啦！&quot;); &#125;);</span><br><span class="line">function processing() &#123;</span><br><span class="line">console.log(&#39;取缓存成功，更新视图&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-deferred-对象&quot;&gt;&lt;a href=&quot;#什么是-deferred-对象&quot; class=&quot;headerlink&quot; title=&quot;什么是 deferred 对象&quot;&gt;&lt;/a&gt;什么是 deferred 对象&lt;/h2&gt;&lt;p&gt;deferred 对象是 jQuery 为操作的回调函数提供的解决方案。deferred 对象提供了链式操作来对操作进行回调处理。&lt;/p&gt;
&lt;p&gt;deferred 对象引入了“执行状态”这个概念，一个 deferred 对象的执行状态分为三种&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;未完成（unresolve）&lt;/li&gt;
&lt;li&gt;已完成（resolved）&lt;/li&gt;
&lt;li&gt;已失败（rejected）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过 deferred 对象的 resolve，reject 方法来改变执行状态从而调用与该状态绑定的回调函数（们）。&lt;/p&gt;
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="jQuery" scheme="https://ufolux.github.io/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>JS运行机制</title>
    <link href="https://ufolux.github.io/2016/04/12/Front_End/js-fondation/js-runtime/"/>
    <id>https://ufolux.github.io/2016/04/12/Front_End/js-fondation/js-runtime/</id>
    <published>2016-04-12T02:00:29.000Z</published>
    <updated>2021-03-11T07:20:00.097Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-代码块"><a href="#1-代码块" class="headerlink" title="1. 代码块"></a>1. 代码块</h2><p>JavaScript中的代码块是指由<code>&lt;script&gt;</code>标签分割的代码段。<br>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">      alert(<span class="string">&quot;这是代码块一&quot;</span>);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">      alert(<span class="string">&quot;这是代码块二&quot;</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>JS是按照代码块来进行编译和执行的，<strong>代码块间相互独立，但变量和方法共享。</strong>什么意思呢? 举个例子，就明白了：</p><span id="more"></span><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">      alert(str);<span class="comment">//因为没有定义str，所以浏览器会出错，下面的不能运行</span></span><br><span class="line">      alert(<span class="string">&quot;我是代码块一&quot;</span>);<span class="comment">//没有运行到这里</span></span><br><span class="line">      <span class="keyword">var</span> test = <span class="string">&quot;我是代码块一变量&quot;</span>;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">      alert(<span class="string">&quot;我是代码块二&quot;</span>); <span class="comment">//这里有运行到</span></span><br><span class="line">      alert(test); <span class="comment">//弹出&quot;我是代码块一变量&quot;</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>上面的代码中代码块一中运行报错，但不影响代码块二的执行，这就是代码块间的独立性，<strong>而代码块二中能调用到代码一中的变量，则是块间共享性。</strong></p><h2 id="2-声明式函数与赋值式函数"><a href="#2-声明式函数与赋值式函数" class="headerlink" title="2. 声明式函数与赋值式函数"></a>2. 声明式函数与赋值式函数</h2><p>   声明式函数和赋值式函数并不会马上执行，需要等待调用发生。两者的区别在于，在JS的预编译期，声明式函数将会先被提取出来，然后才按顺序执行js代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">      <span class="comment">//声明式</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">fun</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//赋值式</span></span><br><span class="line">      <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="3-预编译期与执行期"><a href="#3-预编译期与执行期" class="headerlink" title="3. 预编译期与执行期"></a>3. 预编译期与执行期</h2><p>事实上，JS的解析过程分为两个阶段：预编译期(预处理)与执行期。</p><p><strong>预编译期JS会对本代码块中的所有声明的变量和函数进行处理（类似与C语言的编译），但需要注意的是此时处理函数的只是声明式函数，而且变量也只是进行了声明但未进行初始化以及赋值。</strong><br>js在预处理期对变量进行了声明处理,但是并没有进行初始化与赋值</p><p>下面看几个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    Fn();   <span class="comment">//执行结果：&quot;执行了函数2&quot;,同名函数后者会覆盖前者</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123; <span class="comment">//函数1</span></span><br><span class="line">        alert(<span class="string">&quot;执行了函数1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123; <span class="comment">//函数2</span></span><br><span class="line">        alert(<span class="string">&quot;执行了函数2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;   </span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;  </span><br><span class="line">    Fn();  <span class="comment">//执行结果：&quot;执行了声明式函数&quot;,在预编译期声明函数及被处理了，所以即使Fn()调用函数放在声明函数前也能执行。  </span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123; <span class="comment">//声明式函数  </span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;执行了声明式函数&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> Fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//赋值式函数  </span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;执行了赋值式函数&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&lt;/script&gt; </span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码块一  </span></span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;  </span><br><span class="line">    <span class="built_in">console</span>.log(str);<span class="comment">//浏览器报错,但并没有弹出信息窗  </span></span><br><span class="line">&lt;/script&gt;  </span><br><span class="line"><span class="comment">//代码块二  </span></span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;  </span><br><span class="line">    <span class="built_in">console</span>.log(str); <span class="comment">//弹窗&quot;undefined&quot;  </span></span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">&quot;aaa&quot;</span>;  </span><br><span class="line">&lt;/script&gt;  </span><br><span class="line"><span class="comment">//js在预处理期对变量进行了声明处理,但是并没有进行初始化与赋值，所以导致代码块二中的变量是unfiened的，而代码一中的变量是完全不存在的</span></span><br></pre></td></tr></table></figure><p>看了上面的例子，就不难明白下面代码的行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;  </span><br><span class="line">    Fn();  <span class="comment">//浏览器报错:&quot;undefined&quot;  </span></span><br><span class="line">&lt;/script&gt;  </span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123; <span class="comment">//函数1  </span></span><br><span class="line">        alert(<span class="string">&quot;执行了函数1&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>因为严格地说 js 代码是在按照代码块的先后顺序进行的<strong>预编译</strong>和<strong>执行</strong>的，所以预编译到的也只是执行到的代码块声明的函数和变量。没有执行到的代码块中的变量和函数声明对于当前代码块也同样是不可见的。对于未加载的代码块，并不能对其进行预编译处理。</p><p>总结一下，整个流程就是：</p><blockquote></blockquote><p>step 1.  读入第一个代码块。</p><blockquote></blockquote><p>step 2. 做语法分析，有错则报语法错误（比如括号不匹配等），并跳转到step5。</p><blockquote></blockquote><p>step 3. 对var变量和function定义做“预编译处理”（永远不会报错的，因为只解析正确<br>的声明）。</p><blockquote></blockquote><p>step 4. 执行代码段，有错则报错（比如变量未定义）。</p><blockquote></blockquote><p>step 5. 如果还有下一个代码段，则读入下一个代码段，重复step2。</p><blockquote></blockquote><p>step6. 结束。</p><p>而根据HTML文档流的执行顺序，需要在页面元素渲染前执行的js代码应该放在<code>&lt;body&gt;</code>前面的<code>&lt;script&gt;</code>代码块中，而需要在页面元素加载完后的js放在<code>&lt;/body&gt;</code>元素后面，body标签的onload事件是在最后执行的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-代码块&quot;&gt;&lt;a href=&quot;#1-代码块&quot; class=&quot;headerlink&quot; title=&quot;1. 代码块&quot;&gt;&lt;/a&gt;1. 代码块&lt;/h2&gt;&lt;p&gt;JavaScript中的代码块是指由&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签分割的代码段。&lt;br&gt;例如：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script type=&lt;span class=&quot;string&quot;&gt;&amp;quot;text/javascript&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      alert(&lt;span class=&quot;string&quot;&gt;&amp;quot;这是代码块一&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script type=&lt;span class=&quot;string&quot;&gt;&amp;quot;text/javascript&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      alert(&lt;span class=&quot;string&quot;&gt;&amp;quot;这是代码块二&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;JS是按照代码块来进行编译和执行的，&lt;strong&gt;代码块间相互独立，但变量和方法共享。&lt;/strong&gt;什么意思呢? 举个例子，就明白了：&lt;/p&gt;
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://ufolux.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>ng-route多视图路由</title>
    <link href="https://ufolux.github.io/2016/04/12/Front_End/AngularJS/ng-route-multiview-router/"/>
    <id>https://ufolux.github.io/2016/04/12/Front_End/AngularJS/ng-route-multiview-router/</id>
    <published>2016-04-12T02:00:11.000Z</published>
    <updated>2021-03-11T07:20:00.095Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>ng-view</code> 是一个优先级为1000的终极指令。AngularJS 不会运行同一个元素上的低优先级指令。这个指令是一个特殊的指令，用于为<code>$route</code>对应内容提供占位</p><ol><li>每次触发<code>$routeChangeSuccess</code>事件，视图都会更新。</li><li>如果某个模板同当前的路由相关联：<ul><li>创建一个新的作用域</li><li>移除上一个视图，同时上一个作用域也会被清除</li><li>将新的作用域同当前模版关联在一起</li><li>如果路由中有相关的定义，那么就把对应的控制器同当前作用域关联起来</li><li>触发<code>$viewContentLoaded</code>事件</li><li>如果提供了onload属性，调用该属性所指定的函数</li></ul></li></ol><p>使用 AngularJS 路由，需要在 <code>angular.js</code> <strong><em>之后</em></strong>引入 <code>angular-route.js</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="AngularJS" scheme="https://ufolux.github.io/tags/AngularJS/"/>
    
  </entry>
  
  <entry>
    <title>$ionicHistory 学习</title>
    <link href="https://ufolux.github.io/2016/04/12/Front_End/ionic/study-of-ionichistory/"/>
    <id>https://ufolux.github.io/2016/04/12/Front_End/ionic/study-of-ionichistory/</id>
    <published>2016-04-12T01:59:31.000Z</published>
    <updated>2021-03-11T07:20:00.096Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>$ionicHistory 是 ionic 框架实现的一套记录页面导航路径的方式。它可以跟踪用户在 app 内的浏览记录。它可以跟踪用户的当前页面，父页面和子页面（如果有）。<br>与浏览器不同的是，它可以跟踪多个平行的用户页面历史，比如多个 tab 的单页面应用。</p><span id="more"></span><p>$ionicHistory 里面记录了 view 的一些信息，<code>view</code> 是这样定义的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">viewHistory.views[viewId] &#x3D; this.createView(&#123;</span><br><span class="line">          viewId: viewId,</span><br><span class="line">          index: hist.stack.length,</span><br><span class="line">          historyId: hist.historyId,</span><br><span class="line">          backViewId: (currentView &amp;&amp; currentView.viewId ? currentView.viewId : null),</span><br><span class="line">          forwardViewId: null,</span><br><span class="line">          stateId: currentStateId,</span><br><span class="line">          stateName: this.currentStateName(),</span><br><span class="line">          stateParams: getCurrentStateParams(),</span><br><span class="line">          url: url,</span><br><span class="line">          canSwipeBack: canSwipeBack(ele, viewLocals)</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法:"></a>常用方法:</h2><p><code>goBack([numOfViews])</code>，可以直接返回 <code>numOfViews</code> 个页面前。</p><p><code>clearCache()</code>，这个方法可以清空缓存的页面，清空页面缓存的同时 DOM 中对应的元素也将被移除。</p><p><code>nextViewOptions()</code> 在这个方法中可以定义是否显示导航动画，是否可以返回，是否将下一个页面设置为根视图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ionicHistory.nextViewOptions(&#123;</span><br><span class="line">  disableAnimate: true,</span><br><span class="line">  disableBack: true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>参见：<a href="http://ionicframework.com/docs/api/service/$ionicHistory/">API 参考</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;$ionicHistory 是 ionic 框架实现的一套记录页面导航路径的方式。它可以跟踪用户在 app 内的浏览记录。它可以跟踪用户的当前页面，父页面和子页面（如果有）。&lt;br&gt;与浏览器不同的是，它可以跟踪多个平行的用户页面历史，比如多个 tab 的单页面应用。&lt;/p&gt;
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="ionic" scheme="https://ufolux.github.io/tags/ionic/"/>
    
  </entry>
  
  <entry>
    <title>JS创建对象的方式</title>
    <link href="https://ufolux.github.io/2016/04/12/Front_End/js-fondation/ways-to-create-js-object/"/>
    <id>https://ufolux.github.io/2016/04/12/Front_End/js-fondation/ways-to-create-js-object/</id>
    <published>2016-04-12T01:58:10.000Z</published>
    <updated>2021-03-11T07:20:00.097Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-函数模拟类"><a href="#1-函数模拟类" class="headerlink" title="1.函数模拟类"></a>1.函数模拟类</h2><span id="more"></span><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function Box() &#123;</span><br><span class="line">&#x2F;&#x2F;公开属性使用this来声明</span><br><span class="line">this.name &#x3D; &quot;mike&quot;; &#x2F;&#x2F;重点是this</span><br><span class="line">this.sex &#x3D; &quot;male&quot;;</span><br><span class="line">this.age &#x3D; 12;</span><br><span class="line">this.fun &#x3D; function() &#123;</span><br><span class="line">console.log(&quot;hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;不使用this的就是私有属性或方法。</span><br><span class="line">var ivar &#x3D; &quot;ivar&quot;;</span><br><span class="line">&#125;</span><br><span class="line">Box.prototype.protofunc &#x3D; function(first_argument) &#123;</span><br><span class="line">console.log(first_argument);</span><br><span class="line">&#125;;</span><br><span class="line">Box.prototype.protovar &#x3D; &quot;hi,protovar&quot;;</span><br><span class="line"></span><br><span class="line">var obj1 &#x3D; new Box();</span><br><span class="line">console.log(obj1.name);</span><br><span class="line">console.log(obj1.sex);</span><br><span class="line">console.log(obj1.age);</span><br><span class="line">obj1.fun();</span><br><span class="line">console.log(obj1.ivar); &#x2F;&#x2F;私有属性，不可见</span><br><span class="line">obj1.protofunc(&quot;hi,proto&quot;);</span><br><span class="line">console.log(obj1.protovar);</span><br><span class="line"></span><br><span class="line">&#x2F;*output:</span><br><span class="line">mike</span><br><span class="line">male</span><br><span class="line">12</span><br><span class="line">hello</span><br><span class="line">undefined</span><br><span class="line">hi,proto</span><br><span class="line">hi,protovar</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><h2 id="2-Object-create，对象模拟类"><a href="#2-Object-create，对象模拟类" class="headerlink" title="2.Object create，对象模拟类"></a>2.Object create，对象模拟类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var Cox &#x3D; &#123;</span><br><span class="line">name: &quot;mike&quot;,</span><br><span class="line">sex: &quot;male&quot;,</span><br><span class="line">age: 12,</span><br><span class="line">fun: function() &#123;</span><br><span class="line">console.log(&quot;hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj2 &#x3D; Object.create(Cox);</span><br><span class="line">console.log(obj2.name);</span><br><span class="line">console.log(obj2.sex);</span><br><span class="line">console.log(obj2.age);</span><br><span class="line">obj2.fun();</span><br><span class="line"></span><br><span class="line">&#x2F;*output:</span><br><span class="line">mike</span><br><span class="line">male</span><br><span class="line">12</span><br><span class="line">hello</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><h2 id="3-极简风，推荐"><a href="#3-极简风，推荐" class="headerlink" title="3.极简风，推荐"></a>3.极简风，推荐</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var Dox &#x3D; &#123;</span><br><span class="line">createNew: function() &#123;</span><br><span class="line">var dox &#x3D; &#123;&#125;;</span><br><span class="line">var ivar; &#x2F;&#x2F;私有</span><br><span class="line">dox.name &#x3D; &quot;hi&quot;;</span><br><span class="line">dox.makeSound &#x3D; function() &#123;</span><br><span class="line">console.log(&quot;hello world!&quot;)</span><br><span class="line">&#125;;</span><br><span class="line">return dox;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var dox &#x3D; Dox.createNew();</span><br><span class="line">dox.makeSound();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3.1 继承</span><br><span class="line">var Doxer &#x3D; &#123;</span><br><span class="line">createNew : function () &#123;</span><br><span class="line">var doxer &#x3D; Dox.createNew();&#x2F;&#x2F;继承</span><br><span class="line">doxer.helloDoxer &#x3D; &quot;helloDoxer&quot;; </span><br><span class="line">return doxer;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var doxer &#x3D; Doxer.createNew();</span><br><span class="line">console.log(doxer.helloDoxer);</span><br><span class="line">console.log(doxer.name);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;output:</span><br><span class="line">&#x2F;*</span><br><span class="line">hello world!</span><br><span class="line">helloDoxer</span><br><span class="line">hi</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-函数模拟类&quot;&gt;&lt;a href=&quot;#1-函数模拟类&quot; class=&quot;headerlink&quot; title=&quot;1.函数模拟类&quot;&gt;&lt;/a&gt;1.函数模拟类&lt;/h2&gt;
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://ufolux.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>AngularJS 的 directive机制</title>
    <link href="https://ufolux.github.io/2016/04/12/Front_End/AngularJS/angular-directive/"/>
    <id>https://ufolux.github.io/2016/04/12/Front_End/AngularJS/angular-directive/</id>
    <published>2016-04-12T01:57:33.000Z</published>
    <updated>2021-03-11T07:20:00.094Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="指令的定义"><a href="#指令的定义" class="headerlink" title="指令的定义"></a>指令的定义</h2><p>指令可以理解为在特定的 DOM 元素上运行的函数，指令可以扩展元素的功能。使用这个机制我们可以模块化我们的代码。以实现更好的结构和代码复用。</p><span id="more"></span><h2 id="指令作用域"><a href="#指令作用域" class="headerlink" title="指令作用域"></a>指令作用域</h2><h3 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h3><p>scope 属性设置为 true 的话，则表示指令创建了一个<strong>继承自父作用域</strong>的新作用域对象。<br>设置为 false 则表示不创建作用域。</p><p>scope 也可以被设置为一个对象，当设置为一个对象的时候表示指令创建了一个隔离作用域，这个作用域是与外部完全无关的，干净的环境。通过绑定策略可以使隔离作用域与父作用域进行交互。</p><h3 id="隔离作用域"><a href="#隔离作用域" class="headerlink" title="隔离作用域"></a>隔离作用域</h3><p>当 scope 被设置为一个对象的时候，表示指令内部声明了一个隔离作用域，这个作用域对象与外部完全无关，不能访问外部作用域的任何东西，是一个干净的环境。通过绑定策略可以使隔离作用域与父作用域进行交互。</p><p>Demo：</p><figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!--指令作用域--&gt;</span></span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-controller</span>=<span class="string">&quot;DirectiveScopeController&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">           <span class="comment">&lt;!--继承作用域--&gt;</span></span></span><br><span class="line"><span class="xml">           <span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-init</span>=<span class="string">&quot;outData1=&#x27;Hello World!&#x27;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">               1:&#123;&#123;outData1&#125;&#125;</span></span><br><span class="line"><span class="xml">               <span class="tag">&lt;<span class="name">div</span> <span class="attr">my-inherit-scope-directive</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">               <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">           <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">           <span class="comment">&lt;!--隔离作用域--&gt;</span></span></span><br><span class="line"><span class="xml">           <span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-init</span>=<span class="string">&quot;outData2=&#x27;Hello World!&#x27;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">               1:&#123;&#123;outData2&#125;&#125;</span></span><br><span class="line"><span class="xml">               <span class="tag">&lt;<span class="name">div</span> <span class="attr">my-isolate-scope-directive</span>&gt;</span></span></span><br><span class="line"><span class="xml">               <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">               <span class="tag">&lt;<span class="name">div</span> <span class="attr">my-isolate-scope-directive2</span>&gt;</span></span></span><br><span class="line"><span class="xml">               <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">           <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">app.directive(<span class="string">&#x27;myInheritScopeDirective&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        restrict: <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">        replace: <span class="literal">true</span>,</span><br><span class="line">        template:<span class="string">&quot;&lt;p&gt;this is 2: &#123;&#123;outData1&#125;&#125;&quot;</span>,</span><br><span class="line">        scope:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.directive(<span class="string">&#x27;myIsolateScopeDirective&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        restrict: <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">        replace: <span class="literal">true</span>,</span><br><span class="line">        template:<span class="string">&quot;&lt;p&gt;this is 2: &#123;&#123;outData2&#125;&#125;&lt;/p&gt;&quot;</span>,</span><br><span class="line">        scope:&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).directive(<span class="string">&#x27;myIsolateScopeDirective2&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        restrict: <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">        replace: <span class="literal">true</span>,</span><br><span class="line">        template:<span class="string">&quot;&lt;p&gt;this is 2: &#123;&#123;outData2&#125;&#125;&lt;/p&gt;&quot;</span>,</span><br><span class="line">        scope:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.controller(<span class="string">&quot;DirectiveScopeController&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>上述代码中也反映了数据的绑定方式：html 中的模型在 scope 中绑定给 scope 作用域变量。然后在 directive 中使用作用域变量来为模板赋值。对于表达式字符串使用<code>&quot;@&quot;</code>绑定；对于对象使用<code>&quot;=&quot;</code>绑定；对于函数使用<code>&quot;&amp;&quot;</code>进行绑定</p></blockquote><h2 id="绑定策略"><a href="#绑定策略" class="headerlink" title="绑定策略"></a>绑定策略</h2><p>绑定策略有三种形式，分别是<code>@</code>，<code>=</code>，<code>&amp;</code>。<br><code>@</code>: 字符串（表达式）绑定<br><code>=</code>: 对象绑定<br><code>&amp;</code>: 函数绑定</p><h2 id="AngularJS-生命周期"><a href="#AngularJS-生命周期" class="headerlink" title="AngularJS 生命周期"></a>AngularJS 生命周期</h2><h3 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h3><p>这是 Anguar 生命周期的第一个阶段，这个阶段 Angular 会遍历整个 HTML 文档并根据 JS 中指令的定义来处理页面上声明的指令。指令的模板也可能会包含带有模板的指令，模板树可能会变得又大又深。但是注意<strong>只有优先级最高的指令的模板才会被解析并添加到模板树中</strong>（<em>所以最佳实践是：永远不要在一个一个元素中使用一个以上的指令对其修饰</em>）。编译后的模板会返回一个模板函数。在模板函数返回之前我们仍然有机会对编译后的 DOM 树进行修改。这个时候 DOM 树还没有进行<strong>数据绑定</strong>所以此时对 DOM 树的操作开销很低。<code>ng-repeat</code>和<code>ng-transclude</code>也都是在这个时候对 DOM 树进行操作。</p><p>每个指令都可以有自己的模板和编译函数，每个末班返回的都是自己的模板函数。顶部的指令会将其内部包含的所有指令合并在一个模板函数返回。树的内部只能通过模板函数访问所处的分支。</p><p>模板函数最终被传到编译后的 DOM 树中每个指令定义规则中指定的链接函数。</p><h3 id="compile（对象或函数）"><a href="#compile（对象或函数）" class="headerlink" title="compile（对象或函数）"></a>compile（对象或函数）</h3><p>设置了编译函数意味着我们想要在<strong>指令被放到 DOM 中之前</strong>进行 DOM 操作，这时对 DOM 的操作是安全的。</p><blockquote><p>注意1：compile 函数和 link 函数是互斥的。如果同时实现了它们，compile 函数将会被当做 link 函数，而 link 函数将会被忽略。</p></blockquote><blockquote><p>注意2：不要在 compile 函数内部进行 DOM 事件监听的注册，这个操作应该放到 link 函数中完成。</p></blockquote><h3 id="link（链接）"><a href="#link（链接）" class="headerlink" title="link（链接）"></a>link（链接）</h3><p>它会在<strong>模板编译并同作用域进行链接后</strong>被调用。他负责<strong>设置事件监听器和实时操作 DOM</strong>(但要考虑<strong>性能问题</strong>)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;指令的定义&quot;&gt;&lt;a href=&quot;#指令的定义&quot; class=&quot;headerlink&quot; title=&quot;指令的定义&quot;&gt;&lt;/a&gt;指令的定义&lt;/h2&gt;&lt;p&gt;指令可以理解为在特定的 DOM 元素上运行的函数，指令可以扩展元素的功能。使用这个机制我们可以模块化我们的代码。以实现更好的结构和代码复用。&lt;/p&gt;
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="AngularJS" scheme="https://ufolux.github.io/tags/AngularJS/"/>
    
  </entry>
  
  <entry>
    <title>JS代码到底要放在什么位置</title>
    <link href="https://ufolux.github.io/2016/04/12/Front_End/js-fondation/where-to-put-js-code/"/>
    <id>https://ufolux.github.io/2016/04/12/Front_End/js-fondation/where-to-put-js-code/</id>
    <published>2016-04-12T01:56:38.000Z</published>
    <updated>2021-03-11T07:20:00.097Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><code>&lt;head&gt;&lt;/head&gt;</code> 之间之放置统计脚本，全局变量等等与页面逻辑无关的 js 代码。</li><li>引入页面逻辑相关 js 库的标签放在底部。</li><li>自定义的 js 代码放在引入 js 库的下面，也就是整个页面的最底部。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://ufolux.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>浅析ui-router</title>
    <link href="https://ufolux.github.io/2016/04/12/Front_End/AngularJS/introduce-ui-router/"/>
    <id>https://ufolux.github.io/2016/04/12/Front_End/AngularJS/introduce-ui-router/</id>
    <published>2016-04-12T01:56:29.000Z</published>
    <updated>2021-03-11T07:20:00.095Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是-ui-router"><a href="#什么是-ui-router" class="headerlink" title="什么是 ui-router"></a>什么是 ui-router</h2><p>不同于 ng-router 基于 url 的路由系统， ui-router 提供了一个基于 state 状态机的路由方式。它可以实现在不改变 url 情况下更新视图中局部内容，也可以在一个页面内嵌套并更新多个视图（状态的嵌套，这是相对于 ng-router 的一大优势），使用 ui-router 可以轻松应对复杂场景的页面应用。</p><span id="more"></span><h2 id="ui-router-基本用法"><a href="#ui-router-基本用法" class="headerlink" title="ui-router 基本用法"></a>ui-router 基本用法</h2><p>state 方法会返回 $stateProvider 本身，和 ng-router 一样支持链式操作。</p><h3 id="抽象-state"><a href="#抽象-state" class="headerlink" title="抽象 state"></a>抽象 state</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$stateProvider</span><br><span class="line">      <span class="comment">// setup an abstract state for the tabs directive</span></span><br><span class="line">      .state(<span class="string">&#x27;tabs&#x27;</span>, &#123;</span><br><span class="line">        url: <span class="string">&#x27;/tab&#x27;</span>,</span><br><span class="line">        abstract: <span class="literal">true</span>,</span><br><span class="line">        templateUrl: <span class="string">&#x27;templates/tabs.html&#x27;</span></span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure><p>上述代码描述了一个抽象的状态，一个抽象的状态可以有子状态但不能显式激活，它将被隐性激活当其子状态被激活时。<br>下面是一些你将可能会使用到抽象状态的示例：</p><ul><li>为所有子状态预提供一个基url在父状态中设置template属性，子状态对应的模板将插入到父状态模板中的ui-view(s)中</li><li>通过resolve属性，为所有子状态提供解决依赖项通过data属性，为所有子状态或者事件监听函数提供自定义数据</li><li>运行onEnter或onExit函数，这些函数可能在以某种方式修改应用程序。</li><li>上面场景的任意组合</li></ul><p>请记住：抽象的状态模板仍然需要<ui-view>，来让自己的子状态模板插入其中。因此，如果您使用抽象状态只是为了预提供基url、提供解决依赖项或者自定义data、运行onEnter/Exit函数，你任然需要设置template: “<ui-view>“。</ui-view></ui-view></p><p>上述代码中为所有子状态指定了一个基 url ，后续所有的子状态都会继承这个 url （表现形式是：<code>/tab/childUrl</code>）。</p><h3 id="子-state"><a href="#子-state" class="headerlink" title="子 state"></a>子 state</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.state(<span class="string">&#x27;tabs.questionList&#x27;</span>, &#123;</span><br><span class="line">         url: <span class="string">&#x27;/questionList&#x27;</span>,</span><br><span class="line">         views: &#123;</span><br><span class="line">           <span class="string">&#x27;questionList&#x27;</span>: &#123;</span><br><span class="line">             templateUrl: <span class="string">&#x27;templates/Question/questionList.html&#x27;</span>,</span><br><span class="line">             controller: <span class="string">&#x27;QuestionController&#x27;</span></span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure><p>使用点语法为 <code>tabs</code> 状态创建了一个子状态，对应的 html 代码应该是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ion-tab icon&#x3D;&quot;ion-navicon&quot; href&#x3D;&quot;#&#x2F;tab&#x2F;questionList&quot;&gt;</span><br><span class="line">  &lt;ion-nav-view name&#x3D;&quot;questionList&quot;&gt;&lt;&#x2F;ion-nav-view&gt;</span><br><span class="line">&lt;&#x2F;ion-tab&gt;</span><br></pre></td></tr></table></figure><p><code>ion-nav-view</code> 实际上它是一个具有 <code>ui-view</code> 指令的 html 标签。 <code>name</code> 是 <code>ui-view</code> 的名字，tabs 状态对应的是包含了 questionList 视图的 tabs.html，questionList 嵌套在 tabs 页面内部，所以 questionList 是 tabs 的子状态。</p><p><code>views</code> 中的 <code>questionList</code> 是视图的名称，ui-router 将会把这个视图替换成 <code>templateUrl</code> 中对应的 html。</p><p><code>controller</code> 是 <code>questionList</code> 视图对应的控制器。</p><h3 id="views"><a href="#views" class="headerlink" title="views"></a>views</h3><p>一个 url 对应的页面中嵌套有多个视图的时候，可以再 views 对象中添加对应的视图名字为 key 的对象，运行时嵌套的视图会按照规则被自动替换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.state(&#39;tabs.mainPage&#39;, &#123;</span><br><span class="line">          url: &#39;&#x2F;questionList&#39;,</span><br><span class="line">          views: &#123;</span><br><span class="line">            &#39;questionList&#39;: &#123;</span><br><span class="line">              templateUrl: &#39;templates&#x2F;Question&#x2F;questionList.html&#39;,</span><br><span class="line">              controller: &#39;QuestionController&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#39;answerList&#39;: &#123;</span><br><span class="line">              templateUrl: &#39;templates&#x2F;Answer&#x2F;answerList.html&#39;,</span><br><span class="line">              controller: &#39;AnswerController&#39;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p>对应的 html ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div ui-view&#x3D;&quot;questionList&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div ui-view&#x3D;&quot;answerList&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h3 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h3><p>为子状态注入依赖，参见：<a href="http://bubkoo.com/2014/01/01/angular/ui-router/guide/nested-states%20&amp;%20nested-views/#继承解决的依赖项">http://bubkoo.com/2014/01/01/angular/ui-router/guide/nested-states%20&amp;%20nested-views/#继承解决的依赖项</a></p><h3 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h3><p>页面跳转可以使用 <code>$state.go(stateName [,paramObject] [,option])</code> 第三个参数一般不使用，具体 api 参考请见<br><a href="https://angular-ui.github.io/ui-router/site/#/api/ui.router.state.$state#methods_go">https://angular-ui.github.io/ui-router/site/#/api/ui.router.state.$state#methods_go</a></p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$state.go(&#39;tabs.discovery&#39;, &#123; anId: anId &#125;);&#x2F;&#x2F;去到绝对state路径</span><br><span class="line">$state.go(&#39;^.discovery&#39;, &#123; anId: anId &#125;);&#x2F;&#x2F;去姊妹状态</span><br><span class="line">$state.go(&#39;^&#39;);&#x2F;&#x2F;回父状态</span><br><span class="line">$state.go(&#39;.child.grandchild&#39;);&#x2F;&#x2F;去孙状态</span><br></pre></td></tr></table></figure><p>或者可以使用 <code>ui-sref</code> 指令在 html 中直接写 state 跳转。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;li ui-sref-active&#x3D;&quot;current&quot;&gt;&lt;a ui-sref&#x3D;&quot;home.index&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;li ui-sref-active&#x3D;&quot;current&quot;&gt;&lt;a ui-sref&#x3D;&quot;home.project&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;li ui-sref-active&#x3D;&quot;current&quot;&gt;&lt;a ui-sref&#x3D;&quot;^.project.home(&#123;id:3&#125;)&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;   </span><br></pre></td></tr></table></figure><p><code>ui-sref-active</code> 指令将在元素被选中的时候，为元素添加 <code>active</code> 的 class。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="tab-单页面应用"><a href="#tab-单页面应用" class="headerlink" title="tab 单页面应用"></a>tab 单页面应用</h3><p>对于一个拥有两个 tab 的单页面应用来说，每一个 tab 都对应着一个自己的视图，每一个 tab 都应该拥有一个自己的导航栈。但对于 ui-router 而言，我们始终是在替换同一个视图的内容，所以所有的页面都要挂在 tab 的子级，而不是更下方的层次。</p><h3 id="公共页面的处理"><a href="#公共页面的处理" class="headerlink" title="公共页面的处理"></a>公共页面的处理</h3><p>从不同 tab 中的页面跳转至相同页面情况存在时，需要将公共页面作为 tab 的子 state，分别在需要跳转的 tab 下使用不同的名称挂载，url 也需要不同，类似如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 问题列表state</span><br><span class="line">      .state(&#39;tabs.questionList&#39;, &#123;</span><br><span class="line">          url: &#39;&#x2F;questionList&#39;,</span><br><span class="line">          views: &#123;</span><br><span class="line">            &#39;questionList&#39;: &#123;</span><br><span class="line">              templateUrl: &#39;templates&#x2F;Question&#x2F;questionList.html&#39;,</span><br><span class="line">              controller: &#39;QuestionController&#39;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        &#x2F;&#x2F; 问题详情</span><br><span class="line">        .state(&#39;tabs.questionList-question-detail&#39;, &#123;</span><br><span class="line">          url: &#39;&#x2F;questionList&#x2F;question&#x2F;:quId&#39;,</span><br><span class="line">          views: &#123;</span><br><span class="line">            &#39;questionList&#39;: &#123;</span><br><span class="line">              templateUrl: &#39;templates&#x2F;Public&#x2F;question-detail.html&#39;,</span><br><span class="line">              controller: &#39;QuestionDetailCtrl&#39;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        &#x2F;&#x2F; 答案详情</span><br><span class="line">        .state(&#39;tabs.questionList-answer-detail&#39;, &#123;</span><br><span class="line">          url: &#39;&#x2F;questionList&#x2F;answer&#x2F;:anId&#39;,</span><br><span class="line">          views: &#123;</span><br><span class="line">            questionList: &#123;</span><br><span class="line">              templateUrl: &#39;templates&#x2F;Public&#x2F;answer-detail.html&#39;,</span><br><span class="line">              controller: &#39;AnswerDetailController&#39;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;发现</span><br><span class="line">      .state(&#39;tabs.discovery&#39;, &#123;</span><br><span class="line">        url: &#39;&#x2F;discovery&#39;,</span><br><span class="line">        views: &#123;</span><br><span class="line">          &#39;discovery&#39;: &#123;</span><br><span class="line">            templateUrl: &#39;templates&#x2F;Discovery&#x2F;discovery.html&#39;,</span><br><span class="line">            controller: &#39;DiscoveryController&#39;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .state(&#39;tabs.discovery-question-detail&#39;,&#123;</span><br><span class="line">        url:&#39;&#x2F;discovery&#x2F;question&#x2F;:quId&#39;,</span><br><span class="line">        views: &#123;</span><br><span class="line">          &#39;discovery&#39;: &#123;</span><br><span class="line">            templateUrl: &#39;templates&#x2F;Public&#x2F;question-detail.html&#39;,</span><br><span class="line">            controller: &#39;QuestionDetailCtrl&#39;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .state(&#39;tabs.discovery-answer-detail&#39;,&#123;</span><br><span class="line">        url:&#39;&#x2F;discovery&#x2F;answer&#x2F;:anId&#39;,</span><br><span class="line">        views: &#123;</span><br><span class="line">          &#39;discovery&#39;: &#123;</span><br><span class="line">            templateUrl: &#39;templates&#x2F;Public&#x2F;answer-detail.html&#39;,</span><br><span class="line">            controller: &#39;AnswerDetailController&#39;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure><p>这里的页面逻辑是，<code>问题列表-&gt;问题详情-&gt;答案详情&amp;发现-&gt;问题详情|发现-&gt;答案详情</code>。我们就需要按照如上方式进行 state 的配置。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-ui-router&quot;&gt;&lt;a href=&quot;#什么是-ui-router&quot; class=&quot;headerlink&quot; title=&quot;什么是 ui-router&quot;&gt;&lt;/a&gt;什么是 ui-router&lt;/h2&gt;&lt;p&gt;不同于 ng-router 基于 url 的路由系统， ui-router 提供了一个基于 state 状态机的路由方式。它可以实现在不改变 url 情况下更新视图中局部内容，也可以在一个页面内嵌套并更新多个视图（状态的嵌套，这是相对于 ng-router 的一大优势），使用 ui-router 可以轻松应对复杂场景的页面应用。&lt;/p&gt;
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="AngularJS" scheme="https://ufolux.github.io/tags/AngularJS/"/>
    
  </entry>
  
  <entry>
    <title>服务</title>
    <link href="https://ufolux.github.io/2016/04/12/Front_End/AngularJS/angular-service/"/>
    <id>https://ufolux.github.io/2016/04/12/Front_End/AngularJS/angular-service/</id>
    <published>2016-04-12T01:56:19.000Z</published>
    <updated>2021-03-11T07:20:00.094Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="服务是什么"><a href="#服务是什么" class="headerlink" title="服务是什么"></a>服务是什么</h2><p>控制器的生命是有限的，在需要时才被实例化，一旦不需要就被销毁以节省内存提升性能。每次切换或者重新加载视图的时候当前控制器就会被 AngularJS 销毁。</p><p>如果需要在应用的<strong>整个生命周期</strong>中保持数据就需要使用<em>服务</em>，使用它在控制器之间通信，并保持数据的一致性。</p><p><strong>服务是一个单例对象</strong>，在每一个应用中只会被初始化一次（被$injector实例化）。</p><span id="more"></span><p>我们可以将网络请求以及数据持久化的功能写在 Service 模块中</p><h2 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h2><p>通过<code>$injector</code>创建和注册服务的方式有多种。通常使用<code>angular.module</code>的<code>factory</code> api 来创建服务。</p><p>DEMO:</p><p>HTML 代码如下，这个页面实现了一个输入用户名来获取该用户 github 账号下信息的功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--服务 ServiceScript.js--&gt;</span><br><span class="line">        &lt;div ng-controller=<span class="string">&quot;ServiceTestController&quot;</span>&gt;</span><br><span class="line">            &lt;label <span class="keyword">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span><br><span class="line">                Type a github username</span><br><span class="line">            &lt;/label&gt;</span><br><span class="line">            &lt;input type=<span class="string">&quot;text&quot;</span></span><br><span class="line">                   id=<span class="string">&quot;username&quot;</span></span><br><span class="line">                   ng-model=<span class="string">&quot;username&quot;</span></span><br><span class="line">                   placeholder=<span class="string">&quot;Enter a github username&quot;</span>&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li ng-repeat=<span class="string">&quot;event in events&quot;</span>&gt;</span><br><span class="line">                    &#123;&#123;event | json&#125;&#125;</span><br><span class="line">                    &#123;&#123;event.actor.login&#125;&#125; &#123;&#123;event.repo.name&#125;&#125;</span><br><span class="line">                &lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div ng-controller=<span class="string">&quot;ServiceTestControllerDelay&quot;</span>&gt;</span><br><span class="line">            &lt;label&gt;</span><br><span class="line">                Type a github username</span><br><span class="line">            &lt;/label&gt;</span><br><span class="line">            &lt;input type=<span class="string">&quot;text&quot;</span></span><br><span class="line">                   ng-model=<span class="string">&quot;username&quot;</span></span><br><span class="line">                   placeholder=<span class="string">&quot;Enter a github username&quot;</span>&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li ng-repeat=<span class="string">&quot;event in events&quot;</span>&gt;</span><br><span class="line">                    &#123;&#123;event | json&#125;&#125;</span><br><span class="line">                    &#123;&#123;event.actor.login&#125;&#125; &#123;&#123;event.repo.name&#125;&#125;</span><br><span class="line">                &lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/div&gt;</span><br></pre></td></tr></table></figure><p>Service:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> service = angular.module(<span class="string">&quot;myApp.service&quot;</span>,[]);</span><br><span class="line">service.factory(<span class="string">&#x27;firstService&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$http</span>) </span>&#123;<span class="comment">//注入$http依赖</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> githubUrl = <span class="string">&#x27;https:/api.github.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> runUserRequest = <span class="function"><span class="keyword">function</span> (<span class="params">username, path</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//从使用JSONP调用Github API的$http服务中返回promise对象</span></span><br><span class="line">        <span class="keyword">return</span> $http(&#123;</span><br><span class="line">            method: <span class="string">&#x27;JSONP&#x27;</span>,</span><br><span class="line">            url: githubUrl + <span class="string">&#x27;/users/&#x27;</span> +</span><br><span class="line">                 username + <span class="string">&#x27;/&#x27;</span> +</span><br><span class="line">                 path + <span class="string">&#x27;?callback=JSON_CALLBACK&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> serviceInstance = &#123;</span><br><span class="line">        events: <span class="function"><span class="keyword">function</span> (<span class="params">username</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> runUserRequest(username, <span class="string">&#x27;events&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> serviceInstance;<span class="comment">//singleton obj</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Controller:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">app.controller(<span class="string">&#x27;ServiceTestController&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">$scope, firstService</span>) </span>&#123;</span><br><span class="line">        $scope.$watch(<span class="string">&#x27;username&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">newUsername</span>) </span>&#123;</span><br><span class="line">            firstService.events(newUsername).success(</span><br><span class="line">                <span class="function"><span class="keyword">function</span> (<span class="params">data, status, headers</span>) </span>&#123;</span><br><span class="line">                    $scope.events = data.data;</span><br><span class="line">                    <span class="built_in">console</span>.log(data.data);</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);<span class="comment">//不推荐在控制其中使用 $watch</span></span><br><span class="line"></span><br><span class="line">app.controller(<span class="string">&#x27;ServiceTestControllerDelay&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">$scope, firstService, $timeout</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> timeout;</span><br><span class="line">        $scope.$watch(<span class="string">&#x27;username&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">newUsername</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (newUsername) &#123;</span><br><span class="line">                <span class="keyword">if</span> (timeout)<span class="comment">//350ms 内又会进来,然后任务就被全部取消</span></span><br><span class="line">                    $timeout.cancel(timeout);</span><br><span class="line">                timeout = $timeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">//句柄</span></span><br><span class="line">                    firstService.events(newUsername).success(</span><br><span class="line">                        <span class="function"><span class="keyword">function</span> (<span class="params">data, status, headers</span>) </span>&#123;</span><br><span class="line">                            $scope.events = data.data;</span><br><span class="line">                            <span class="built_in">console</span>.log(data.data);</span><br><span class="line">                        &#125;);</span><br><span class="line">                &#125;, <span class="number">350</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);<span class="comment">//不推荐在控制其中使用 $watch</span></span><br></pre></td></tr></table></figure><h2 id="创建服务其他的方式"><a href="#创建服务其他的方式" class="headerlink" title="创建服务其他的方式"></a>创建服务其他的方式</h2><ol><li><p>service() 可以为服务提供构造函数。</p></li><li><p>provider() 如果希望在 config() 函数中可以对服务进行配置<strong>必须</strong>使用<code>provider()</code>来定义服务。</p></li><li><p>constant() 可以将一个现有的常量值注册成为服务。</p></li><li><p>value() 将一个值注册成为一个服务。</p><blockquote><p>注意：constant() 和 value() 方法的区别在于，常量可以注入到配置函数（<code>config()</code>）中，但值不行。通常使用 <code>value()</code> 注册服务对象或函数，用<code>constant()</code>来配置数据。</p></blockquote></li><li><p>decorator() 装饰器十分强大，可以对服务进行拦截，中断甚至替换功能等操作。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;服务是什么&quot;&gt;&lt;a href=&quot;#服务是什么&quot; class=&quot;headerlink&quot; title=&quot;服务是什么&quot;&gt;&lt;/a&gt;服务是什么&lt;/h2&gt;&lt;p&gt;控制器的生命是有限的，在需要时才被实例化，一旦不需要就被销毁以节省内存提升性能。每次切换或者重新加载视图的时候当前控制器就会被 AngularJS 销毁。&lt;/p&gt;
&lt;p&gt;如果需要在应用的&lt;strong&gt;整个生命周期&lt;/strong&gt;中保持数据就需要使用&lt;em&gt;服务&lt;/em&gt;，使用它在控制器之间通信，并保持数据的一致性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务是一个单例对象&lt;/strong&gt;，在每一个应用中只会被初始化一次（被$injector实例化）。&lt;/p&gt;
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="AngularJS" scheme="https://ufolux.github.io/tags/AngularJS/"/>
    
  </entry>
  
  <entry>
    <title>Promise入门</title>
    <link href="https://ufolux.github.io/2016/04/12/Front_End/js-fondation/introduce-promise/"/>
    <id>https://ufolux.github.io/2016/04/12/Front_End/js-fondation/introduce-promise/</id>
    <published>2016-04-12T01:56:06.000Z</published>
    <updated>2021-03-11T07:20:00.096Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Promise-是什么"><a href="#Promise-是什么" class="headerlink" title="Promise 是什么"></a>Promise 是什么</h2><p>Promise 是抽象异步处理对象以及对其进行各种操作的组件。<br>Promise 提供了一种可以使用对象和方法来代替回调函数的异步事件处理方法。</p><span id="more"></span><h2 id="Promise-Chain"><a href="#Promise-Chain" class="headerlink" title="Promise Chain"></a>Promise Chain</h2><h2 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h2><p>HTML:</p><figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://www.promisejs.org/polyfills/promise-7.0.4.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;Promise.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>JavaScript:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by RichardLu on 3/30/16.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getURL</span>(<span class="params">URL</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        req.open(<span class="string">&#x27;GET&#x27;</span>, URL, <span class="literal">true</span>);</span><br><span class="line">        req.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (req.status === <span class="number">200</span>) &#123;</span><br><span class="line">                resolve(req.responseText);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        req.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">        &#125;;</span><br><span class="line">        req.send();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> request = &#123;</span><br><span class="line">    comment: <span class="function"><span class="keyword">function</span> <span class="title">getComment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getURL(<span class="string">&#x27;http://azu.github.io/promises-book/json/comment.json&#x27;</span>).then(<span class="built_in">JSON</span>.parse);</span><br><span class="line">    &#125;,</span><br><span class="line">    people: <span class="function"><span class="keyword">function</span> <span class="title">getPeople</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getURL(<span class="string">&#x27;http://azu.github.io/promises-book/json/people.json&#x27;</span>).then(<span class="built_in">JSON</span>.parse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">recordValue</span>(<span class="params">results, value</span>) </span>&#123;</span><br><span class="line">        results.push(value);</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pushValue = recordValue.bind(<span class="literal">null</span>, []);</span><br><span class="line">    <span class="keyword">return</span> request.comment().then(pushValue).then(request.people).then(pushValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main().then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;).catch( <span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Promise-是什么&quot;&gt;&lt;a href=&quot;#Promise-是什么&quot; class=&quot;headerlink&quot; title=&quot;Promise 是什么&quot;&gt;&lt;/a&gt;Promise 是什么&lt;/h2&gt;&lt;p&gt;Promise 是抽象异步处理对象以及对其进行各种操作的组件。&lt;br&gt;Promise 提供了一种可以使用对象和方法来代替回调函数的异步事件处理方法。&lt;/p&gt;
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://ufolux.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS原型链 （prototype chain）</title>
    <link href="https://ufolux.github.io/2016/04/12/Front_End/js-fondation/js-prototype/"/>
    <id>https://ufolux.github.io/2016/04/12/Front_End/js-fondation/js-prototype/</id>
    <published>2016-04-12T01:55:53.000Z</published>
    <updated>2021-03-11T07:20:00.097Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="prototype-和原型链"><a href="#prototype-和原型链" class="headerlink" title="prototype 和原型链"></a>prototype 和原型链</h2><p>如下代码中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Box</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.a=[]; <span class="comment">//实例变量</span></span><br><span class="line">    <span class="built_in">this</span>.fn=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//实例方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> box1=<span class="keyword">new</span> Box();</span><br><span class="line">box1.a.push(<span class="number">1</span>);</span><br><span class="line">box1.fn=&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(box1.a); <span class="comment">//[1]            </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> box1.fn); <span class="comment">//object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> box2=<span class="keyword">new</span> Box();</span><br><span class="line"><span class="built_in">console</span>.log(box2.a); <span class="comment">//[]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> box2.fn); <span class="comment">//function</span></span><br></pre></td></tr></table></figure><p>在这段代码中，我们注意到，当修改了<code>box1</code>的<code>fn</code>之后<code>box2</code>的<code>fn</code>并没有发生改变。由于数组和函数都是对象，是引用类型，所以说明此处不同对象的属性和方法同名但并不指向同一个引用而是对类定义的属性和方法的拷贝。这对于属性来说很正常，但是对于函数来说就很不合理，因为同一个类的对象中的函数做的都是相同的事情，却保存着不同的引用，占据了不该占用的空间。protoype 就是为了解决这个问题出现的。</p><span id="more"></span><p>简单来讲 prototype 是一个指针，指向一个原型对象。这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。可以理解为一类对象的公共部分（是真正的公共部分，因为每一类对象都保持对同一地址的原型对象的引用）。这样的话，我们可以把一类对象的公共的函数挂在 prototype 中，这样的话，每一个实例都只保留一个引用而不是复制整个函数。在创建实例比较多的应用中可以节省内存。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>)   //积累构造函数</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;<span class="comment">//设置对象属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.behavior = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) //给基类构造函数的<span class="title">prototype</span>添加<span class="title">behavior</span>方法</span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    alert(<span class="string">&quot;this is a &quot;</span>+<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Dog = <span class="keyword">new</span> Animal(<span class="string">&quot;dog&quot;</span>);<span class="comment">//创建Dog对象</span></span><br><span class="line"><span class="keyword">var</span> Cat = <span class="keyword">new</span> Animal(<span class="string">&quot;cat&quot;</span>);<span class="comment">//创建Cat对象</span></span><br><span class="line"></span><br><span class="line">Dog.behavior();<span class="comment">//通过Dog对象直接调用behavior方法</span></span><br><span class="line">Cat.behavior();<span class="comment">//output &quot;this is a cat&quot;</span></span><br><span class="line"></span><br><span class="line">alert(Dog.behavior==Cat.behavior);<span class="comment">//output true;</span></span><br></pre></td></tr></table></figure><p>注意只有函数拥有可以直接调用的 <code>prototype</code>，且被初始化为空值，其他对象拥有的是<code>_proto_</code>这个内部属性，不可以直接使用。但本质来讲同一类对象的<code>_proto_</code>和类的<code>prototype</code>指向的是同一个对象。</p><p>原型链：当从一个对象那里调取属性或方法时，如果该对象自身不存在这样的属性或方法，就会去自己关联的prototype对象那里寻找，如果prototype没有，就会去prototype关联的前辈prototype那里寻找，如果再没有则继续查找Prototype.Prototype引用的对象，依次类推，直到Prototype.….Prototype为undefined（Object的Prototype就是undefined）从而形成了所谓的“原型链”。</p><p>总结一下，当发生对象的调用时，将会执行以下步骤：<br>setp1. 搜索本对象中有无此方法，如果有直接调用，没有就进行下一步。<br>step2. 搜索<code>prototype</code>中，如果有被调用的对象，直接调用。没有的话就去<code>prototype.prototype</code>中去寻找。<br>step3.如果找到<code>Object.prototype</code>还没有找到，就报出undefine。</p><h2 id="prototype模式"><a href="#prototype模式" class="headerlink" title="prototype模式"></a>prototype模式</h2><p>使用prototype属性实现继承。<br>如果”猫”的prototype对象，指向一个Animal的实例，那么所有”猫”的实例，就能继承Animal了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　Cat.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">　　Cat.prototype.constructor = Cat;</span><br><span class="line">　　<span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">&quot;大毛&quot;</span>,<span class="string">&quot;黄色&quot;</span>);</span><br><span class="line">　　<span class="built_in">console</span>.log(cat1.species); <span class="comment">// 动物</span></span><br></pre></td></tr></table></figure><p>代码的第一行，将Cat的prototype对象指向一个Animal的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　Cat.prototype = <span class="keyword">new</span> Animal();</span><br></pre></td></tr></table></figure><p>第二行是需要注意的地方。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat.prototype.constructor = Cat;</span><br></pre></td></tr></table></figure><p>对象的 prototype 中都有一个 constructor 属性。这个属性指向了对象的构造方法。Cat.prototype 的 constructor 原本应该指向构造函数 Cat。但是经过  Cat.prototype = new Animal(); 之后，constructor 指向了 Animal，然而 cat1 对象显然是通过 Cat 方法来进行创建的，如果不进行修改将造成混乱。这里一定要手动指定一次。<br>这是很重要的一点，编程时务必要遵守，即如果替换了prototype对象，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　o.prototype = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>那么，下一步必然是为新的prototype对象加上constructor属性，并将这个属性指回原来的构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o.prototype.constructor = o;</span><br></pre></td></tr></table></figure><h2 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO:"></a>DEMO:</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Box</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Box.prototype.fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">counter++;</span><br><span class="line"><span class="built_in">console</span>.log(counter);</span><br><span class="line">&#125;;</span><br><span class="line">Box.prototype.a = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> box1=<span class="keyword">new</span> Box();</span><br><span class="line">box1.a.push(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(box1.a); <span class="comment">//[1]            </span></span><br><span class="line">box1.fn();<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> box2=<span class="keyword">new</span> Box();</span><br><span class="line">box2.a.push(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(box2.a); <span class="comment">//[ 1, 1 ]</span></span><br><span class="line">box2.fn();<span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>其他参见：<br><a href="http://www.cnblogs.com/yangjinjin/archive/2013/02/01/2889103.html">JS的prototype和<strong>proto</strong></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;prototype-和原型链&quot;&gt;&lt;a href=&quot;#prototype-和原型链&quot; class=&quot;headerlink&quot; title=&quot;prototype 和原型链&quot;&gt;&lt;/a&gt;prototype 和原型链&lt;/h2&gt;&lt;p&gt;如下代码中&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Box&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.a=[]; &lt;span class=&quot;comment&quot;&gt;//实例变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.fn=&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123; &lt;span class=&quot;comment&quot;&gt;//实例方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; box1=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Box();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;box1.a.push(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;box1.fn=&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(box1.a); &lt;span class=&quot;comment&quot;&gt;//[1]            &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; box1.fn); &lt;span class=&quot;comment&quot;&gt;//object&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; box2=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Box();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(box2.a); &lt;span class=&quot;comment&quot;&gt;//[]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; box2.fn); &lt;span class=&quot;comment&quot;&gt;//function&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这段代码中，我们注意到，当修改了&lt;code&gt;box1&lt;/code&gt;的&lt;code&gt;fn&lt;/code&gt;之后&lt;code&gt;box2&lt;/code&gt;的&lt;code&gt;fn&lt;/code&gt;并没有发生改变。由于数组和函数都是对象，是引用类型，所以说明此处不同对象的属性和方法同名但并不指向同一个引用而是对类定义的属性和方法的拷贝。这对于属性来说很正常，但是对于函数来说就很不合理，因为同一个类的对象中的函数做的都是相同的事情，却保存着不同的引用，占据了不该占用的空间。protoype 就是为了解决这个问题出现的。&lt;/p&gt;
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://ufolux.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS事件循环模型</title>
    <link href="https://ufolux.github.io/2016/04/12/Front_End/js-fondation/js-event-loop-model/"/>
    <id>https://ufolux.github.io/2016/04/12/Front_End/js-fondation/js-event-loop-model/</id>
    <published>2016-04-12T01:55:24.000Z</published>
    <updated>2021-03-11T07:20:00.097Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Javascript的单线程机制。在现有浏览器环境中，Javascript执行引擎是单线程的，主线程的语句和方法，会阻塞定时任务的运行，执行引擎只有在执行完主线程的语句后，定时任务才会实际执行，这期间的时间，可能大于注册任务时设置的延时时间。在这一点上，Javascript与Java/C#的机制很不同。</p><span id="more"></span><p>在单线程的Javascript引擎中，setTimeout()是如何运行的呢，这里就要提到浏览器内核中的事件循环模型了。简单的讲，在Javascript执行引擎之外，有一个任务队列，当在代码中调用setTimeout()方法时，注册的延时方法会交由浏览器内核其他模块（以webkit为例，是webcore模块）处理，当延时方法到达触发条件，即到达设置的延时时间时，这一延时方法被添加至任务队列里。这一过程由浏览器内核其他模块处理，与执行引擎主线程独立，执行引擎在主线程方法执行完毕，到达空闲状态时，会从任务队列中顺序获取任务来执行，这一过程是一个不断循环的过程，称为事件循环模型。</p><p>console.log方法是一个webkit内核支持的方法，在执行引擎执行这个代码的时候，console.log会先被入栈，然后立即执行直接出栈，而不被其他方法阻塞。而setTimeout()方法属于事件循环模型WebAPIs中的方法。引擎将方法出栈执行的时候，直接将回调函数交给了<strong>相应的模块</strong>。待时间到达以后再将函数交回<strong>任务队列</strong>，等到执行栈被清空之后，再将延时方法送入执行栈中。</p><h2 id="Webkit中的Timer实现"><a href="#Webkit中的Timer实现" class="headerlink" title="Webkit中的Timer实现"></a>Webkit中的Timer实现</h2><p>TimerHeap采用最小堆的数据结构，预期延时时间最小的任务最先被执行，同时，预期延时时间相同的两个任务，其执行顺序是按照注册的先后顺序执行。</p><p>循环中的 setTimeout()<br>循环中的代码会按照代码块的执行规则来运行，setTimeout将会在每次循环结束时执行。对于for循环，i++的操作将在每次循环执行之后来执行。</p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo:"></a>Demo:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body onload&#x3D;&quot;countDown()&quot;&gt;</span><br><span class="line">&lt;p id&#x3D;&quot;clock&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">function countDown() &#123;</span><br><span class="line">var now &#x3D; new Date();</span><br><span class="line">var h &#x3D; now.getHours();</span><br><span class="line">var m &#x3D; now.getMinutes();</span><br><span class="line">var s &#x3D; now.getSeconds();</span><br><span class="line">document.getElementById(&quot;clock&quot;).innerHTML &#x3D; &quot;now is:&quot;+h+&quot;:&quot;+m+&quot;:&quot;+s;</span><br><span class="line">setTimeout(&quot;countDown()&quot;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>问题：为什么用递归方式？有什么好处？</p><ol><li>准确，因为是一直在拿最新时间。不会出现使用减减时执行引擎的卡顿导致任务队列中任务不能进入执行线程造成的不准确现象。</li><li>可以方便的暂停，通过setTimeout()获得的句柄，使用clearTimeout(no)来暂停计时。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Javascript的单线程机制。在现有浏览器环境中，Javascript执行引擎是单线程的，主线程的语句和方法，会阻塞定时任务的运行，执行引擎只有在执行完主线程的语句后，定时任务才会实际执行，这期间的时间，可能大于注册任务时设置的延时时间。在这一点上，Javascript与Java/C#的机制很不同。&lt;/p&gt;
    
    </summary>
    
      <category term="大钱端" scheme="https://ufolux.github.io/categories/%E5%A4%A7%E9%92%B1%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://ufolux.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>x86 汇编知识补充</title>
    <link href="https://ufolux.github.io/2016/01/23/Compiler/%E6%B1%87%E7%BC%96%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/"/>
    <id>https://ufolux.github.io/2016/01/23/Compiler/汇编知识补充/</id>
    <published>2016-01-23T02:35:56.000Z</published>
    <updated>2021-03-11T07:20:00.084Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>做编译器的代码生成器部分的时候一定会使用到汇编代码，特在此总结一些简单的汇编语言知识点。以能看懂常见的汇编代码为目的，不做深入探究。</p><p>学习一种的汇编语言，必须了解这种 CPU 的寄存器、寻址方式以及各种指令。我们就先从寄存器开始着手吧。</p><span id="more"></span><h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p>32位x86架构的CPU有8个通用寄存器:</p><h3 id="通用寄存器-段寄存器"><a href="#通用寄存器-段寄存器" class="headerlink" title="通用寄存器 段寄存器"></a>通用寄存器 段寄存器</h3><ul><li>AX: Accumulator register (累加器 CS 代码段)</li><li>CX: Counter register (计数器 SS 堆栈段)</li><li>DX: Data register (数据 ES 附加段)</li><li>BX: Base register (基址 DS 数据段)</li></ul><h3 id="指针寄存器-堆栈寄存器"><a href="#指针寄存器-堆栈寄存器" class="headerlink" title="指针寄存器 堆栈寄存器"></a>指针寄存器 堆栈寄存器</h3><ul><li>SP: Stack pointer register (栈指针,指向栈顶)</li><li>BP: Stack base pointer register (基址指针,指向当前stack frame的底部)</li><li>SI: Source index register (源索引指针)</li><li>DI: Destination index register (目的索引指针)</li></ul><p>以上名称对应的寄存器均为16位，在32位模式下，上面的寄存器名称前需要加E，64位模式下需要加R。例如，访问32位的AX寄存器需要使用名称EAX，而访问64位(x86_64)的需要使用RAX。</p><p>另外，AX, BX, CX, DX这四个通用寄存器的高8位和低8位还可以分成两个单独的寄存器使用，名称分别是XH和XL(X=A,B,C,D)。</p><p>下面是RAX寄存器的示意图:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+---------------------------------------------------------------+</span><br><span class="line">| 8bits | 8bits | 8bits | 8bits | 8bits | 8bits | 8bits | 8bits |</span><br><span class="line">|---------------------------------------------------------------|</span><br><span class="line">|                              RAX                              |</span><br><span class="line">|---------------------------------------------------------------|</span><br><span class="line">|                               |              EAX              |</span><br><span class="line">|---------------------------------------------------------------|</span><br><span class="line">|                                               |      AX       | </span><br><span class="line">|---------------------------------------------------------------|</span><br><span class="line">|                                               |  AH   |   AL  |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>x86_64添加了8个新的通用寄存器，且引入了新的命名规则，详情可参考<a href="http://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture#General-purpose_registers_.2864-bit_naming_conventions.29">这里</a>。</p><h3 id="其他常用寄存器"><a href="#其他常用寄存器" class="headerlink" title="其他常用寄存器"></a>其他常用寄存器</h3><ul><li>EFLAGS: 32位寄存器，用于保存指令结果和处理器状态，具体说明可参考这里。</li><li>IP: 指令寄存器，用于保存要执行的指令，和通用寄存器类似，32位模式下用EIP，64位模式下用RIP。</li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>x86汇编语言主要有两个语法分支: AT&amp;T和Intel。我们平常接触到的GNU系的工具（包括GCC，OBJDUMP等）都是使用AT&amp;T语法，若无特别说明，下面的汇编代码例子也是如此。</p><table><thead><tr><th align="left">操作</th><th align="left">AT&amp;T</th><th align="left">Intel</th><th align="left">注释</th></tr></thead><tbody><tr><td align="left">寄存器前缀</td><td align="left">%eax</td><td align="left">eax</td><td align="left"></td></tr><tr><td align="left">立即数前缀</td><td align="left">$5</td><td align="left">5</td><td align="left"></td></tr><tr><td align="left">指令后缀</td><td align="left">movl</td><td align="left">mov</td><td align="left">操作数长度4</td></tr><tr><td align="left">参数次序</td><td align="left">movl $5, %eax</td><td align="left">mov eax, 5</td><td align="left">R[eax] = 5</td></tr><tr><td align="left">取址1</td><td align="left">var</td><td align="left">[var]</td><td align="left">变量</td></tr><tr><td align="left">取址2</td><td align="left">0x8(%eax)</td><td align="left">[eax + 0x8]</td><td align="left">偏移</td></tr><tr><td align="left">取址3</td><td align="left">arr(, %eax, 4)</td><td align="left">[eax * 4 + arr]</td><td align="left">数组</td></tr></tbody></table><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="mov"><a href="#mov" class="headerlink" title="mov"></a>mov</h3><p>拷贝数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># R[eax] &#x3D; 5</span><br><span class="line">movl $5, %eax</span><br><span class="line"># var &#x3D; 5</span><br><span class="line">movl %eax, var</span><br></pre></td></tr></table></figure><h3 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmpl $2, count.0</span><br></pre></td></tr></table></figure><p>比较操作符，并将结果暂存于EFLAGS寄存器。</p><h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><p>跳转指令可以修改IP寄存器的值，以实现控制流转换。</p><ul><li>jmp (jump):无条件跳转到对应的label地址处。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp label</span><br></pre></td></tr></table></figure><ul><li>je (jump if equal): 如果上一次cmp指令结果是相等的，跳转到label处。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">je label</span><br></pre></td></tr></table></figure><ul><li>jne (jump if not equal):和je相反，如果上一次cmp指令结果不相等，跳转到label处。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp $5, $eax</span><br><span class="line">jne label</span><br></pre></td></tr></table></figure><ul><li>jl (jump if less):如果上一次cmp指令结果小于条件成立，跳转到label处。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp $5, $eax</span><br><span class="line">jl label</span><br></pre></td></tr></table></figure><ul><li>jle (jump if less or equal):如果上一次cmp指令结果小于等于条件成立，跳转到label处。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp $5, $eax</span><br><span class="line">jle label</span><br></pre></td></tr></table></figure><ul><li>jg (jump if greater):如果上一次cmp指令结果大于条件成立，跳转到label处。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp $5, $eax</span><br><span class="line">jg label</span><br></pre></td></tr></table></figure><ul><li>jge (jump if greater or equal):如果上一次cmp指令结果大于等于条件成立，跳转到label处。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp $5, $eax</span><br><span class="line">jge label</span><br></pre></td></tr></table></figure><p>在<a href="https://en.wikibooks.org/wiki/X86_Assembly/Control_Flow#Jump_Instructions">这里</a>查看更多跳转指令</p><h3 id="call-ret"><a href="#call-ret" class="headerlink" title="call ret"></a>call ret</h3><ul><li>call: 将下一条指令的地址入栈，然后跳转到proc地址处。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cal proc</span><br></pre></td></tr></table></figure><ul><li>ret: 将栈顶的数据出栈并载入IP寄存器（即跳转回call的下一条指令处）。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret</span><br></pre></td></tr></table></figure><h3 id="enter-leave"><a href="#enter-leave" class="headerlink" title="enter leave"></a>enter leave</h3><ul><li>enter: 新建一个stack frame，相当于:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push %ebp</span><br><span class="line">mov  %esp, %ebp</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enter arg</span><br></pre></td></tr></table></figure><ul><li>leave: 销毁当前stack frame，恢复上一个stack frame，相当于:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov %ebp, %esp</span><br><span class="line">pop %ebp</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leave</span><br></pre></td></tr></table></figure><h3 id="运算指令"><a href="#运算指令" class="headerlink" title="运算指令"></a>运算指令</h3><ul><li>add: 加法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># R[ebx] +&#x3D; R[eax]</span><br><span class="line">add %eax, %ebx</span><br></pre></td></tr></table></figure><ul><li>sub: 减法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># R[ebx] -&#x3D; R[eax]</span><br><span class="line">sub %eax, %ebx</span><br></pre></td></tr></table></figure><ul><li>inc: 自增</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># R[eax] +&#x3D; 1</span><br><span class="line">inc %eax</span><br></pre></td></tr></table></figure><ul><li>dec: 自减</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># R[eax] -&#x3D; 1</span><br><span class="line">dec %eax</span><br></pre></td></tr></table></figure><h3 id="其他常用指令"><a href="#其他常用指令" class="headerlink" title="其他常用指令"></a>其他常用指令</h3><ul><li>lea (Load effective address):</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># R[eax] &#x3D; R[ebx] - 8</span><br><span class="line">lea -0x8(%ebx), %eax</span><br></pre></td></tr></table></figure><p>注意和mov指令的区别:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mem[R[eax]] &#x3D; R[ebx] - 8</span><br><span class="line">mov -0x8(%ebx), %eax</span><br></pre></td></tr></table></figure><p>引用：<a href="http://blog.atime.me/note/asm-summary.html">http://blog.atime.me/note/asm-summary.html</a></p><p>参阅：<a href="https://en.wikipedia.org/wiki/Control_flow">https://en.wikipedia.org/wiki/Control_flow</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做编译器的代码生成器部分的时候一定会使用到汇编代码，特在此总结一些简单的汇编语言知识点。以能看懂常见的汇编代码为目的，不做深入探究。&lt;/p&gt;
&lt;p&gt;学习一种的汇编语言，必须了解这种 CPU 的寄存器、寻址方式以及各种指令。我们就先从寄存器开始着手吧。&lt;/p&gt;
    
    </summary>
    
      <category term="Compiler" scheme="https://ufolux.github.io/categories/Compiler/"/>
    
    
      <category term="Compiler" scheme="https://ufolux.github.io/tags/Compiler/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习笔记-属性</title>
    <link href="https://ufolux.github.io/2015/12/26/Swift/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%B1%9E%E6%80%A7/"/>
    <id>https://ufolux.github.io/2015/12/26/Swift/Swift学习笔记-属性/</id>
    <published>2015-12-26T05:11:52.000Z</published>
    <updated>2021-03-11T07:20:00.109Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>class 可以拥有属性。属性分为两种，存储属性和计算属性。</p><h2 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h2><p>最简单的情形，作为特定类或结构实例的一部分，存储属性存储着常量或者变量的值。存储属性可分为变量存储属性（关键字var描述）和常量存储属性（关键字let描述）。</p><p>当定义存储属性时，你可以提供一个默认值，这些在“默认属性值”描述。在初始化过程中你也可以设置或改变存储属性的初值。这个准则对常量存储属性也同样适用（在“初始化过程中改变常量属性”描述）</p><span id="more"></span><p>下面的例子定义了一个叫FixedLengthRange的结构，它描述了一个一定范围内的整数值，当创建这个结构时，范围长度是不可以被改变的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct FixedLengthRange &#123;</span><br><span class="line">var firstValue: Int</span><br><span class="line">let length: Int</span><br><span class="line">&#125;</span><br><span class="line">var rangeOfThreeItems &#x3D; FixedLengthRange(firstValue: 0, length: 3)</span><br><span class="line">&#x2F;&#x2F; the range represents integer values 0, 1, and 2</span><br><span class="line">rangeOfThreeItems.firstValue &#x3D; 6</span><br><span class="line">&#x2F;&#x2F; the range now represents integer values 6, 7, and 8</span><br></pre></td></tr></table></figure><p>因为rangeOfFourItems是一个常量（let），即便firstValue是一个变量属性，它的值也是不可以被改变的</p><p>这样的特性是因为结构是值类型。当一个值类型实例作为常量而存在，它的所有属性也作为常量而存在。</p><p>而这个特性对类并不适用，因为类是引用类型。如果你将引用类型的实例赋值给常量，依然能够改变实例的变量属性。</p><p>Lazy Stored Properties（懒惰存储属性？）<br>懒惰存储属性是当它第一次被使用时才进行初值计算。通过在属性声明前加上@lazy来标识一个懒惰存储属性。</p><p>注意<br>必须声明懒惰存储属性为变量属性（通过var），因为它的初始值直到实例初始化完成之后才被检索。常量属性在实例初始化完成之前就应该被赋值，因此常量属性不能够被声明为懒惰存储属性。</p><p>当属性初始值因为外部原因，在实例初始化完成之前不能够确定时，就要定义成懒惰存储属性。当属性初始值需要复杂或高代价的设置，在它需要时才被赋值时，懒惰存储属性就派上用场了。</p><p>下面的例子使用懒惰存储属性来防止类中不必要的初始化操作。它定义了类DataImporter和类DataManager：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class DataImporter &#123;</span><br><span class="line">&#x2F;*DataImporter is a class to import data from an external file.     The class is assumed to take a non-trivial amount of time to initialize.*&#x2F;</span><br><span class="line">var fileName &#x3D; &quot;data.txt&quot;</span><br><span class="line">&#x2F;&#x2F; the DataImporter class would provide data importing functionality here</span><br><span class="line">&#125;</span><br><span class="line">class DataManager &#123;</span><br><span class="line">@lazy var importer &#x3D; DataImporter()</span><br><span class="line">var data &#x3D; String[]()</span><br><span class="line">&#x2F;&#x2F; the DataManager class would provide data management functionality here</span><br><span class="line">&#125;</span><br><span class="line">let manager &#x3D; DataManager()</span><br><span class="line">manager.data +&#x3D; &quot;Some data&quot;</span><br><span class="line">manager.data +&#x3D; &quot;Some more data&quot;</span><br><span class="line">&#x2F;&#x2F; the DataImporter instance for the importer property has not yet been created</span><br></pre></td></tr></table></figure><p>DataImporter的实例importer只有在当它在第一次被访问时才被创建。</p><h3 id="存储属性与实例变量"><a href="#存储属性与实例变量" class="headerlink" title="存储属性与实例变量"></a>存储属性与实例变量</h3><p>如果你使用过Objective－C，你应该知道它提供两种方式来存储作为类实例一部分的值与引用。除了属性，你可以使用实例变量作为属性值的后备存储</p><p>Swift使用一个单一属性声明来统一这些概念。一个Swift属性没有与之相符的实例变量，并且属性的后备存储也不能直接访问。这防止了在不通上下文中访问值的混淆，并且简化属性声明成为一个单一的、最终的语句。关于属性的所有信息－包含名称、类型和内存管理等－作为类型定义的一部分而定义。</p><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>除了存储属性，类、结构和枚举能够定义计算属性。计算属性并不存储值，它提供getter和可选的setter来间接地获取和设置其它的属性和值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x &#x3D; 0.0, y &#x3D; 0.0</span><br><span class="line">&#125;</span><br><span class="line">struct Size &#123;</span><br><span class="line">    var width &#x3D; 0.0, height &#x3D; 0.0</span><br><span class="line">&#125;</span><br><span class="line">struct Rect &#123;</span><br><span class="line">    var origin &#x3D; Point()</span><br><span class="line">    var size &#x3D; Size()</span><br><span class="line">    var center: Point &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            let centerX &#x3D; origin.x + (size.width &#x2F; 2)</span><br><span class="line">            let centerY &#x3D; origin.y + (size.height &#x2F; 2)</span><br><span class="line">            return Point(x: centerX, y: centerY)</span><br><span class="line">        &#125;</span><br><span class="line">        set(newCenter) &#123;</span><br><span class="line">            origin.x &#x3D; newCenter.x - (size.width &#x2F; 2)</span><br><span class="line">            origin.y &#x3D; newCenter.y - (size.height &#x2F; 2)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var square &#x3D; Rect(origin: Point(x: 0.0, y: 0.0),size: Size(width: 10.0, height: 10.0))</span><br><span class="line">let initialSquareCenter &#x3D; square.center</span><br><span class="line">square.center &#x3D; Point(x: 15.0, y: 15.0)</span><br><span class="line">print(&quot;square.origin is now at (\(square.origin.x), \(square.origin.y))&quot;)</span><br><span class="line">&#x2F;&#x2F; prints &quot;square.origin is now at (10.0, 10.0)&quot;</span><br></pre></td></tr></table></figure><h3 id="setter声明的简略写法"><a href="#setter声明的简略写法" class="headerlink" title="setter声明的简略写法"></a>setter声明的简略写法</h3><p>如果计算属性的setter方法没有将被设置的值定义一个名称，将会默认地使用newValue这个名称来代替。下面的例子采用了这样一种特性，定义了Rect结构的新版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct AlternativeRect &#123;</span><br><span class="line">    var origin &#x3D; Point()</span><br><span class="line">    var size &#x3D; Size()</span><br><span class="line">    var center: Point &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            let centerX &#x3D; origin.x + (size.width &#x2F; 2)</span><br><span class="line">            let centerY &#x3D; origin.y + (size.height &#x2F; 2)</span><br><span class="line">            return Point(x: centerX, y: centerY)</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            origin.x &#x3D; newValue.x - (size.width &#x2F; 2)</span><br><span class="line">            origin.y &#x3D; newValue.y - (size.height &#x2F; 2)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="只读计算属性"><a href="#只读计算属性" class="headerlink" title="只读计算属性"></a>只读计算属性</h3><p>只读计算属性只带有一个getter方法，通过点操作符，可以放回属性值，但是不能修改它的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct Cuboid &#123;</span><br><span class="line">    var width &#x3D; 0.0, height &#x3D; 0.0, depth &#x3D; 0.0</span><br><span class="line">    var volume: Double &#123;</span><br><span class="line">        return width * height * depth</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let fourByFiveByTwo &#x3D; Cuboid(width: 4.0, height: 5.0, depth: 2.0)</span><br><span class="line">print(&quot;the volume of fourByFiveByTwo is \(fourByFiveByTwo.volume)&quot;)</span><br><span class="line">&#x2F;&#x2F; prints &quot;the volume of fourByFiveByTwo is 40.0</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>应该使用var关键字将计算属性(包含只读计算属性)定义成变量属性，因为它们的值并不是固定的。let关键字只被常量属性说使用，以表明一旦被设置它们的值就是不可改变的了</p><h2 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h2><h3 id="类型属性句法"><a href="#类型属性句法" class="headerlink" title="类型属性句法"></a>类型属性句法</h3><p>在C和Objective－C中，定义静态常量、变量和全局静态变量一样。但是在swift中，类型属性的定义要放在类型定义中进行，在类型定义的大括号中，显示地声明它在类型中的作用域。</p><p>对值类型而言，定义类型属性使用static关键字，而定义类类型的类型属性使用class关键字。下面的例子展示了存储和计算类型属性的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct SomeStructure &#123;</span><br><span class="line">    static var storedTypeProperty &#x3D; &quot;Some value.&quot;</span><br><span class="line">    static var computedTypeProperty: Int &#123;</span><br><span class="line">        &#x2F;&#x2F; return an Int value here</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">enum SomeEnumeration &#123;</span><br><span class="line">    static var storedTypeProperty &#x3D; &quot;Some value.&quot;     static var computedTypeProperty: Int &#123;     &#x2F;&#x2F; return an Int value here</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class SomeClass &#123;</span><br><span class="line">    class var computedTypeProperty: Int &#123;</span><br><span class="line">        &#x2F;&#x2F; return an Int value here</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><p>上面的例子是针对只读计算类型属性而言的，不过你也可以像计算实例属性一样定义可读可写的计算类型属性</p><h3 id="查询与设置类型属性"><a href="#查询与设置类型属性" class="headerlink" title="查询与设置类型属性"></a>查询与设置类型属性</h3><p>像实例属性一样，类型属性通过点操作符来查询与设置。但是类型属性的查询与设置是针对类型而言的，并不是针对类型的实例。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">println(SomeClass.computedTypeProperty)</span><br><span class="line">&#x2F;&#x2F; prints &quot;42&quot;</span><br><span class="line">print(SomeStructure.storedTypeProperty)</span><br><span class="line">&#x2F;&#x2F; prints &quot;Some value.&quot;</span><br><span class="line">SomeStructure.storedTypeProperty &#x3D; &quot;Another value.&quot;</span><br><span class="line">print(SomeStructure.storedTypeProperty)</span><br><span class="line">&#x2F;&#x2F; prints &quot;Another value.</span><br></pre></td></tr></table></figure><h2 id="属性观察者"><a href="#属性观察者" class="headerlink" title="属性观察者"></a>属性观察者</h2><p>属性观察者观察属性值的改变并对此做出响应。当设置属性的值时，属性观察者就被调用，即使当新值同原值相同时也会被调用。</p><p>除了懒惰存储属性，你可以为任何存储属性加上属性观察者定义。另外，通过重写子类属性，也可以继承属性（存储或计算）加上属性观察者定义。属性重写在“重写”章节定义。</p><p><strong>注意</strong></p><p>不必为未重写的计算属性定义属性观察者，因为可以通过它的setter方法直接对值的改变做出响应</p><p>定义属性的观察者时，你可以单独或同时使用下面的方法：</p><p>willSet：设置值前被调用</p><p>didSet：设置值后立刻被调用</p><p>当实现willSet观察者时，新的属性值作为常量参数被传递。你可以为这个参数起一个名字，如果不的话，这个参数就默认地被命名成newValue。</p><p>在实现didSet观察者时也是一样，只不过传递的产量参数表示的是旧的属性值。</p><p><strong>注意</strong></p><p>属性初始化时，willset和didSet并不会被调用。只有在初始化上下文之外，当设置属性值时才被调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class StepCounter &#123;</span><br><span class="line">    var totalSteps: Int &#x3D; 0 &#123;</span><br><span class="line">        willSet(newTotalSteps) &#123;</span><br><span class="line">            print(&quot;About to set totalSteps to \(newTotalSteps)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            if totalSteps &gt; oldValue  &#123;</span><br><span class="line">                print(&quot;Added \(totalSteps - oldValue) steps&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let stepCounter &#x3D; StepCounter()</span><br><span class="line">stepCounter.totalSteps &#x3D; 200</span><br><span class="line">&#x2F;&#x2F; About to set totalSteps to 200</span><br><span class="line">&#x2F;&#x2F; Added 200 steps</span><br><span class="line">stepCounter.totalSteps &#x3D; 360</span><br><span class="line">&#x2F;&#x2F; About to set totalSteps to 360</span><br><span class="line">&#x2F;&#x2F; Added 160 steps</span><br><span class="line">stepCounter.totalSteps &#x3D; 896</span><br><span class="line">&#x2F;&#x2F; About to set totalSteps to 896</span><br><span class="line">&#x2F;&#x2F; Added 536 steps</span><br></pre></td></tr></table></figure><p>类StepCounter声明了一个Int类型的、含有willSet和didSet观察者的存储属性totalSteps。当这个属性被赋予新值时，willSet和didSet将会被调用，即使新值和旧值是相同的。</p><p>例子中的willSet观察者为参数起了个新的名字newTotalSteps，它简单地打印了即将被设置的值。</p><p>当totalSteps值被更新时，didSet观察者被调用，它比较totalSteps的新值和旧值，如果新值比旧值大，就打印所增加的步数。didSet并没有为旧值参数命名，在本例中，将会使用默认的名字oldValue来表示旧的值。</p><p><strong>注意</strong></p><p>如果通过didSet来设置属性的值，即使属性值刚刚被设置过，起作用的也将会是didSet，即新值是didSet设置的值，在 didSet 中不要设置属性的值，否则程序将陷入死循环。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>值类型（结构体，枚举）中既可以定义存储属性也可以定义计算属性；引用类型（类）</p><p>参见：<a href="http://letsswift.com/2014/06/properties/">http://letsswift.com/2014/06/properties/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;属性&quot;&gt;&lt;a href=&quot;#属性&quot; class=&quot;headerlink&quot; title=&quot;属性&quot;&gt;&lt;/a&gt;属性&lt;/h1&gt;&lt;p&gt;class 可以拥有属性。属性分为两种，存储属性和计算属性。&lt;/p&gt;
&lt;h2 id=&quot;存储属性&quot;&gt;&lt;a href=&quot;#存储属性&quot; class=&quot;headerlink&quot; title=&quot;存储属性&quot;&gt;&lt;/a&gt;存储属性&lt;/h2&gt;&lt;p&gt;最简单的情形，作为特定类或结构实例的一部分，存储属性存储着常量或者变量的值。存储属性可分为变量存储属性（关键字var描述）和常量存储属性（关键字let描述）。&lt;/p&gt;
&lt;p&gt;当定义存储属性时，你可以提供一个默认值，这些在“默认属性值”描述。在初始化过程中你也可以设置或改变存储属性的初值。这个准则对常量存储属性也同样适用（在“初始化过程中改变常量属性”描述）&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://ufolux.github.io/categories/Swift/"/>
    
    
      <category term="学习" scheme="https://ufolux.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>iOS 资源列表</title>
    <link href="https://ufolux.github.io/2015/12/25/Translation/%E3%80%90%E7%83%AD%E6%96%87%E3%80%91iOS%20%E8%B5%84%E6%BA%90%E5%A4%A7%E5%85%A8/"/>
    <id>https://ufolux.github.io/2015/12/25/Translation/【热文】iOS 资源大全/</id>
    <published>2015-12-25T02:08:07.000Z</published>
    <updated>2021-03-11T07:20:00.112Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><img src="/images/awesome_logo.png" width="400"><p><a href="https://github.com/sindresorhus/awesome"><img src="https://cdn.rawgit.com/sindresorhus/awesome/d7305f38d29fed78fa85652e3a63e154dd8e8829/media/badge.svg" alt="Awesome"></a></p><p><a href="https://github.com/vsouza/awesome-ios/blob/master/README.md#image">原文在此</a> 翻译 by skyfly.xyz</p><p>这是个精心编排的列表，它包含了优秀的 iOS 框架，库，教程，XCode 插件，组件等等。</p><p>这个列表分为以下几个部分：框架（ Frameworks ），组件（ Components ），测试（ Testing ）和其他的开源项目，免费的和付费的服务。每个部分中的项目没有先后顺序，均是按照提交的先后顺序排列的。如果你想为这个列表作出贡献，请阅读这个<a href="https://github.com/vsouza/awesome-ios/blob/master/CONTRIBUTING.md">指南</a>。</p><p>Swift 语言写成的项目会被标记为 <img src="/images/swift_logo.png" width="20" height="20"> ，AppleWatch 的项目则会被标记为 <img src="/images/applewatch_logo.png" width="20" height="20">。你可以自由添加你的项目。</p><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a><a name></a>内容</h3><span id="more"></span><ul><li><a href="#getting-started">入门</a></li><li><a href="#libraries-and-frameworks">库和框架</a><ul><li><a href="#audio">音频</a></li><li><a href="#animation">动画</a></li><li><a href="#apple-tv">Apple TV</a></li><li><a href="#bridging">桥接</a></li><li><a href="#cache">缓存</a></li><li><a href="#core-data">Core Data</a></li><li><a href="#charts">图表</a></li><li><a href="#database">数据库</a></li><li><a href="#hardware">硬件</a><ul><li><a href="#motion">动作</a></li><li><a href="#bluetooth">蓝牙</a></li><li><a href="#location">位置</a></li><li><a href="#ibeacon">iBeacon</a></li></ul></li><li><a href="#hud">HUD</a></li><li><a href="#eventbus">事件总线（ EventBus ）</a></li><li><a href="#files">文件</a></li><li><a href="#json">JSON</a></li><li><a href="#layout">布局</a></li><li><a href="#logging">日志</a></li><li><a href="#maps">地图</a></li><li><a href="#media">媒体</a><ul><li><a href="#image">图片</a></li><li><a href="#video">视频</a></li><li><a href="#pdf">PDF</a></li></ul></li><li><a href="#messaging">消息</a></li><li><a href="#networking">网络</a></li><li><a href="#push-notifications">推送通知</a></li><li><a href="#passbook">Passbook</a></li><li><a href="#permissions">权限</a></li><li><a href="#text">文本</a></li><li><a href="#walkthrough--intro--tutorial">浏览 / 介绍 / 教程</a></li><li><a href="#url-scheme">URL Scheme</a></li><li><a href="#ui">UI</a></li><li><a href="#websocket">Websocket</a></li><li><a href="#code-quality">代码质量</a></li><li><a href="#analytics">分析</a></li><li><a href="#payments">支付</a></li><li><a href="#products">产品化工具</a></li><li><a href="#utility">实用工具</a></li><li><a href="#security">安全</a></li></ul></li></ul><ul><li><a href="#project-setup">安装项目</a></li><li><a href="#dependency--package-manager">依赖 / 包管理</a></li><li><a href="#testing">测试</a><ul><li><a href="#tdd--bdd">测试驱动开发（TDD） / 行为驱动开发（BDD）</a></li><li><a href="#ui-testing">UI测试</a></li><li><a href="#beta-distribution">Beta 测试</a></li><li><a href="#other-testing">其他测试</a></li></ul></li><li><a href="#toolchains">工具链</a></li><li><a href="#tools">工具</a></li><li><a href="#rapid-development">敏捷开发</a></li><li><a href="#deployment">部署</a></li><li><a href="#app-store">App Store</a></li><li><a href="#sdk">SDK</a></li><li><a href="#xcode">Xcode</a><ul><li><a href="#plugins">插件</a></li><li><a href="#themes">主题</a></li><li><a href="#other-xcode">其他 Xcode 相关</a></li></ul></li><li><a href="#style-guides">编码规范</a></li><li><a href="#good-websites">一些好网站</a><ul><li><a href="#news-blogs-and-more">新闻, 博客等</a></li><li><a href="#uikit-references">UIKIt 文档</a></li><li><a href="#forums-and-discuss-lists">论坛和讨论列表</a></li><li><a href="#tutorials-and-keynotes">教程和 Keynotes</a></li><li><a href="#prototyping">原型</a></li></ul></li><li><a href="#twitter">Twitter</a></li><li><a href="#facebook-groups">Facebook 群组</a></li><li><a href="#podcasts">播客（Podcasts）</a></li><li><a href="#books">书籍</a></li><li><a href="#other-awesome-lists">其他优秀的列表</a></li><li><a href="#contributing">贡献</a></li></ul><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a><a name="getting-started"></a>入门</h1><ul><li><a href="https://developer.apple.com/library/prerelease/ios/referencelibrary/GettingStarted/DevelopiOSAppsSwift/">Road Map iOS</a> - 开发 iOS 应用从今天开始，苹果指南。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="http://lifehacker.com/i-want-to-write-ios-apps-where-do-i-start-1644802175">Lifehacker</a> - 我想写一个 iOS 应用，该从哪里开始？</li><li><a href="http://www.codeproject.com/Articles/88929/Getting-Started-with-iPhone-and-iOS-Development">Codeproject</a> - 入门 iPhone 和 iOS 应用开发。</li><li><a href="http://www.raywenderlich.com/38557/learn-to-code-ios-apps-1-welcome-to-programming">Ray Wenderlich</a> - 学习 iOS 应用开发。</li><li><a href="https://itunes.apple.com/us/itunes-u/developing-apps-for-ios-hd/id395605774?mt=10">Stanford - Developing Apps to iOS</a> - 斯坦福在 iTunes U 上的 App 开发课程（音频和视频）。</li><li><a href="https://itunes.apple.com/us/course/developing-ios-8-apps-swift/id961180099">Stanford - Developing iOS 8 Apps with Swift</a> - 斯坦福在 iTunes U 上的 App 开发课程（2015版）。<img src="/images/swift_logo.png" width="20" height="20"></li></ul><h1 id="库和框架"><a href="#库和框架" class="headerlink" title="库和框架"></a><a name="libraries-and-frameworks"></a>库和框架</h1><h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a><a name="audio"></a>音频</h3><ul><li><a href="https://developer.audiob.us/">AudioBus</a> - 下一代 App 到 App 的实时音频路由。</li><li><a href="https://github.com/audiokit/AudioKit">AudioKit</a> - 一个强大的音频合成，处理和分析的工具集。</li><li><a href="https://github.com/syedhali/EZAudio">EZAudio</a> - 一个基于 Core Audio 的 iOS/OSX 音频可视化框架。用于实时，低延迟的音频处理和可视化功能的开发。</li><li><a href="https://github.com/alexbw/novocaine">novocaine</a> - 应用于 OSX 和 iOS 的非侵入性的高性能音频框架。</li><li><a href="https://github.com/quentinhayot/QHSpeechSynthesizerQueue">QHSpeechSynthesizerQueue</a> - 一个 <code>AVSpeechSynthesizer</code>（iOS文本发音） 的队列管理系统。</li><li><a href="https://github.com/tumtumtum/StreamingKit">StreamingKit</a> - 一个针对 OSX 和 iOS 中 <code>AudioPlayer/AudioStreamer</code> 快捷的无缝扩展。</li><li><a href="https://github.com/evgenyneu/sound-fader-ios">sound-fader-ios</a> - 一个 Swift 写的 <code>AVAudioPlayer</code> 的声音控制器 <img src="/images/swift_logo.png" width="20" height="20"></li></ul><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a><a name></a>动画</h3><ul><li><a href="https://github.com/facebook/pop">Pop</a> - 富有扩展性的 iOS 和 OS X 动画库，可以方便地实现由物理效果的交互。</li><li><a href="https://github.com/intuit/AnimationEngine">AnimationEngine</a> - 可以在 iOS 上方便地构建高级自定义动画。</li><li><a href="https://github.com/jackyzh/awesome-ios-animation">Awesome-iOS-Animation</a> - 一个动画项目的集合。</li><li><a href="https://github.com/Raizlabs/RZTransitions">RZTransitions</a> - iOS View Controller 过场动画库。</li><li><a href="https://github.com/daltoniam/DCAnimationKit">DCAnimationKit</a> - iOS 动画集合。很简单，只需要添加流水动画。</li><li><a href="https://github.com/MengTo/Spring">Spring</a> - 一个简单的 Swift iOS 动画库。</li><li><a href="https://github.com/CanvasPod/Canvas">Canvas</a> - 无需代码就可以在 Xcode 中显示动画 <a href="http://canvaspod.io">http://canvaspod.io</a>。</li><li><a href="https://github.com/matthewcheok/Fluent">Fluent</a> - 便捷的 Swift 动画框架。 <img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/suguru/Cheetah">Cheetah</a> - 便捷的 iOS 动画库，由 Swift2 编写。 <img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/soheil/RadialLayer">RadialLayer</a> - 针对可点击元素的动画（类似于 Youtube Music）<img src="/images/swift_logo.png" width="20" height="20"></li></ul><h3 id="Apple-TV"><a href="#Apple-TV" class="headerlink" title="Apple TV"></a><a name="apple-tv"></a>Apple TV</h3><ul><li><a href="https://github.com/rsattar/Voucher">Voucher</a> - 方便 tvOS App 通过 iOS 设备上相应的程序来认证的库。</li></ul><h3 id="桥接"><a href="#桥接" class="headerlink" title="桥接"></a><a name="bridging"></a>桥接</h3><ul><li><a href="https://github.com/bang590/JSPatch">JSPatch</a> - JSPatch 利用 Objective-C 运行时桥接了 Objective-C 和 Javascript。你仅需引入一个小的引擎，就可以使用 JS 调用任何 Objective-C 的类。JSPatch 通常用来对 iOS App 进行在线修复（hotfix）。</li></ul><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a><a name="cache"></a>缓存</h3><ul><li><a href="https://github.com/steipete/SDURLCache">SDURLCache</a> - URLCache 的子类，可以为 iPhone/iPad 应用提供的本地磁盘缓存。</li><li><a href="https://github.com/aschuch/AwesomeCache">Awesome Cache</a> - 让人喜爱的本地缓存 <img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/buzzfeed/mattress">mattress</a> - iOS Web 内容的离线缓存 <img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/WeltN24/Carlos">Carlos</a> - 简单但却灵活的缓存 <img src="/images/swift_logo.png" width="20" height="20"></li></ul><h3 id="图表"><a href="#图表" class="headerlink" title="图表"></a><a name="charts"></a>图表</h3><ul><li><a href="https://github.com/danielgindi/ios-charts">ios-charts</a> - 一个强大的图表框架，<a href="https://github.com/PhilJay/MPAndroidChart">MPAndroidChart</a> 在 iOS 上的移植。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/kubatru/JTChartView">JTChartView</a> - JTChartView 是一个完全可定制的轻量级图表解决方案。</li><li><a href="https://github.com/kevinzhow/PNChart">PNChart</a> - 一个简单漂亮的图表库，Pinner 和 CoinsMan 的iOS客户端中使用了这个框架。</li><li><a href="https://github.com/Boris-Em/BEMSimpleLineGraph">BEMSimpleLineGraph</a> - 优雅的折线图框架。</li><li><a href="https://github.com/Jawbone/JBChartView">JBChartView</a> - 基于 iOS 的图表库，包含折线图和直方图。</li><li><a href="https://github.com/honcheng/iOSPlot">iOSPlot</a> - iOS 图表库。</li><li><a href="https://github.com/xyfeng/XYPieChart">XYPieChart</a> - 一个有动画的饼图框架。</li><li><a href="https://github.com/xhacker/TEAChart">TEAChart</a> - 简单易用的 iOS 图表库。包括了贡献图，时钟图，直方图。</li><li><a href="https://github.com/zhuhuihuihui/EChart">EChart</a> - iOS/iPhone/iPad 图表。提供了事件处理和动画支持。</li><li><a href="https://github.com/ArthurGuibert/FSLineChart">FSLineChart</a> - 一个 iOS 折线图库。</li><li><a href="https://github.com/zhiyu/chartee">chartee</a> - 一个为移动平台设计的图表库。</li><li><a href="https://github.com/anaglik/ANDLineChartView">ANDLineChartView</a> - 使用 ANDLineChartView 可以便捷的在视图类中显示有动画效果的折线图。</li><li><a href="https://github.com/chasseurmic/TWRCharts">TWRCharts</a> - 一个 ChartJS 的 iOS 封装。结合 Obj-C 原生代码便捷的构建有动画的图表。</li></ul><h3 id="Core-Data"><a href="#Core-Data" class="headerlink" title="Core Data"></a><a name="core-data"></a>Core Data</h3><ul><li><a href="https://github.com/jayway/CWCoreData">CWCoreData</a> - 方便并发环境下 CoreData 框架开发的扩展与实用工具。</li><li><a href="https://github.com/supermarin/ObjectiveRecord">ObjectiveRecord</a> - ActiveRecord 的 Objective-C 版本。</li><li><a href="https://github.com/soffes/SSDataKit">SSDataKit</a> - 消灭使用 CoreData 产生的样板代码。</li><li><a href="https://github.com/martydill/ios-queryable">ios-queryable</a> - ios-queryable 是一个基于 CoreData 的 IQueryable/IEnumerable 实现。</li><li><a href="https://github.com/apparentsoft/ReactiveCoreData">ReactiveCoreData</a> - ReactiveCoreData (RCD) 是一个将 CoreData 带入 ReactiveCocoa 世界的尝试。</li><li><a href="https://github.com/drewmccormack/ensembles">Ensembles</a> - 一个 CoreData 同步框架。</li><li><a href="https://github.com/OliverLetterer/SLRESTfulCoreData">SLRESTfulCoreData</a> - 根据Objc 命名习惯，在运行时自动生成访问器，URL替换和智能属性映射。</li><li><a href="https://github.com/rentzsch/mogenerator">Mogenerator</a> - 自动生成 CoreData 代码。</li><li><a href="https://github.com/Krivoblotsky/HardCoreData">HardCoreData</a> - 不会阻塞 UI 线程的 CoreData 栈和控制器。</li><li><a href="https://github.com/project-imas/encrypted-core-data">encrypted-core-data</a> - 使用 SQLClipher 对 CoreData 的 SQLite 存储进行加密。</li><li><a href="https://github.com/magicalpanda/MagicalRecord">MagicalRecord</a> - 非常优秀的 CoreData 便捷存取框架。</li><li><a href="https://github.com/QueryKit/QueryKit">QueryKit</a> - 一个简洁的类型安全的 CoreData 查询语言 <img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/JohnEstropia/CoreStore">CoreStore</a> - 强大的 CoreData 框架，解决了增量迁移，获取，观察等问题。<img src="/images/swift_logo.png" width="20" height="20"></li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><a name="database"></a>数据库</h3><ul><li><a href="https://github.com/realm/realm-cocoa">Realm</a> - CoreData 和 SQLite 的替代品。它简洁，现代，快速。</li><li><a href="https://github.com/yapstudios/YapDatabase">YapDatabase</a> - YapDatabase 是一个 iOS 和 Mac 上可扩展的数据库。</li><li><a href="http://developer.couchbase.com/mobile/">Couchbase Mobile</a> - Couchbase，有云同步支持的移动平台上的文档存储。</li><li><a href="https://github.com/ccgus/fmdb">FMDB</a> - SQLite 的 Cocoa/Objective-C 封装。</li><li><a href="https://github.com/roytang121/Akaibu-NSUserDefaults">Akaibu-NSUserDefaults</a> - Swift 键－值存储，只需要一行代码就可以对 NSObject 对象进行归档。类的属性会自动映射和归档。</li><li><a href="https://github.com/marcoarment/FCModel">FCModel</a> - 为那些喜欢直接使用 SQL 进行数据库操作的人提供的 CoreData 的替代品。</li><li><a href="https://github.com/ArtSabintsev/Zephyr">Zephyr</a> - 轻松地通过 iCloud 同步 NSUserDefaults <img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/phimage/Prephirences">Prephirences</a> - Prephirences 是一个提供了有用的协议和便捷的方法来管理应用的偏好设置，配置和应用状态的 Swift 库。<img src="/images/swift_logo.png" width="20" height="20"></li></ul><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a><a name></a>加密</h3><ul><li><a href="https://github.com/Gurpartap/AESCrypt-ObjC">AESCrypt-ObjC</a> - 一个简单固执的 AES 加密／解密类，然而它就是可以很好的工作。</li></ul><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a><a name="hardware"></a>硬件</h3><h5 id="动作"><a href="#动作" class="headerlink" title="动作"></a><a name="motion"></a>动作</h5><ul><li><a href="https://github.com/MHaroonBaig/MotionKit">MotionKit</a> - 只需要两行或者很少的几行代码就可以从加速度传感器，陀螺仪和磁力传感器获取数据。现在 CoreMotion 让这些变得前所未有的简单。</li></ul><h5 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a><a name="bluetooth"></a>蓝牙</h5><ul><li><a href="https://github.com/omergul123/Discovery">Discovery</a> - 这是个很简单的库，用来从附近的设备上发现和获取数据（即便种子 app 在后台工作）。</li><li><a href="https://github.com/l0gg3r/LGBluetooth">LGBluetooth</a> - 基于 CoreBluetooth 的一个轻量级库，基于 block 制作。它能够让你程序中的 CoreBluetooth 相关的代码更加简洁。</li><li><a href="https://github.com/jpsim/PeerKit">PeerKit</a> 一个用于事件驱动，零配置的 Multipeer 连接应用程序的开源 Swift 框架。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/lauraskelton/simple-share">simple-share</a> - 一个基于蓝牙LE共享的框架，易于实现附近设备的连接。</li><li><a href="https://github.com/rasmusth/BluetoothKit">BluetoothKit</a> - 使用 BLE 在 iOS/OSX 设备之间通讯的框架<img src="/images/swift_logo.png" width="20" height="20"></li></ul><h5 id="位置"><a href="#位置" class="headerlink" title="位置"></a><a name="location"></a>位置</h5><ul><li><a href="https://github.com/IngeoSDK/ingeo-ios-sdk">IngeoSDK</a> - 总是处于开启状态的 iOS 位置显示框架。</li><li><a href="https://github.com/Proxitee/iOS-SDK">Proxitee</a> - 允许开发者利用 iBeacons 和地理围栏创建近场感知的应用。</li><li><a href="https://github.com/intuit/LocationManager">LocationManager</a> - 实现了一次性或者持续请求当前位置的功能，提供了基于 block 的异步 API。</li><li><a href="https://locationkit.io">LocationKit</a> - 高级位置 SDK － 只使用很少的电量和上下文相关的位置信息就可以提供高精确度的位置数据。</li></ul><h5 id="iBeacon"><a href="#iBeacon" class="headerlink" title="iBeacon"></a><a name="ibeacon"></a>iBeacon</h5><ul><li><a href="https://github.com/Proxitee/iOS-SDK">Proxitee</a> - 允许开发者利用 iBeacons 和地理围栏创建近场感知的应用。</li><li><a href="https://github.com/ohwutup/OWUProximityManager">OWUProximityManager</a> - 一个方便的 iBeacon + CoreBluetooth 管理器。</li><li><a href="https://github.com/Instrument/Vicinity">Vicinity</a> - 复制邻近的iBeacons （通过分析RSSI），并支持在后台广播和检测 BLE 设备。</li><li><a href="https://github.com/lgaches/BeaconEmitter">BeaconEmitter</a> - 把你的 Mac 变成一个 iBeacon。</li><li><a href="https://github.com/ohwutup/OWUProximityManager">OWUProximityManager</a> - iBeacons + CoreBluetooth.</li></ul><h3 id="HUD"><a href="#HUD" class="headerlink" title="HUD"></a><a name="hud"></a>HUD</h3><ul><li><a href="https://github.com/jdg/MBProgressHUD">MBProgressHUD</a> - 用于显示一个半透明的 HUD。当任务在后台线程结束时可以在上边显示一个指示器和／或者标签。</li><li><a href="https://github.com/TransitApp/SVProgressHUD">SVProgressHUD</a> - 一个为你的 iOS 应用制作的简洁，轻量级的进度指示 HUD。</li><li><a href="https://github.com/relatedcode/ProgressHUD">ProgressHUD</a> - ProgressHUD 是一个轻量易用的 HUD。</li><li><a href="https://github.com/Marxon13/M13ProgressSuite">M13ProgressSuite</a> - 一个包含了很多 iOS 上用于显示进度信息工具的套装。</li><li><a href="https://github.com/harikrishnant1991/JHProgressHUD">JHProgressHUD</a> - 一个简单轻量的 Swift 框架，用于在 iOS 应用中显示<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/pkluz/PKHUD">PKHUD</a> - 用 Swift 重新实现了 Apple 的原生 HUD，支持 iOS 8 以上<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/goktugyil/CozyLoadingActivity">CozyLoadingActivity</a> - 轻量的载入动作指示 HUD <img src="/images/swift_logo.png" width="20" height="20"></li></ul><h3 id="事件总线"><a href="#事件总线" class="headerlink" title="事件总线"></a><a name="eventbus"></a>事件总线</h3><ul><li><a href="https://github.com/coshx/caravel">Caravel</a> - 用于 UIWebView 和 JS 的 Swift 事件总线。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/cesarferreira/SwiftEventBus">SwiftEventBus</a> - 一个真对 iOS 8 优化的发布／订阅事件总线。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/mxcl/PromiseKit">PromiseKit</a> - iOS 和 OS X 上的 Promises 实现。</li><li><a href="https://github.com/BoltsFramework/Bolts-iOS">Bolts</a> - Bolts 是一个试图使构建移动应用更简单的一个底层库集合。包括了任务（promises）和应用关联（deep links）。</li><li><a href="https://github.com/ReactKit/SwiftTask">SwiftTask</a> - Swift 实现的 Promise + progress + pause + cancel + retry。 <img src="/images/swift_logo.png" width="20" height="20"></li></ul><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a><a name="files"></a>文件</h3><ul><li><a href="https://github.com/nvzqz/FileKit">FileKit</a> - Swift 实现的简单快捷的文件管理工具。<img src="/images/swift_logo.png" width="20" height="20"></li></ul><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a><a name="json"></a>JSON</h3><ul><li><a href="https://github.com/johnezang/JSONKit">JSONKit</a> - Objective-C JSON 工具.</li><li><a href="https://github.com/TouchCode/TouchJSON">TouchJSON</a> - 一个 Objective-C 的 JSON 框架。</li><li><a href="https://github.com/stig/json-framework">JSON-Framework</a> - 这个框架用 Objective-C 实现了一个严格的 JSON 解释器和生成器。</li><li><a href="https://github.com/Mantle/Mantle">Mantle</a> - 面向 Cocoa 和 Cocoa Touch 的模型框架 Model 。</li><li><a href="https://github.com/gonzalezreal/Groot">Groot</a> - 实现呃 JSON 字典或者数组和 Core Data Mangement 对象之间的转换。</li><li><a href="https://github.com/krzysztofzablocki/KZPropertyMapper">KZPropertyMapper</a> - 以最少的代码实现数据映射和验证。</li><li><a href="https://github.com/icanzilb/JSONModel">JSONModel</a> - 神奇的基于 JSON 的数据模型化框架。创建了一系列敏捷便利，自动并且智能的模型类。</li><li><a href="https://github.com/SwiftyJSON/SwiftyJSON">SwiftyJSON</a> - 使用 Swift 处理 JSON 数据的好方法。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/Yalantis/FastEasyMapping">FastEasyMapping</a> - 快速地序列化和反序列化 JSON 数据。</li><li><a href="https://github.com/aryaxt/OCMapper">OCMapper</a> - Objective-C &amp; Swift 通用的快速 JSON 模型转化框架 <img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/Hearst-DD/ObjectMapper">ObjectMapper</a> - 在模型对象（包括 class 和 struct）和 JSON 之间转换的 Swift 框架。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/delba/JASON">JASON</a> - 性能优秀操作便捷的 JSON 解析。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/hkellaway/Gloss">Gloss</a> - 一个 Swift 写的 JSON 解析库。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/Weebly/Cereal">Cereal</a> - Swift 对象序列化 <img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/insanoid/SwiftyJSONAccelerator">SwiftyJSONAccelerator</a> - 使用 SwiftyJSON 或者 ObjectMapper 根据 JSON 生成 Swift 模型。支持 NSCoding 并且提供了使用 JSON 来表示模型的方法。<img src="/images/swift_logo.png" width="20" height="20"></li></ul><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a><a name="layout"></a>布局</h3><ul><li><a href="https://github.com/alexdrone/ios-flexboxkit">ios-flexboxkit</a> - 一个封装了 Flexbox 布局的简单 UIKit 扩展。</li><li><a href="https://github.com/SnapKit/Masonry">Masonry</a> -  利用简单的，链式的语法发挥出自动布局 NSLayoutConstraints 的强大功能。</li><li><a href="https://github.com/floriankugler/FLKAutoLayout">FLKAutoLayout</a> - 让使用代码做约束更加简便的 UIView 类别。</li><li><a href="https://github.com/mamaral/Facade">Façade</a> - 可编程的视图布局，一个 autolayout 的替代品。</li><li><a href="https://github.com/PureLayout/PureLayout">PureLayout</a> - 终极的 iOS 和 OS X 上的 Autolayout API，极其简单又异常强大。同时适用于 Objective-C 和 Swift。</li><li><a href="https://github.com/SnapKit/SnapKit">SnapKit</a> - 一个 iOS 和 OS X 的 Swift Autolayout 领域专用语言（DSL）。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/robb/Cartography">Cartography</a> - 一个 Swift 编写的声明式 Auto Layout 领域专用语言（DSL）。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/ruipfcosta/AutoLayoutPlus">AutoLayoutPlus</a> - 给 Auto Layout 加的一点料，由 Swift 驱动。 <img src="/images/swift_logo.png" width="20" height="20"></li></ul><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a><a name="logging"></a>日志</h3><ul><li><a href="https://github.com/emaloney/CleanroomLogger">CleanroomLogger</a> - 一个基于 Swift 可配置可扩展的日志 API，简洁，轻量并且高效。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/CocoaLumberjack/CocoaLumberjack">CocoaLumberjack</a> - 一个快捷强大灵活的日志框架（iOS &amp; Mac）。</li><li><a href="https://github.com/fpillet/NSLogger">NSLogger</a> - 一个高性能的日志工具，它可以显示运行在 OS X，iOS 和 Android 上客户端应用的踪迹。</li><li><a href="https://github.com/square/Aardvark/">Aardvark</a> - 一个高性能日志框架，它使得创建可操作的 bug 报告变得非常简单。</li><li><a href="https://github.com/conradev/BlockTypeDescription">BlockTypeDescription</a> - 在日志记录 block 的时候显示类型签名。</li><li><a href="https://github.com/goktugyil/QorumLogs">QorumLogs</a> — 为 Xcode 和 Google Docs 设计的 Swift 日志工具。<img src="/images/swift_logo.png" width="20" height="20"> </li></ul><h3 id="地图"><a href="#地图" class="headerlink" title="地图"></a><a name="maps"></a>地图</h3><ul><li><a href="https://github.com/route-me/route-me">Route-me</a> - iOS 开源地图框架</li><li><a href="https://github.com/neilang/NAMapKit">NAMapKit</a> - 允许你在 iPhone 应用使用自定义地图，并尝试模仿 Mapkit 框架的一些行为。</li><li><a href="https://github.com/mapbox/mapbox-gl-native">Mapbox GL</a> - 一个 iOS 上使用 OpenGL 渲染 Mapbox 矢量地图块的框架。</li><li><a href="https://github.com/citymapper/CMMapLauncher">CMMapLauncher</a> - 用于 iOS 中在各种地图应用中显示方向的便捷框架。 </li></ul><h3 id="媒体"><a href="#媒体" class="headerlink" title="媒体"></a><a name="media"></a>媒体</h3><h5 id="图片"><a href="#图片" class="headerlink" title="图片"></a><a name="image"></a>图片</h5><ul><li><a href="https://github.com/BradLarson/GPUImage">GPU Image</a> - 一个基于 GPU 的 iOS 开源的图像和视频处理框架。</li><li><a href="https://github.com/gdawg/uiimage-dsp">UIImage DSP</a> - iOS UIImage 处理功能，它使用 vDSP/Accelerate 框架来提高速度。</li><li><a href="http://www.appcoda.com/qr-code-ios-programming-tutorial/">QR Code Scanner</a> - 二维码扫描。</li><li><a href="https://github.com/nicklockwood/AsyncImageView">AsyncImageView</a> - UIImageView 的异步图像加载和显示扩展，不会阻塞 UI 线程。</li><li><a href="https://github.com/rs/SDWebImage">SDWebImage</a> - 异步的图像下载器，提供了缓存支持。以 UIImageView 类别的方式提供。</li><li><a href="https://github.com/kean/DFImageManager">DFImageManager</a> - 从多种数据源获取图像的现代框架。无需配置，并具有高度的可定制性和扩展性。使用了 NSURLSession。</li><li><a href="https://github.com/zalando/MapleBacon">MapleBacon</a> - 一个 Swift iOS 图像下载和缓存库 <img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/NYTimes/NYTPhotoViewer">NYTPhotoViewer</a> - 抽屉菜单和照片查看器。</li><li><a href="https://github.com/ideaismobile/IDMPhotoBrowser">IDMPhotoBrowser</a> - 图片浏览器／查看器。</li><li><a href="https://github.com/jaredsinclair/JTSImageViewController">JTSImageViewController</a> - iOS 交互式图片浏览器。</li><li><a href="https://github.com/contentful-labs/Concorde/">Concorde</a> - 下载和解码连续的 JPEG 图像。</li><li><a href="https://github.com/rFlex/SCRecorder">SCRecorder</a> - 类似 Vine 的点击拍摄，动画过滤器，慢镜头，片段编辑相机引擎。</li><li><a href="https://github.com/Haneke/HanekeSwift">HanekeSwift</a> - 一个 Swift 编写的 iOS 平台的轻量级通用缓存框架，还有对图像的更多支持。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/TimOliver/TOCropViewController">TOCropViewController</a> - 一个可以允许用户修改 UIImage 对象的视图控制器。</li><li><a href="https://github.com/hanton/YXTMotionView">YXTMotionView</a> - 一个自定义的图片视图，它实现了依靠设备运动来滚动图片。</li><li><a href="https://github.com/pinterest/PINRemoteImage">PINRemoteImage</a> - 一个线程安全，高性能，特性丰富的图像获取器。</li><li><a href="https://github.com/szk-atmosphere/SABlurImageView">SABlurImageView</a> - 可以轻松地为图片添加模糊动画效果。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/path/FastImageCache">FastImageCache</a> - 在滚动时快速显示图片的 iOS 框架。</li><li><a href="https://github.com/bkoc/BKAsciiImage">BKAsciiImage</a> - 将图片渲染为 ASCII art 的库。</li><li><a href="https://github.com/liyong03/YLGIFImage">YLGIFImage</a> - 异步的 GIF 图像解码和图片浏览器。支持 GIF 图动画，但只消耗少量的内存。</li><li><a href="https://github.com/Alamofire/AlamofireImage">AlamofireImage</a> - 一个为 Alamofire 制作的图像组件库。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/kean/Nuke">Nuke</a> - 高级的图片管理框架。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/madebybowtie/FlagKit">FlagKit</a> - 供 app 和 web 页面上使用的漂亮旗标。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/ibireme/YYWebImage">YYWebImage</a> - 异步图像加载框架（支持 WebP，APNG，GIF 格式）。</li></ul><h5 id="视频"><a href="#视频" class="headerlink" title="视频"></a><a name="video"></a>视频</h5><ul><li><a href="https://github.com/vimeo/VIMVideoPlayer">VIMVideoPlayer</a> - 一个对 AVPlayer 和 AVPlayerLayer 类的简单封装。</li><li><a href="https://github.com/mobileplayer/mobileplayer-ios">MobilePlayer</a> - 一个强大完善且完全可定制的 iOS 媒体播放器。</li></ul><h5 id="PDF"><a href="#PDF" class="headerlink" title="PDF"></a><a name="pdf"></a>PDF</h5><ul><li><a href="https://github.com/vfr/Reader">Reader</a> - 一个 iOS PDF 阅读器的核心。</li><li><a href="https://github.com/RobertAPhillips/UIView_2_PDF">UIView 2 PDF</a> - <a href="https://github.com/RobertAPhillips/UIView_2_PDF">https://github.com/RobertAPhillips/UIView_2_PDF</a></li></ul><h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a><a name="messaging"></a>消息</h3><ul><li><a href="https://github.com/layerhq/releases-ios">LayerKit</a> - 一个对于 Layer 的 iOS 开发组件,。是将消息（文字，照片，视频，数据）添加到移动或 Web 应用中最简单的解决方案。</li><li><a href="https://www.twilio.com/">Twilio</a> - 驱动着现代的交流方式，构建下一代音频与 SMS 应用。</li><li><a href="https://www.plivo.com/">Plivo</a> - SMS API, 音频 API 和 全球运营商。</li><li><a href="https://github.com/robbiehanson/XMPPFramework">XMPPFramework</a> - 一个 iOS 和 Mac 上的 XMPP 协议通讯框架。</li></ul><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a><a name="networking"></a>网络</h3><ul><li><a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a> - 一个得心应手的 iOS 和 OSX 上的网络请求框架。</li><li><a href="https://github.com/RestKit/RestKit">RestKit</a> - RestKit 是一个 iOS Objective-C 框架，是为了让和 RESTful web 服务交互变的简单，快捷，有趣。</li><li><a href="https://github.com/foursquare/FSNetworking">FSNetworking</a> - 稳固的 iOS 网络库。</li><li><a href="https://github.com/pokeb/asi-http-request">ASIHTTPRequest</a> - Objective-C 编写的 HTTP 网络请求库。它是对 CFNetwork 易用的封装。支持 Mac OS X 和 iPhone。</li><li><a href="https://github.com/Overcoat/Overcoat">Overcoat</a> - 小但是很强大的库，他让创建一个 REST 客户端简便和有趣。</li><li><a href="https://github.com/epam/road-ios-framework">ROADFramework</a> - 面向属性的 web 服务交互方式。框架有内建的 json 和 xml 请求响应序列化方法，十分方便扩展。</li><li><a href="https://github.com/emaloney/MBToolbox/blob/master/Code/Network/MBNetworkMonitor.h">MBNetworkMonitor</a> - 苹果 <code>Reachability</code> 类的现代化替代品，使用了 <code>CoreTelephony</code> 来传达更多<a href="https://rawgit.com/emaloney/MBToolbox/master/Documentation/html/Classes/MBNetworkMonitor.html">有关用户网络连接状况的信息</a>。</li><li><a href="https://github.com/emaloney/MBToolbox/blob/master/Code/Network/MBNetworkIndicator.h">MBNetworkIndicator</a> -  提供了简单的方式<a href="https://rawgit.com/emaloney/MBToolbox/master/Documentation/html/Classes/MBNetworkIndicator.html">在多个请求之间协调设备网络指示器。</a>.</li><li><a href="https://github.com/Alamofire/Alamofire">Alamofire</a> - Alamofire 是一个 Swift 写的 HTTP 网络库，由 AFNetworking 的作者编写。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/nghialv/Transporter">Transporter</a> - 让上传下载更便捷的小代码库。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/cdzombak/CDZPinger">CDZPinger</a> - 使用方便的 ICMP Ping 框架。</li><li><a href="https://github.com/dingbat/nsrails">NSRails</a> - 将客户端的对象／类映射到远程 rest api 的对象／ORM。</li><li><a href="https://github.com/nathankot/NKMultipeer">NKMultipeer</a> - 一个建立在多重链接上的可测试的抽象。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/robbiehanson/CocoaAsyncSocket">CocoaAsyncSocket</a> - 用于 Mac 和 iOS 的异步 socket 网络库。</li><li><a href="https://bustoutsolutions.github.io/siesta/">Siesta</a> - 优雅的 RESTful 资源抽象，将状态解藕。是基于回调或者代理的网络库的替代品。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/ashleymills/Reachability.swift">Reachability.swift</a> - 用 Swift 和闭包重新实现了苹果的 Reachablility 框架。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/coderyi/NetworkEye">NetworkEye</a> - 一个 iOS 网络调试库，可以显示 App 中的 HTTP 请求和请求的相关信息。</li></ul><h3 id="推送通知"><a href="#推送通知" class="headerlink" title="推送通知"></a><a name="push-notifications"></a>推送通知</h3><ul><li><a href="https://github.com/mattt/Orbiter">Orbiter</a> - 在 iOS 中注册推送通知。</li><li><a href="https://github.com/fastlane/PEM">PEM</a> - 为推送服务器自动生成 profile。</li><li><a href="https://parse.com/products/push">Parse Push</a> - 完全免费的后台推送通知，提供了创建分段，调度甚至 A/B 测试的能力。</li><li><a href="https://www.urbanairship.com/products/platform#push-messages">Urban Airship</a> - 付费的推送通知后台。</li><li><a href="https://growthpush.com">Growth Push</a> - 付费的推送通知。 它是在日本最受开发者喜爱的工具之一。</li><li><a href="https://github.com/KnuffApp/APNS-Pusher">APNS-Pusher</a> - 苹果推送通知服务的调试器。</li></ul><h3 id="Passbook"><a href="#Passbook" class="headerlink" title="Passbook"></a><a name="passbook"></a>Passbook</h3><ul><li><a href="https://github.com/frozon/passbook">passbook</a> - 为 Passbook 创建 pkpass 文件。</li><li><a href="https://github.com/nomad/dubai">Dubai</a> - 生成和预览 Passbook 的 Pass。</li><li><a href="https://passkit.com">Passkit</a> - 设计，创建并验证 Passbook 的 Pass。</li></ul><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a><a name="permissions"></a>权限</h3><ul><li><a href="https://github.com/nickoneill/PermissionScope">PermissionScope</a> - 智能的 iOS 授权 UI 和 统一的 API（支持位置，通知，照片，联系人，日历，照片，麦克风，BT，进度指示，HealthKit 和 CloudKit）。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/nixzhu/Proposer">Proposer</a> - 便捷地请求用户权限（支持相机，照片，麦克风，联系人，位置）。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/wircho/ICanHas">ICanHas</a> - 简化 iOS 用户权限请求（支持位置，推送通知，相机，联系人，日历，照片）。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/zakkhoyt/VWWPermissionKit">VWWPermissionKit</a> - 可视化的 iOS 授权管理器。</li><li><a href="https://github.com/iosphere/ISHPermissionKit">ISHPermissionKit</a> - 为 iOS 提供请求用户权限的统一方法。</li><li><a href="https://github.com/jlaws/JLPermissions">JLPermissions</a> - iOS 预授权工具，开发者用它来制作询问用户是否授权的对话框，支持日历，联系人，位置，照片，备忘录，twitter，推送通知和其他需要授权的操作。</li></ul><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a><a name="text"></a>文本</h3><ul><li><a href="https://github.com/twitter/twitter-text">Twitter Text Obj</a> - Twitter 的文本处理库的 Objective-C 实现。</li><li><a href="http://nimbuskit.info/">Nimbus</a> - Nimbus 是一个为高级 iOS 软件设计师制作工具包。</li><li><a href="https://github.com/diy/nsstringemojize">NSStringEmojize</a> - 一个将 Emoji 表情符号转换为等价的 Unicode 字串的 NSString 类别。</li><li><a href="https://github.com/mdiep/MMMarkdown">MMMarkdown</a> - 用于将 Markdown 转换为 HTML 的 Objective-C 静态库。</li><li><a href="https://github.com/Cocoanetics/DTCoreText">DTCoreText</a> - 利用 CoreText 使用 HTML 代码的方法。</li><li><a href="https://github.com/Cocoanetics/DTRichTextEditor">DTRichTextEditor</a> - 一个 iOS 的富文本编辑器。</li><li><a href="https://github.com/neerajbaid/NBEmojiSearchView">NBEmojiSearchView</a> - 一个支持搜索并且可以集成到文本控件中的 emoji  下拉列表视图。</li><li><a href="https://github.com/alexdrone/ios-fontawesome">ios-fontawesome</a> - NSString+FontAwesome.</li><li><a href="https://github.com/joshualat/Pluralize.swift">Pluralize.swift</a> - 强大的 Swift String 单数转换复数扩展。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/cjwirth/RichEditorView">RichEditorView</a> - RichEditorView 是一个简单，模块化，非侵入式的富文本编辑器视图。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/danthorpe/Money">Money</a> - 为与钱和现金相关工作的的 Swift 值类型。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/marmelroy/PhoneNumberKit">PhoneNumberKit</a> - 用于解析，格式化和验证国际电话号码的 Swift 框架，由谷歌的 libphonenumber 库支持。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/ibireme/YYText">YYText</a> - iOS 上用于显示和编辑富文本的强大文本框架。</li></ul><h3 id="功能漫游-介绍-教程"><a href="#功能漫游-介绍-教程" class="headerlink" title="功能漫游 / 介绍 / 教程"></a><a name="walkthrough--intro--tutorial"></a>功能漫游 / 介绍 / 教程</h3><ul><li><a href="https://github.com/mamaral/Onboard">Onboard</a> - 用一点点代码来创建一个漂亮的吸附效果的实践。</li><li><a href="https://github.com/ealeksandrov/EAIntroView">EAIntroView</a> - 高度可定制非侵入式的欢迎页面解决方案。</li><li><a href="https://github.com/MatthewYork/MYBlurIntroductionView">MYBlurIntroductionView</a> - 在 MYIntroductionView 上完善的，用于构建可定制的 app 介绍或者教程页面的框架。</li><li><a href="https://github.com/ariok/BWWalkthrough">BWWalkthrough</a> - 一个自定义 iOS App 的功能漫游页面的框架。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/GnosisHub/GHWalkThrough">GHWalkThrough</a> - 一个基于 UICollectionView 的非侵入式介绍页面组件。</li><li><a href="https://github.com/icepat/ICETutorial">ICETutorial</a> - 一个很好的教程框架，类似 Path 3.X 版本的 App 中的样式。</li><li><a href="https://github.com/IFTTT/JazzHands">JazzHands</a> - Jazz Hands 是一个简单的 UIKit 关键帧动画框架。动画是可以使用手势，滚动视图，KVO 或者 ReactiveCocoa 来控制的。</li><li><a href="https://github.com/IFTTT/RazzleDazzle">RazzleDazzle</a> - 简单的基于关键帧的 iOS 动画框架，由 Swift 编写。最适合用于 App 的滚动介绍页面。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/ephread/Instructions">Instructions</a> - 向你的 iOS 项目中添加自定义的操作方式指导的简单办法。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/ruipfcosta/SwiftyWalkthrough">SwiftyWalkthrough</a> - 创建一个体验绝佳的功能漫游的最简单方法，Swift 编写。<img src="/images/swift_logo.png" width="20" height="20"></li></ul><h3 id="URL-Scheme"><a href="#URL-Scheme" class="headerlink" title="URL Scheme"></a><a name="url-scheme"></a>URL Scheme</h3><ul><li><a href="https://github.com/Wasappli/WAAppRouting">WAAppRouting</a> - iOS 的路由实现。同时处理了 URL 识别和利用控制器显示解析后的参数。全部这些只要一行代码就可以搞定，控制器堆栈还会被自动保留！</li><li><a href="https://github.com/usebutton/DeepLinkKit">DeepLinkKit</a> - 杰出的路由匹配框架，使用基于 block API 处理你的深链接。</li><li><a href="https://github.com/intentkit/IntentKit">IntentKit</a> - 一个便捷的方法来在 iOS app 中处理第三方 URL schemes。</li><li><a href="https://github.com/joeldev/JLRoutes">JLRoutes</a> - 使用了 block  API 的 iOS URL 路由框架。</li></ul><h3 id="UI"><a href="#UI" class="headerlink" title="UI"></a><a name="ui"></a>UI</h3><ul><li><a href="https://github.com/ViccAlexander/Chameleon">Chameleon</a> - 一个 iOS 性能强大的轻量级扁平化颜色框架，可以用于 Objective-C 和 Swift。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/skywinder/ActionSheetPicker-3.0/">ActionSheetPicker-3.0</a> - 为 iOS App 快速制作一个下拉 UIPickerView / ActionSheet 功能。</li><li><a href="https://github.com/Grouper/FlatUIKit">FlatUIKit</a> - 适用于 iOS 的扁平化 UI 组件集合。</li><li><a href="https://github.com/jverdi/JVFloatLabeledTextField">JVFloatLabeledTextField</a> - 附有浮动标签的 UITextField 子类。</li><li><a href="https://github.com/StyleShare/SSBouncyButton">SSBouncyButton</a> - 有弹性的 iOS7 样式按钮 UI 组件。</li><li><a href="https://github.com/ice3-software/between-kit">BetweenKit</a> - 一个健壮的 iOS 拖拽框架。</li><li><a href="https://github.com/jessesquires/JSQMessagesViewController">JSQMessagesViewController</a> - 一个优雅的 iOS 聊天消息 UI 库。</li><li><a href="https://github.com/mtonio91/AMSmoothAlert">AMSmoothAlert</a> - 一个很 cool 的 AlertView.</li><li><a href="https://github.com/KrauseFx/TSMessages">TSMessages</a> - 在屏幕上方显示通知（比如成功，错误，警告或者消息）视图。</li><li><a href="https://github.com/NZN/NZAlertView">NZAlertView</a> - 简单直观的 AlertView。类似推送通知的效果。</li><li><a href="https://github.com/MortimerGoro/MGSwipeTableCell">MGSwipeTableCell</a> - 可以显示滑动按钮的 UITableViewCell 的子类，还支持多种过渡动画。</li><li><a href="https://github.com/alexruperez/ARAutocompleteTextView">ARAutocompleteTextView</a> - subclass of 实时显示文本提示的 UITextView 的子类。完美支持 e-mail 格式。</li><li><a href="https://github.com/tdginternet/TGCameraViewController">TGCameraViewController</a> - 基于 AVFoundation 的自定义相机。样式漂亮，轻量并且可以很容易地集成到 iOS 项目中。</li><li><a href="https://github.com/evnaz/ENSwiftSideMenu">ENSwiftSideMenu</a> - 一个 Swift 写的简洁 iOS7/8 侧滑菜单。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/modocache/MDCSwipeToChoose">MDCSwipeToChoose</a> -  滑动卡片来决定 “喜欢” 或者 “不喜欢” 的控件，效果类似 Tinder App。可以用于在几分钟内创建识字卡 app，图片浏览器或者其他类似应用，而不用几小时。</li><li><a href="https://github.com/Vinodh-G/ParallaxTableViewHeader">ParallaxTableViewHeader</a> - UITableView header 的视差滚动效果组件。</li><li><a href="https://github.com/devxoul/JLToast">JLToast</a> - iOS 的 Toast 组件，提供了简单的接口。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/codestergit/SweetAlert-iOS">SweetAlert</a> - 为 iOS 应用提供了实时动画效果的 AlertView，Swift 编写而成。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/hyperoslo/Form">Form</a> - JSON 驱动的 列表控件。</li><li><a href="https://github.com/bryankeller/BLKFlexibleHeightBar">BLKFlexibleHeightBar</a> - 创建一个高度可以自动调整的 NavigationBar，类似 Facebook ，Square Cash，Safari 中的那样。</li><li><a href="https://github.com/psy2k/NMPopUpView">NMPopUpView</a> - 用于显示浮动窗口的简单 iOS 类。支持 Swift 和 Objective-C。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/0x73/SDevIconFonts">SDevIconFonts</a> - 用于 Swift 的 Fontawesome, Iconic, Ionicons, Octicon。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/0x73/SDevBootstrapButton">SDevBootstrapButton</a> - Swift 版的 Twitter Bootstrap 按钮。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/0x73/SDevCircleButton">SDevCircleButton</a> - Swift 实现的圆型按钮。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/0x73/SDevFlatColors">SDevFlatColors</a> - Swift 实现的扁平化颜色。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/vinhnx/ColorArt">ColorArt</a> - 从图片中取出主要颜色，类似 iTunes 11 的效果。</li><li><a href="https://github.com/hackiftekhar/IQKeyboardManager">IQKeyboardManager</a> - 防止键盘滑出来遮挡住 UITextField/UITextView 的框架，非侵入，无需代码。</li><li><a href="https://github.com/wczekalski/WCFastCell">WCFastCell</a> - 滚动流畅的 Tables/Collections cell (没有动画)。</li><li><a href="https://github.com/erichoracek/Motif">Motif</a> - 一个基于 JSON 的可定制轻量级样式表框架。</li><li><a href="https://github.com/victorBaro/VBFPopFlatButton">VBFPopFlatButton</a> - 基于 Facebook POP制作的，有9种不同状态动画的扁平化按钮。</li><li><a href="https://github.com/herinkc/HTPressableButton">HTPressableButton</a> - 扁平化设计的可以按压的按钮。</li><li><a href="https://github.com/GabrielAlva/Cool-iOS-Camera">Cool-iOS-Camera</a> - 一个完全可定制的现代的照相机，使用 AVFoundation 框架实现。</li><li><a href="https://github.com/facebook/AsyncDisplayKit/">AsyncDisplayKit</a> - AsyncDisplayKit 是一个 iOS 框架，它能够使一个很复杂的用户界面保持平滑和反应灵敏。</li><li><a href="https://github.com/andreamazz/AMTagListView">AMTagListView</a> - 一个可以添加一系列高度可定制化的标签的 UIScrollView 子类。</li><li><a href="https://github.com/fastred/MotionBlur">MotionBlur</a> - MotionBlur 让你可以在 iOS 动画效果上添加模糊效果。</li><li><a href="https://github.com/piemonte/PBJVision">PBJVision</a> - iOS 相机引擎，支持点击拍摄，慢动作视频和图片捕捉功能。</li><li><a href="https://github.com/yannickl/DynamicColor">DynamicColor</a> - 又一个用于操作颜色的 Swift 扩展。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/skywinder/GaugeKit">GaugeKit</a> - 可定制的仪表组件，可以方便地仿制苹果样式的仪表盘。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/TransitApp/SVWebViewController">SVWebViewController</a> - 一个非侵入式的内置浏览器。</li><li><a href="https://github.com/meismyles/SwiftWebVC">SwiftWebVC</a> - 一个 SVWebViewController 的 Swift 实现。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/mrugrajsinh/MVAutocompletePlaceSearchTextField">MVAutocompletePlaceSearchTextField</a> - 一个类似 Google Places，Uber 等位置搜索的非侵入式自动完成控件。</li><li><a href="https://github.com/mrugrajsinh/MVMaterialView">MVMaterialView</a> - 用来模仿 Material Design 概念波纹（Ripple）效果 UI 控件的子类和 UIButton。</li><li><a href="https://github.com/layerhq/Atlas-iOS">Atlas</a> -  为 Layer 设计的原生 iOS 消息应用 UI 组件。</li><li><a href="https://github.com/GabrielAlva/Swift-Prompts">Swift-Prompts</a> - 用来设计自定义提示的 Swift 库，有很大的范围可供选择。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/hackiftekhar/IQDropDownTextField">IQDropDownTextField</a> - 提供了下拉 UIPickerView 支持的 UITextField。 </li><li><a href="https://github.com/PrajeetShrestha/PJAlertView">PJAlertView</a> - 苹果弃用了原来好用的警告视图，让我们失去了很多的定制性，这个库重新将定制性带回来。</li><li><a href="https://github.com/chenzeyu/CZPicker">CZPicker</a> - iOS 的 Popup 样式的 UIPickerView.</li><li><a href="https://github.com/tispr/tispr-card-stack">TisprCardStack</a> - 卡片 UI 库。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/hanton/YXTPageView">YXTPageView</a> - 一个支持 UIView 和 UITableView 之间滚动切换的 PageView。</li><li><a href="https://github.com/squimer/DatePickerDialog-iOS-Swift">DatePickerDialog</a> - 在 UIAlertView 上显示 UIDatePicker 的 Swift 库。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/kaishin/gifu">gifu</a> - iOS 上支持动态 GIF 的 Swift 框架。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/szk-atmosphere/SAHistoryNavigationViewController">SAHistoryNavigationViewController</a> - SAHistoryNavigationViewController 实现了一个在 iOS 上的类似任务管理器的 UI，兼容 UINavigationContoller,3D Touch。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/okmr-d/DOFavoriteButton">DOFavoriteButton</a> - 一个可爱的动画按钮。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/LISNR/LNRSimpleNotifications">LNRSimpleNotifications</a> - 简单的 Swift app 内置通知。LNRSimpleNotifications 是一个 Swift <a href="https://github.com/KrauseFx/TSMessages">TSMessages</a> 简化版本。 <img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/meiwin/NgKeyboardTracker">NgKeyboardTracker</a> - iOS 的键盘跟踪 Objective-C 库。</li><li><a href="https://github.com/szk-atmosphere/SAInboxViewController">SAInboxViewController</a> - 受到 “Inbox by google” 动画过渡效果启发的 UIViewController 子类。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/telly/TLYShyNavBar">TLYShyNavBar</a> - 不像那些 UINavigationBar 那么傲慢。这个 Bar 很谦虚！可以很容易地创建自动滚动的 navigation bar。</li><li><a href="https://github.com/bryx-inc/BRYXBanner">BRYXBanner</a> - Swift 的 iOS7+ 样式的下拉通知。 <img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/nealyoung/NYAlertViewController">NYAlertViewController</a> - 可以自定义内容视图的 iOS AlertView，可高度自定义。</li><li><a href="https://github.com/nhdang103/HDNotificationView">HDNotificationView</a> - 使用模仿原生的通知横幅 UI，发出任何警告。</li><li><a href="https://github.com/m1entus/MZFormSheetPresentationController">MZFormSheetPresentationController</a> - MZFormSheetPresentationController 提供了一个原生 iOS UIModalPresentationFormSheet 的替代品，添加了对 iPhone 的支持，并且可以自定义 controller 的尺寸和表单的外观。</li><li><a href="https://github.com/shu223/AnimatedTransitionGallery">AnimatedTransitionGallery</a> - 使用 UIViewControllerAnimatedTransitioning 协议实现了自定义 iOS 7 过渡动画。</li><li><a href="https://github.com/nicklockwood/iCarousel">iCarousel</a> - iOS 和 Mac OS 上简单的，高度可定制化的数据驱动 3D 跑马灯。</li><li><a href="https://github.com/romaonthego/RESideMenu">RESideMenu</a> - 受 Dribble 上的设计启发而制作的 iOS 7/8 样式的视差侧滑菜单。</li><li><a href="https://github.com/PrideChung/FontAwesomeKit">FontAwesomeKit</a> - iOS 的图标字体库，现在支持 Font-Awesome，Foundation icons，Zocial 和 ionicons。</li><li><a href="https://www.cocoacontrols.com/">Cocoa Controls</a> - 开源的 iOS 和 OS X UI 组件.</li><li><a href="https://github.com/optonaut/ActiveLabel.swift">ActiveLabel.swift</a> - 非侵入的 UILabel 替代品，支持 Hashtags (#), Mentions (@) 和 URL (http://)。 <img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/xmartlabs/XLForm">XLForm</a> - XLForm 是最灵活强大的 iOS 库，用来创建动态的 tableview 表单，完全适用于 Swift 和 Obj-C。</li><li><a href="https://github.com/ra1028/RAReorderableLayout">RAReorderableLayout</a> - 可以拖拽放置的 UICollectionView 元素。</li><li><a href="https://github.com/ezescaruli/ESTabBarController">ESTabBarController</a> - 一个允许高亮按钮和自定义按钮动作的 Tabbar 控制器。</li><li><a href="https://github.com/kevin0571/STPopup">STPopup</a> - STPopup 为 iPhone 和 iPad 提供了一个 popup 样式的 UINavigationController。</li><li><a href="https://github.com/suzuki-0000/HoneycombView">HoneycombView</a> - HoneycombView 是用来显示类似 Honyecomb 布局的 iOS UIView，由 Swift 实现。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/devinross/tapkulibrary">tapkulibrary</a> - tap + haiku = tapku, 一个精心设计的开源的iOS框架。</li><li><a href="https://github.com/ninjaprox/NVActivityIndicatorView">NVActivityIndicatorView</a> - 很好的加载动画集合。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/kciter/KCJogDial">KCJogDial</a> - 提供控制功能的 UIView，类似一个转轮控制器。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/kitasuke/PagingMenuController">PagingMenuController</a> - 有可定制的菜单的分页视图控制器，Swift 实现。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/bradjasper/radialmenu">RadialMenu</a> - RadialMenu 是一个提供了触控的上下文菜单（类似 iOS8 中 iMessage 的录制按钮）的自定义控件。使用 Swift 和 POP 框架构建。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/vangelov/VLDContextSheet">VLDContextSheet</a> - 类似 Pinterest iOS app 中的菜单。</li><li><a href="https://github.com/arn00s/cariocamenu">cariocamenu</a> - 最快的无点击菜单。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/ifitdoesntwork/DAExpandAnimation">DAExpandAnimation</a> - 以自定义的模态过渡效果，从 cell 中展开来呈现控制器的库。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/aryaxt/ScrollPager">ScrollPager</a> - 类似 Flipboard 的滚动翻页。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="http://componentkit.org/">ComponentKit</a> - 受到 React 启发的 iOS 框架，Facebook 出品A React-Inspired View Framework for iOS, by Facebook.</li><li><a href="https://github.com/xmartlabs/Eureka">Eureka</a> - 使用纯 Swift 构建优雅的 iOS 表单。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/poetmountain/PMTween">PMTween</a> - 优雅灵活的 iOS 渐变库。</li><li><a href="https://github.com/mineschan/MZTimerLabel">MZTimerLabel</a> - 让 UILabel 变成 倒计时器或者秒表的便利类，类似苹果的时钟应用。</li><li><a href="https://github.com/inFullMobile/WobbleView">WobbleView</a> - WobbleView 是一个实现了流行的摇晃效果的视图。你可以在应用中方便的添加动态的用户交互和过渡效果。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/callumboddy/CBZSplashView">CBZSplashView</a> - Twitter 样式的启动页（Splash Screen）视图，缩放后显示主视图。</li><li><a href="https://github.com/cwRichardKim/RKNotificationHub">RKNotificationHub</a> - 让任何 UIView 变成完善的通知中心。</li><li><a href="https://github.com/Yalantis/EatFit">EatFit</a> - Eat fit 是一个受 Google Fit 启发的用于漂亮地展示数据的组件。</li><li><a href="https://github.com/rob-nash/CollapsableTable">CollapsableTable</a> - 可以自定义 section header 的可折叠 tableview section。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/yoavlt/LiquidFloatingActionButton">LiquidFloatingActionButton</a> - 流体状态的 Material Design 的浮动按钮。</li><li><a href="https://github.com/yoavlt/LiquidLoader">LiquidLoader</a> - 液体动画的加载器组件。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/filipealva/PickerView">PickerView</a> - Swift 实现的自定义的 UIPickerView 替代品。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/AhmettKeskin/InteractivePlayerView">InteractivePlayerView</a> - 自定义的 iOS 音乐播放器视图。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/hughbe/phone-number-picker">phone-number-picker</a> - 一个 Swift 实现的简单易用的视图控制器，类似 WhatsApp 那样让你输入带有国家代码电话号码。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/cute/DLWBouncyView">DLWBouncyView</a> - BouncyView 是一个为所有视图都实现了最近流行的弹性效果的框架。</li><li><a href="https://github.com/adad184/MMPopupView">MMPopupView</a> - 基于 Pop-up 的视图(例如，AlertSheet)，支持方便地定制。</li><li><a href="https://github.com/recruit-mtl/EXTView">EXTView</a> - 使用 IB_DESIGNABLE 和 IBInspectable 为 Interface Builder 提供了 UIView 扩展。</li><li><a href="https://github.com/JunichiT/JTMaterialSwitch">JTMaterialSwitch</a> - 一个受 Google 的 Material Design 启发的可定制的开关 UI，有波纹效果和弹性动画。</li><li><a href="https://github.com/filipealva/PickerView">PickerView</a> - Swift 写的可定制的 UIPickerView 替代品。</li><li><a href="https://github.com/kciter/KCSelectionDialog">KCSelectionDialog</a> - 简单的选择对话框。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/fdzsergio/SFFocusViewLayout">SFFocusViewLayout</a> - 支持内容聚焦的 UICollectionViewLayout。</li><li><a href="https://github.com/andreamazz/UITextField-Shake">UITextField-Shake</a> - 添加了摇晃动画的 UITextField 类别。<a href="https://github.com/King-Wizard/UITextField-Shake-Swift">也有 Swift 版本</a> <img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/JunichiT/JTFadingInfoView">JTFadingInfoView</a> - 一个基于 UIButton 的支持淡入淡出动画特性的视图。</li><li><a href="https://github.com/kciter/KCFloatingActionButton">KCFloatingActionButton</a> - 简洁的 iOS 浮动操作按钮。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/zekunyan/TTGSnackbar">TTGSnackbar</a> - 在屏幕底部显示简单的消息和操作按钮，支持多种动画效果。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/zekunyan/TTGEmojiRate">TTGEmojiRate</a> - iOS 的类似 emoji 的评分视图。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/seedante/CardAnimation">CardAnimation</a> - 卡片翻页动画效果。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/Boris-Em/BEMCheckBox#sample-app">BEMCheckBox</a> - 优雅的 iOS 复选框。(Check box)</li><li><a href="https://github.com/Mozharovsky/CVCalendar">CVCalendar</a> - 支持 iOS 8+ 的自定义可视化日历，Swift（2.0）实现。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/vikmeup/SCLAlertView-Swift">SCLAlertView-Swift</a> - Swift 实现的一个漂亮的动画 Alert View。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://atlas.layer.com/ios">Atlas-iOS</a> - Atlas 是一个原生 iOS 对话 UI Layer 组件。</li><li><a href="https://github.com/TBXark/TKRubberIndicator">TKRubberIndicator</a> - Swift 版橡胶 PageControl 指示器。 <a href="http://tbxark.github.io">http://tbxark.github.io</a> <img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/AliThink/HorizontalProgress">HorizontalProgress</a> - 简单的动画水平进度条。</li><li><a href="https://github.com/TBXark/TKSwitcherCollection">TKSwitcherCollection</a> - 一个动画开关集合。<a href="http://tbxark.github.io">http://tbxark.github.io</a> <img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/JellyDevelopment/JDSwiftAvatarProgress">JDSwiftAvatarProgress</a> - 方便自定义的异步加载展位图进度条动画。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/CardinalNow/iOS-CircleProgressView">iOS-CircleProgressView</a> - 这个空间允许用户用代码或者 interface builder 初始化或创建并渲染一个圆形的进度条视图。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/toannt/Hamburger-Menu-Button">Hamburger-Menu-Button</a> - 一个高度可定制的汉堡包菜单按钮。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/gontovnik/DGElasticPullToRefresh">DGElasticPullToRefresh</a> - iOS 弹性下拉刷新控件，Swift 实现。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/hanton/HTYTextField">HTYTextField</a> - 一个有弹性的站位文字的 UITextField。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/jaydee3/JDStatusBarNotification">JDStatusBarNotification</a> - 显示在顶部状态栏的通知，使用简单，可以自定义。</li><li><a href="https://github.com/Yalantis/GuillotineMenu/tree/swift_2.0">GuillotineMenu</a> - 铡刀样式过渡动画的下拉菜单。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/pixyzehn/MediumMenu">MediumMenu</a> - 一个基于 Medium iOS 应用的菜单。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/Yalantis/YALField?utm_campaign=Indie%2BiOS%2BFocus%2BWeekly&utm_medium=email&utm_source=Indie_iOS_Focus_Weekly_43">YALField</a> - 使用 interface builder 更容易地创建表单 UI。包含带合法性验证的自定义字段。</li><li><a href="https://github.com/peterprokop/StarryStars?utm_campaign=explore-email&utm_medium=email&utm_source=newsletter&utm_term=daily">StarryStars</a> - iOS GUI 库，用于显示和编辑评分。</li><li><a href="https://github.com/tommypeps/JRSplitVC">JRSplitVC</a> - 自适应布局的 UISplitViewController。</li><li><a href="https://github.com/bvogelzang/SevenSwitch">SevenSwitch</a> - 非侵入式的 iOS7 样式的开关替代品。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/soheil/RadialLayer">RadialLayer</a> - 可点击元素的动画。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/DroidsOnRoids/MPParallaxView">MPParallaxView</a> - Swift 实现的 Apple TV 视差效果。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/naoyashiga/RPLoadingAnimation">RPLoadingAnimation</a> - Swift 实现的基于 CALayer 的加载动画。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/yannickl/Splitflap">Splitflap</a> - Swift 应用的分屏显示框架。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/pronebird/UIScrollView-InfiniteScroll">UIScrollView-InfiniteScroll</a> - 支持无限滚动的 UIScrollView 类别。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/entotsu/PullToBounce">PullToBounce</a> -  UIScrollView 的下拉刷新控件。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/marmelroy/TVButton">TVButton</a> - 重新创造一个非常酷的 Apple TV 视差图标用在 iOS UIButton 上（Swift 实现）。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/slackhq/SlackTextViewController">SlackTextViewController</a> - 一个非侵入式的 UIViewcontroller 子类，提供了一个可以随文字长度变化的大小的文本框和一些其他有用的消息特性。</li><li><a href="https://github.com/thellimist/EZAlertController">EZAlertController</a> - 便捷的 Swift UIAlertController。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/goktugyil/EZSwipeController">EZSwipeController</a> - <img src="/images/pointer.png.png" width="20" height="20">类似 Snapchat/Tinder/iOS 主页的 UIPageViewController。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/John-Lluch/SWRevealViewController">SWRevealViewController</a> - 受到 FaceBook 和 Wunderlist 应用启发的 UIViewController 子类，用于显示侧滑的视图控制器。</li></ul><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a><a name="websocket"></a>WebSocket</h3><ul><li><a href="https://github.com/square/SocketRocket">Socket Rocket</a> - 一个一致的 Objective-C WebSocket 客户端库。</li></ul><h3 id="代码质量"><a href="#代码质量" class="headerlink" title="代码质量"></a><a name="code-quality"></a>代码质量</h3><ul><li><a href="https://github.com/krzysztofzablocki/KZBootstrap">KZBootstrap</a> - 一系列的脚本和注释，代码质量很差时，在编译时产生额外的错误和警告。</li><li><a href="https://github.com/krzysztofzablocki/KZAsserts">KZAsserts</a> - 一系列的自定义断言，使用 DSL 来自动生成 NSError，允许在 Debug 时断言和在 Release 时捕获错误。</li><li><a href="https://gist.github.com/steipete/5664345">PSPDFUIKitMainThreadGuard</a> - 简洁的代码片段，当 UIKit 在后台线程被使用时生成断言。</li><li><a href="https://github.com/Flipboard/FLEX">Flex</a> - 一个嵌入 iOS App 的调试和探索工具。</li><li><a href="https://github.com/facebook/chisel">chisel</a> - iOS app 的辅助调试工具，提供了一系列的 LLDB 命令。</li><li><a href="http://oclint.org/">OCLint</a> - 静态代码分析工具，用以提高代码质量，减少瑕疵。</li><li><a href="https://github.com/Cue/ocstyle">ocstyle</a> - Objective-C 代码风格检查器。</li><li><a href="https://github.com/realm/SwiftLint">SwiftLint</a> - 一个实验性的工具，用于强化 Swift 的代码风格和习惯。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/square/spacecommander">spacecommander</a> - 像一个团队那样，提交完全格式化的 Objective-C 代码。</li><li><a href="https://github.com/diwu/DWURecyclingAlert">DWURecyclingAlert</a> - 优化 UITableViewCell 的滚动流畅性。</li><li><a href="https://github.com/domesticcatsoftware/DCIntrospect">DCIntrospect</a> - 小型的 iOS 可视化调试工具库。</li><li><a href="https://github.com/wojteklu/Watchdog">Watchdog</a> - 一个用于记录阻塞主线程的过重任务的类。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="http://tailor.sh/">Tailor</a> - 跨平台的 Swift 代码静态分析器，它帮助你编写更加清洁的代码，避免 bug。</li><li><a href="https://github.com/andresinaka/SwiftCop">SwiftCop</a> -  SwiftCop 是一个很实用的格式验证库，灵感来自 Ruby On Rails 清晰的活动记录验证。<img src="/images/swift_logo.png" width="20" height="20"></li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a><a name="analytics"></a>分析</h3><ul><li><a href="http://www.flurry.com">Flurry Analytics</a> - 免费的 App 分析 API。</li><li><a href="https://parse.com/products/analytics">Parse Analytics</a> - 测量 App 的使用情况，跟踪 bug 等等。</li><li><a href="https://mixpanel.com/">Mixpanel</a> - 高级分析平台。</li><li><a href="http://www.localytics.com/">Localytics</a> - 将 app 的营销和数据分析结合起来。</li><li><a href="https://answers.io/">Answers by Fabric</a> - 让你实时的洞悉用户体验。</li><li><a href="https://onliquid.com">Liquid Analytics</a> - 通过分析和个性化的实时反馈辨认特定的行为。</li><li><a href="https://github.com/gemr/GTrack">GTrack</a> - Google Analytics 对 iOS 的轻量级 Objective-C 封装，并且提供了一些额外的功能。</li><li><a href="https://github.com/orta/ARAnalytics">ARAnalytics</a> - 抽象的分析框架，提供了聪明的 API 来跟踪事件和用户数据。</li><li><a href="https://github.com/segmentio/analytics-ios">Segment</a> - 将分析继承进 iOS 应用中的简单方式。</li></ul><h3 id="支付"><a href="#支付" class="headerlink" title="支付"></a><a name="payments"></a>支付</h3><ul><li><a href="https://stripe.com">Stripe</a> - 将 Apple Pay 支付继承到你的应用中。很适合那些缺少后台知识的开发者。</li><li><a href="https://www.braintreepayments.com">Braintree</a> - 提供 5 万美金的免费支付额度，需要后台支持。</li><li><a href="https://github.com/venmo/venmo-ios-sdk">Venmo</a> - 在你的应用中支持和接受通过 Venmo 的支付。</li><li><a href="https://moltin.com/ios-ecommerce-sdk">Moltin</a> - 使用简单的 SDK 为应用添加 eCommerce，你可以创建一个销售产品的商店，不需要后端支持。</li></ul><h3 id="生产力"><a href="#生产力" class="headerlink" title="生产力"></a><a name="products"></a>生产力</h3><ul><li><a href="https://import.io">Import.io</a> - 将网页即时转换为数据。</li><li><a href="https://www.tapglue.com">Tapglue</a> - 是用很少的代码来构建社交产品和活动的 feed。<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a><a name="utility"></a>工具</h3><ul><li><a href="https://github.com/robb/Underscore.m">Underscore.m</a> - 用来操作数据的 DSL。</li><li><a href="https://github.com/paulsamuels/SBConstants">SBConstants</a> - 生成一个包含了 storyboard 中所有 identifier 的常量文件。</li><li><a href="https://github.com/tumblr/XExtensionItem">XExtensionItem</a> - 方便地在 iOS 应用和分享扩展至简分享数据。</li><li><a href="https://github.com/fastred/ReflectableEnum">ReflectableEnum</a> - Objective-C 枚举的反射。</li><li><a href="https://github.com/zakkhoyt/VWWPermissionKit">VWWPermissionKit</a> - 可视化的 iOS 权限管理器。</li><li><a href="https://github.com/clusterinc/ClusterPrePermissions">ClusterPrePermissions</a> - 可重用的预授权工具，它可以让开发者在对话中获取系统权限之前询问用户。</li><li><a href="https://github.com/MatthewYork/DateTools">DateTools</a> - 简便的 Objective-C 日期和时间工具。</li><li><a href="https://github.com/EvgenyKarkan/EKAlgorithms">EKAlgorithms</a> - 一些知名的计算机科学算法和数据结构的 Objective-C 实现。</li><li><a href="https://github.com/delba/Tactile">Tactile</a> - 安全并且更加合乎习惯的响应收拾和控件事件的方式。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/bennyguitar/Colours">Colours</a> - 这是一套与定义的颜色和颜色方法，让你的 iOS／OS X 开发更加方便。</li><li><a href="https://github.com/supermarin/ObjectiveSugar">ObjectiveSugar</a> - Ruby 风格的 ObjectiveC 附件。</li><li><a href="https://github.com/mattt/GroundControl">GroundControl</a> - iOS 远程配置。</li><li><a href="https://github.com/leoschweizer/OpinionatedC">OpinionatedC</a> - 让 Objective-C 继承更多 Smalltalk 特性。</li><li><a href="https://github.com/JohnEstropia/GCDKit">GCDKit</a> - GCD 的 Swift 简化版。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/thellimist/SwiftRandom">SwiftRandom</a> - 随即数据生成器。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/nvzqz/RandomKit/">RandomKit</a> - Swift 随机数据生成器。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/duemunk/Async">Async</a> - Swift 的 GCD 异步派发语法糖。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/mxcl/YOLOKit">YOLOKit</a> - 让方块透过圆洞。</li><li><a href="https://github.com/goktugyil/EZSwiftExtensions">EZSwiftExtensions</a> - :smirk:标准类型和类是如何工作的。<img src="/images/swift_logo.png" width="20" height="20"></li></ul></li></ul><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a><a name="security"></a>安全</h3><ul><li><a href="https://github.com/kishikawakatsumi/UICKeyChainStore">UICKeyChainStore</a> - UICKeyChainStore 是一个对 Keychain 的简洁封装。</li><li><a href="https://github.com/orta/cocoapods-keys">cocoapods-keys</a> - 一个用来存储环境和应用键值的键值存储。</li><li><a href="https://github.com/square/Valet">Valet</a> - 在 iOS 和 OS X 的 Keychain 中安全地存储数据，然而你无需知道 keychain 的具体工作细节。</li><li><a href="https://github.com/jspahrsummers/libextobjc">libextobjc</a> - 一个用于扩展 Objective-C 编程语言的 Cocoa。</li><li><a href="https://github.com/matthewpalmer/Locksmith">Locksmith</a> - 方便 Keychain 使用的强大的 Swift 面向协议库。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/simple-machines/simple-touch">simple-touch</a> - 非常简单的生物识别认证服务（Touch ID）的 Swift 封装。</li></ul><h1 id="项目安装"><a href="#项目安装" class="headerlink" title="项目安装"></a><a name="project-setup"></a>项目安装</h1><ul><li><a href="https://github.com/krzysztofzablocki/crafter">crafter</a> -  这是一个允许你使用自定义的领域专用语言（DSL）语法来配置你的 iOS 项目模版的命令行工具（CLI），使用简单但性能强大。</li><li><a href="https://github.com/thoughtbot/liftoff">liftoff</a> - 另一个用于创建 iOS 项目的 CLI。</li><li><a href="https://github.com/krzysztofzablocki/KZBootstrap">KZBootstrap</a> - iOS 项目的 bootstrap，目的是高质量的编码。</li><li><a href="https://github.com/crushlovely/Amaro">amaro</a> - 优秀的 iOS 样板。</li><li><a href="https://github.com/orta/chairs">chairs</a> - 交换你的 iOS 模拟器文档。</li></ul><h1 id="依赖-包管理"><a href="#依赖-包管理" class="headerlink" title="依赖 / 包管理"></a><a name="dependency--package-manager"></a>依赖 / 包管理</h1><ul><li><a href="https://cocoapods.org/">Cocoa Pods</a> - CocoaPods 是一个 Objective-C 项目的依赖管理工具。它拥有成千上万个库，它们可以使你的项目更加优雅。</li><li><a href="http://sap-production.github.io/xcode-maven-plugin/site/">Xcode Maven</a> - Xcode Maven 插件，它可以将 Xcode 构建过程嵌入 Maven 的生命周期中。</li><li><a href="http://openbakery.org/gradle.html">Gradle</a> - Xcode 的 gradle 插件，可以使用 gradle 来构建 iOS 或者 Mac OS X 项目。</li><li><a href="https://github.com/Carthage/Carthage">Carthage</a> - 简单的分布式的 Cocoa 依赖管理器。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/jankuca/swm">SWM (Swift Modules)</a> - 一个类似 npm（node.js的包管理器）或者 bower（Twitter 的浏览器的包管理器） 的 Swift 项目的包／依赖管理器，无需使用 Xcode。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="http://alcatraz.io/">Alcatraz</a> - Xcode 包管理工具.</li><li><a href="https://github.com/devxoul/CocoaSeeds">CocoaSeeds</a> - Cocoa 的 Git 子模块替代品。</li></ul><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a><a name="testing"></a>测试</h1><h3 id="测试驱动开发／行为驱动开发（TDD-BDD）"><a href="#测试驱动开发／行为驱动开发（TDD-BDD）" class="headerlink" title="测试驱动开发／行为驱动开发（TDD / BDD）"></a><a name="tdd--bdd"></a>测试驱动开发／行为驱动开发（TDD / BDD）</h3><ul><li><a href="https://github.com/kiwi-bdd/Kiwi">Kiwi</a> - 一个用于 iOS 开发的 BDD 库。</li><li><a href="https://github.com/specta/specta">Specta</a> - 轻量级 TDD / BDD Objective-C &amp; Cocoa 开发框架。</li><li><a href="https://github.com/Quick/Quick">Quick</a> - Swift 和 Objective-C 的 BDD 框架。</li><li><a href="https://github.com/jonreid/XcodeCoverage">XcodeCoverage</a> - Xcode 项目代码覆盖率。</li><li><a href="https://github.com/AliSoftware/OHHTTPStubs">OHHTTPStubs</a> - 方便地为你的网络请求做存根（Stub）! 使用网络假数据测试你的 app ，你也可以自定义响应时间，响应代码和响应头！</li><li><a href="https://github.com/Skyscanner/Dixie">Dixie</a> - Dixie 是一个开源的 Objective-C 测试框架。用于改变对象的行为。</li><li><a href="https://github.com/gh-unit/gh-unit">gh-unit</a> - Objective-C 的测试框架。</li></ul><h3 id="UI-测试"><a href="#UI-测试" class="headerlink" title="UI 测试"></a><a name="ui-testing"></a>UI 测试</h3><ul><li><a href="https://github.com/mokemokechicken/CrashMonkey">CrashMonkey</a> - iOS 平台的 Monkey 测试工具。 </li><li><a href="http://appium.io/">appium</a> - Appium 是一个开源自动化测试框架。用于测试原生或者混合 app。</li><li><a href="https://github.com/jollychang/robotframework-appiumlibrary">robotframework-appiumlibrary</a> - AppiumLibrary 是一个用于 RobotFramwork 的 appium 测试框架。</li><li><a href="https://cucumber.io/">Cucumber</a> - iOS BDD 框架。</li><li><a href="https://github.com/kif-framework/KIF">Kif</a> - 一个 iOS 的函数式测试框架。</li><li><a href="https://github.com/inkling/Subliminal">Subliminal</a> - 一个保守的 iOS 集成测试框架。</li><li><a href="https://developer.apple.com/library/ios/documentation/DeveloperTools/Reference/UIAutomationRef/">UIAutomation</a> - 一个使用脚本在连接着的设备上测试你的用户界面元素的 JavaScript 库。</li><li><a href="http://ios-driver.github.io/ios-driver/index.html">ios-driver</a> - 使用 Selenium / WebDriver 测试任何 iOS 原生，混合或者移动 web 应用。</li><li><a href="https://github.com/zucchini-src/zucchini">Zucchini</a> - 可视化的 iOS 测试框架。</li><li><a href="https://github.com/johnno1962/Remote">Remote</a> - 在 Xcode 内部控制你的 iPhone 来做端到端的测试。</li></ul><h3 id="其他测试"><a href="#其他测试" class="headerlink" title="其他测试"></a><a name="other-testing"></a>其他测试</h3><ul><li><a href="https://github.com/Palleas/NaughtyKeyboard">NaughtyKeyboard</a> - 一个危险字符串的大列表，当用户输入这些字符串使有很大的可能会造成 bug，这是一个用于在你的 iOS 设备上测试你 app 的键盘。</li><li><a href="https://github.com/square/PonyDebugger">PonyDebugger</a> - 使用 Chrome 开发者工具对你的 iOS app 进行远程网络和数据调试。</li><li><a href="https://github.com/facebook/ios-snapshot-test-case">ios-snapshot-test-case</a> - 使用屏幕快照的 iOS 单元测试。</li></ul><h3 id="Beta-测试版本发布"><a href="#Beta-测试版本发布" class="headerlink" title="Beta 测试版本发布"></a><a name="beta-distribution"></a>Beta 测试版本发布</h3><ul><li><a href="https://try.crashlytics.com/">Crashlytics</a> - 一个崩溃报告和 beta 测试服务。</li><li><a href="https://developer.apple.com/testflight/">TestFlight Beta Testing</a> - iTunes Connect 支持的 beta 测试服务。</li><li><a href="http://hockeyapp.net/">HockeyApp</a> - 在 HockeyApp 你可以发布你 app 的 beta 测试版本，收集实时的崩溃报告，获取用户反馈，分析测试覆盖率。</li><li><a href="https://github.com/fastlane/boarding">boarding</a> - 即时为 TestFlight beta 测试者创建简单的注册页面。</li><li><a href="https://github.com/bitstadium/HockeyKit">HockeyKit</a> - 一个软件升级套件。</li></ul><h1 id="工具链"><a href="#工具链" class="headerlink" title="工具链"></a><a name="toolchains"></a>工具链</h1><ul><li><a href="http://www.rubymotion.com/">RubyMotion</a> - RubyMotion 是一个革命性的工具链。它可以让你快速地开发和测试原生 iOS 和 OS X 应用，全部使用 Ruby 语言。</li></ul><h1 id="工具-1"><a href="#工具-1" class="headerlink" title="工具"></a><a name="tools"></a>工具</h1><ul><li><a href="https://github.com/kaandedeoglu/Shark">Shark</a> - 用于将 .xcassets 文件夹转换成一个类型安全枚举的 Swift 脚本。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/mac-cain13/R.swift">R.swift</a> - 在 Swift 项目中，强类型的自动补全资源名称的工具，包括图片，单元格和 segue 的工具。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/AliSoftware/SwiftGen">SwiftGen</a> - 一个生成 Swift 代码工具的集合（生成资源的枚举，storyboard，本地化字符串和 UIColor）。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/marmelroy/Localize-Swift">Localize-Swift</a> - Swift 2.0 实现在应用中切换语言的功能，帮助你的 APP 实现友好的本地化和国际化。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/jondot/blade">Blade</a> - 为 iOS 和 OS X 应用生成 Xcode 图片目录，全局图片和其他相关的东西。</li><li><a href="https://github.com/terwanerik/Retini">Retini</a> - 一个超级简单的 Retina（2x，3x）图片转换器。</li><li><a href="https://github.com/chockenberry/Provisioning">Provisioning</a> - 一个查看器插件，用于预览 .mobileprovision 文件。</li><li><a href="https://github.com/metasmile/strsync">Strsync</a> - 自动翻译并且使 .strings 文件和默认语言同步。</li></ul><h1 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a><a name="rapid-development"></a>敏捷开发</h1><ul><li><a href="https://github.com/krzysztofzablocki/KZPlayground">KZPlayground</a> - Objective-C 版本的 Playground。</li><li><a href="https://github.com/DyCI/dyci-main">dyci</a> -  代码注入工具。</li><li><a href="https://github.com/johnno1962/injectionforxcode">injectionforxcode</a> - 代码注入，支持 Swift。</li><li><a href="https://github.com/mutualmobile/MMBarricade">MMBarricade</a> - 在运行时为 iOS app 配置本地服务器。</li><li><a href="https://github.com/colemancda/NetworkObjects">NetworkObjects</a> - 根据你的 Core Data 模型生成 RESTful 服务器。</li><li><a href="http://www.sensiblecocoa.com">STV Framework</a> - 开发原生 iOS app 的可视化开发工具。</li></ul><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a><a name="deployment"></a>部署</h1><ul><li><a href="https://github.com/fastlane/fastlane">fastlane</a> 将所有 iOS 部署工具整合到一个工作流中。</li><li><a href="https://github.com/fastlane/deliver">deliver</a> 部署截屏，app 元数据和 AppStore app 更新，这一切只需要一个命令就可以搞定。</li><li><a href="https://github.com/fastlane/snapshot">snapshot</a> 自动地创建全部语言和全部设备的屏幕截图。</li></ul><h1 id="App-Store"><a href="#App-Store" class="headerlink" title="App Store"></a><a name="app-store"></a>App Store</h1><ul><li><a href="http://appreviewtimes.com">Average App Store Review Times</a> 这个网站可以同时跟踪 AppStore 上 iOS 和 Mac 两个版本的浏览次数，使用了利用 iOS 和 Mac 开发者的众包数据。</li><li><a href="https://developer.apple.com/app-store/review/rejections/">Apple’s Common App Rejections Styleguide</a>  一些导致 app 被苹果拒绝的重要常见问题。</li><li><a href="https://www.mobileaction.co">Free App Store Optimization Tool</a> 在关键字和竞争者的角度上，让你可视化地追踪你的 App Store 数据。</li></ul><h1 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a><a name="sdk"></a>SDK</h1><h2 id="官方的"><a href="#官方的" class="headerlink" title="官方的"></a><a name></a>官方的</h2><ul><li><a href="https://github.com/spotify/ios-sdk">Spotify</a> Spotify iOS SDK。</li><li><a href="https://github.com/facebook/facebook-ios-sdk">Facebook</a> Facebook iOS SDK。</li><li><a href="https://developers.google.com/analytics/devguides/collection/ios/v3/">Google Analytics</a> Google Analytics iOS SDK。</li><li><a href="https://github.com/paypal/PayPal-iOS-SDK">Paypal iOS SDK</a> The PayPal 移动端 SDK，可以简便地在本地应用中集成 PayPal 和 信用卡支付。</li><li><a href="https://github.com/Pocket/Pocket-ObjC-SDK">Pocket</a> 将东西保存到 Pocket 的 SDK。</li><li><a href="https://github.com/tumblr/TMTumblrSDK">Tumblr</a> 集成 Tumblr 数据到 iOS 或 OS X 应用中的库。</li><li><a href="https://github.com/evernote/evernote-cloud-sdk-ios">Evernote</a> Evernote iOS SDK。</li><li><a href="https://github.com/box/box-ios-sdk">Box</a> Box iOS 和 OS X SDK API。</li><li><a href="https://github.com/OneDrive/onedrive-sdk-ios">OneDrive</a> Live iOS SDK。</li><li><a href="https://github.com/stripe/stripe-ios">Stripe</a> iOS and OS X Stripe 绑定框架。</li><li><a href="https://github.com/venmo/venmo-ios-sdk">Venmo</a> 在你的 iOS app 通过 Venmo 生成订单并且接受支付。</li><li><a href="https://github.com/aws/aws-sdk-ios">AWS</a> Amazon Web Services iOS 移动应用 SDK。</li><li><a href="https://github.com/zendesk/zendesk_sdk_ios">Zendesk</a> Zendesk iOS 移动应用 SDK。</li><li><a href="https://creativesdk.adobe.com/">Adobe Creative SDK</a> Adobe creative tools 和 Creative Cloud SDK。</li><li><a href="https://www.dropbox.com/developers">Dropbox</a>  Drop-ins 和 Dropbox Core API 的 SDK。</li><li><a href="https://docs.fabric.io/ios/index.html">Fabric by Twitter</a> iOS 的 Fabric Twitter Kit。</li><li><a href="https://github.com/lqd-io/liquid-sdk-ios">Liquid Analytics</a> 通过分析与实时的个性化的实时响应产生特定的行为。</li><li><a href="https://github.com/ResearchKit/ResearchKit">ResearchKit</a> ResearchKit 是一个开源的软件框架，用它可方便的构建医疗研究应用或者其他的研究项目。</li><li><a href="https://packetzoom.com">PacketZoom</a> PacketZoom iOS SDK。</li><li><a href="https://www.goprimer.com">Primer</a> - 在可视化编辑器上方便创建定制化的登陆页，注册和登录流程的 SDK，内建了 a/b/n 测试和分析。</li></ul><h2 id="非官方"><a href="#非官方" class="headerlink" title="非官方"></a><a name></a>非官方</h2><ul><li><a href="https://github.com/nst/STTwitter">STTwitter</a> 为 Twitter REST API 1.1 制作的稳定，成熟，全面的 Objective-C 库。 </li><li><a href="https://github.com/fhsjaagshs/FHSTwitterEngine">FHSTwitterEngine</a> 为 Cocoa 开发者提供的 Twitter API。</li><li><a href="https://github.com/heyalexchoi/Giphy-iOS">Giphy</a> Giphy API 的 Objective-C iOS 客户端。</li><li><a href="https://github.com/sachinkesiraju/UberKit">UberKit</a> - Objective-C 包装的简单易用的    Uber API。</li><li><a href="https://github.com/shyambhat/InstagramKit">InstagramKit</a> - Instagram iOS SDK。</li><li><a href="https://github.com/agilie/dribbble-ios-sdk">DribbbleSDK</a> - Dribbble iOS SDK。</li><li><a href="https://github.com/lukhnos/objectiveflickr">objectiveflickr</a> - 对象化的 Flickr， Objective-C 写的 Flickr API。</li><li><a href="https://github.com/victorgama/DropletKit">DropletKit</a> - Objective-C 包装的 DigitalOcean v2 API。</li></ul><h1 id="Xcode"><a href="#Xcode" class="headerlink" title="Xcode"></a><a name="xcode"></a>Xcode</h1><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a><a name="plugins"></a>插件</h3><ul><li><a href="https://github.com/FuzzyAutocomplete/FuzzyAutocompletePlugin">FuzzyAutocompletePlugin</a> - 提供了除前缀匹配之外的其他更加灵活的自动补全功能，支持 Xcode 5+。</li><li><a href="https://github.com/stefanceriu/SCXcodeMiniMap">SCXcodeMiniMap</a> - SCXcodeMiniMap 为 Xcode 添加了代码地图功能</li><li><a href="https://github.com/larsxschneider/ShowInGitHub">Show in Github</a> -  可以直接打开 Github 上当前正在编辑的行对应的 commit 页面。</li><li><a href="https://github.com/neonichu/BBUFullIssueNavigator">BBUFullIssueNavigator</a> - 这个插件让 Xcode 在 issue 导航栏显示所有的 issue 内容。</li><li><a href="https://github.com/neonichu/BBUDebuggerTuckAway">BBUDebuggerTuckAway</a> - 当你开始编辑的时候帮你隐藏调试器栏的 Xcode 插件。</li><li><a href="https://github.com/stefanceriu/SCXcodeSwitchExpander">SCXcodeSwitchExpander</a> - SCXcodeSwitchExpander 是一个可以帮你展开 switch 语句的插件，还会自动帮你插入 case 语句。</li><li><a href="https://github.com/onevcat/VVDocumenter-Xcode">VVDocumenter-Xcode</a> - 方便的编写标准注释的 Xcode 插件。</li><li><a href="https://github.com/qfish/XAlign">XAlign</a> - 一个 Xcode 代码自动对齐插件，它可以使用自定义的模式来对齐任何东西。</li><li><a href="https://github.com/kattrali/cocoapods-xcode-plugin">Cocoapods Xcode Plugin</a> - 依赖管理工具 CocoaPods 的 Xcode 插件。</li><li><a href="https://github.com/ksuther/KSImageNamed-Xcode">KSImageNamed-Xcode</a> - 提供了图片名称自动补全功能的插件。</li><li><a href="https://github.com/omz/ColorSense-for-Xcode">ColorSense-for-Xcode</a> - 可视化的颜色选择插件。</li><li><a href="https://github.com/limejelly/Backlight-for-XCode">Backlight-for-XCode</a> - 高亮当前编辑的行。</li><li><a href="https://github.com/yeahdongcn/UIColor-Hex-Swift">UIColor-Hex-Swift</a> - 通过十六进制字符串创建 autorelease 颜色的便利方法。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/kitschpatrol/KPRunEverywhereXcodePlugin">KPRunEverywhereXcodePlugin</a> - 只需一次点击，就可以在多个 iOS 设备上构建，运行 App。</li><li><a href="https://github.com/shjborage/Reveal-Plugin-for-Xcode">RevealPlugin</a> - 将 Reveal App 和你的项目自动合为一体的 Xcode 插件。</li><li><a href="https://realm.io/docs/objc/0.81.0/#xcode-plugin">RealmPlugin</a>- 生成 Realm 模型的 Xcode 插件。</li><li><a href="https://github.com/zats/AdjustFontSize-Xcode-Plugin">AdjustFontSize</a> - 使用 <code>⌘ +</code> / <code>⌘ -</code> 快捷键调整字体大小。</li><li><a href="https://github.com/questbeat/Lin">Lin</a> - 这个插件提供了 NSLocalizedString 的自动补全插件。</li><li><a href="https://www.rephrase.io">Rephrase</a> - Xcode 用于本地化的插件.</li><li><a href="https://github.com/pdcgomes/XCActionBar">XCActionBar</a> - Xcode 的 Alfred。</li><li><a href="https://github.com/wiruzx/QuickJump">QuickJump</a> - Xcode 快速代码导航。</li><li><a href="https://github.com/keefo/CATweaker">CATweaker</a> - 一个用于创建漂亮的 CAMediaTimingFunction 曲线的插件.</li><li><a href="https://github.com/onmyway133/XcodeWay">XcodeWay</a> - 便捷地导航到多个地方。</li><li><a href="https://github.com/johnno1962/GitDiff">GitDiff</a> - 将与 git 仓库中不同的代码高亮。</li><li><a href="https://github.com/yuhua-chen/MCLog">MCLog</a> - 用于控制台内容筛选的插件。</li><li><a href="https://github.com/trawor/XToDo">XToDo</a> - 一个显示项目中 TODO，FIXME，??? 和 !!! 列表的对话框。</li><li><a href="https://github.com/hanton/CopyIssue-Xcode-Plugin">CopyIssue</a> - 使复制 Xcode issuse 描述更简单。</li><li><a href="https://github.com/rickytan/RTImageAssets">RTImageAssets</a> - 自动生成所需的全部 App 图标的插件。</li><li><a href="https://github.com/benoitsan/BBUncrustifyPlugin-Xcode">BBUncrustifyPlugin-Xcode</a> - 使用 ClangFormat 或 Uncrustify 格式化代码的插件。</li><li><a href="https://github.com/marksands/Aviator">Aviator</a> - 这个插件将 AppCode 的 ⇧⌘T (source/test 切换) 带到 Xcode 中.</li><li><a href="https://github.com/merrickp/JumpMarks">JumpMarks</a> - 使用有序的书签为你的代码做导航。</li><li><a href="https://github.com/dzenbot/XCSnippetr">XCSnippetr</a> - 直接上传代码片段到 Slack 和 Gist 的 Xcode 插件。</li><li><a href="https://github.com/markohlebar/Peckham">Peckham</a> -  使用 #import 引用项目中的任何文件，提供代码提示。</li><li><a href="https://github.com/molon/MLAutoReplace">MLAutoReplace</a> -  快速编码以及代码格式化插件，提升你的编码速度。</li><li><a href="https://github.com/ViccAlexander/Chameleon">Chameleon</a> -  iOS （Obj-C &amp; Swift）的扁平化颜色框架。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/chiahsien/AutoHighlightSymbol">AutoHighlightSymbol</a> - 高亮被选中的符号对应的所有实例。</li><li><a href="https://github.com/lzwjava/Reveal-In-Github">Reveal-In-GitHub</a> - 用一个快捷键就可以跳转到 GitHub 仓库的 History, Blame, PRs, Issues, Notifications。</li><li><a href="https://github.com/insanoid/CleanHeaders-Xcode">CleanHeaders-Xcode</a> - 类似 iSort 的头文件排序和重复消除插件，让你的头文件看起来更加有序。</li><li><a href="https://github.com/k0nserv/luft">Luft</a> - 帮助你实现轻量的 View Controller 的 Xcode 插件。</li></ul><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a><a name="themes"></a>主题</h3><ul><li><a href="https://github.com/zenorocha/dracula-theme">Dracula Theme</a> - 一个 Xcode 的暗色主题（仿 SublimeText）.</li><li><a href="https://github.com/hdoria/xcode-themes">Xcode themes list</a> - Xcode 的多彩主题。</li><li><a href="https://github.com/ArtSabintsev/Solarized-Dark-for-Xcode/">Solarized-Dark-for-Xcode</a> - 用于 Xcode5 的 Solarized Dark 主题.</li></ul><h3 id="其他-Xcode-插件"><a href="#其他-Xcode-插件" class="headerlink" title="其他 Xcode 插件"></a><a name="other-xcode"></a>其他 Xcode 插件</h3><ul><li><a href="https://github.com/venmo/synx">Synx</a> - 一个重新组织你的 Xcode 项目的命令行工具，它能够让你的 group 和文件夹对应起来。</li><li><a href="https://github.com/Tintenklecks/IBDelegateCodesippets">dsnip</a> - 可以在本地为所有的 UIKit 协议／代理方法（UITableView,…）生成 Xcode 代码片段的工具。</li></ul><h1 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a><a name="style-guides"></a>编码规范</h1><ul><li><a href="https://github.com/NYTimes/objective-c-style-guide">NY Times - Objective C Style Guide</a> - 纽约时报使用的 Objective-C 编码规范。</li><li><a href="https://github.com/raywenderlich/objective-c-style-guide">raywenderlich Style Guide</a> - 一个描述 raywenderlich.com 编码习惯的代码规范。</li><li><a href="https://github.com/github/objective-c-style-guide">Github Objective-C Style Guide</a> - Objective-C 项目的编码规范和惯用法。</li><li><a href="https://gist.github.com/soffes/812796">Objective-C Coding Convention and Best Practices</a> - 一份描述编码习惯的 Gist。</li><li><a href="https://github.com/raywenderlich/swift-style-guide">Swift Style Guide by @raywenderlich</a> - raywenderlich.com 官方的 Swift 编码风格规范。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/spotify/ios-style">Spotify Objective-C Coding Style</a> - Spotify 的 iOS 开发指导。</li><li><a href="https://dl.dropboxusercontent.com/s/5utnlwhr18ax05c/style-guide.html?dl=0">Dropbox Objective-C Style Guide</a> - Dropbox 的 Objective-C 代码风格指南。</li><li><a href="https://github.com/github/swift-style-guide">Github - Style guide &amp; coding conventions for Swift projects</a> - github 的 Swift 编码风格和习惯指南。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/futurice/ios-good-practices">Futurice iOS Good Practices</a> - <a href="https://github.com/futurice">@futurice</a> 介绍的 iOS 入门指南和最佳实践。</li></ul><h1 id="好网站"><a href="#好网站" class="headerlink" title="好网站"></a><a name="good-websites"></a>好网站</h1><h3 id="新闻，播客和其他"><a href="#新闻，播客和其他" class="headerlink" title="新闻，播客和其他"></a><a name="news-blogs-and-more"></a>新闻，播客和其他</h3><ul><li><a href="http://bgr.com/ios-7/">BGR</a></li><li><a href="http://www.imore.com/">iMore</a></li><li><a href="http://lifehacker.com/tag/ios">Lifehacker</a></li><li><a href="http://www.icodeblog.com/">iCode Blog</a></li><li><a href="http://nshipster.com">NSHipster</a></li><li><a href="https://www.objc.io/">Objc.io</a></li><li><a href="http://asciiwwdc.com">ASCIIwwdc</a></li><li><a href="http://natashatherobot.com">Natasha The Robot</a></li><li><a href="https://developer.apple.com/swift/blog/">Apple’s Swift Blog</a> <img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://www.reddit.com/r/iosprogramming">iOS Programming Subreddit</a></li><li><a href="https://iosdevweekly.com/">iOS Dev Weekly</a></li><li><a href="https://github.com/shinobicontrols/iOS8-day-by-day">iOS8-day-by-day</a> <img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="http://www.ioscreator.com/">iOScreator</a> <img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="http://mathewsanders.com/">Mathew Sanders</a> <img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://littlebitesofcocoa.com/">Little Bites of Cocoa</a> <img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="http://hboon.com/iosdevnuggets/">iOS Dev Nuggets</a> <img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="http://swiftnews.curated.co">This Week in Swift</a> <img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="http://ios-goodies.com">iOS Goodies</a></li><li><a href="https://github.com/CameronBanga/iOS-Developer-and-Designer-Interview-Questions">iOS Developer and Designer interview</a> - 一个用于帮助那些寻找 iOS 开发者或设计师的雇主的小指南。</li><li><a href="https://medium.com/ios-os-x-development">iOS App Development on Medium</a> - 一些关于 iOS，AppleWatch 开发的小故事和小贴士。</li><li><a href="http://swiftsandbox.io">Swift Sandbox</a> - Swift 开发者通讯，Swift 开源新闻，项目和资源。 <img src="/images/swift_logo.png" width="20" height="20"></li></ul><h3 id="UIKit-文档"><a href="#UIKit-文档" class="headerlink" title="UIKit 文档"></a><a name="uikit-references"></a>UIKit 文档</h3><ul><li><a href="http://iosfonts.com/">iOS Fonts</a></li><li><a href="https://gist.github.com/mattt/5135521">UIAppearance list</a></li></ul><h3 id="论坛和讨论列表"><a href="#论坛和讨论列表" class="headerlink" title="论坛和讨论列表"></a><a name="forums-and-discuss-lists"></a>论坛和讨论列表</h3><ul><li><a href="http://iphonedevsdk.com/">iPhone Dev SDK Forum</a></li><li><a href="http://stackoverflow.com/questions/tagged/ios">“iOS” on Stackoverflow</a></li></ul><h3 id="教程和-Keynotes"><a href="#教程和-Keynotes" class="headerlink" title="教程和 Keynotes"></a><a name="tutorials-and-keynotes"></a>教程和 Keynotes</h3><ul><li><a href="http://www.appcoda.com">AppCoda</a></li><li><a href="http://www.tutorialspoint.com/ios/">Tutorials Point</a></li><li><a href="http://codewithchris.com/">Code with Cris</a></li><li><a href="http://www.cocoawithlove.com/">Cocoa with Love</a></li><li><a href="http://www.cimgf.com/">Cocoa is my Girlfriend</a></li><li><a href="http://tryobjectivec.codeschool.com/">Code School - Try Objective-C</a></li><li><a href="https://www.youtube.com/channel/UCysEngjfeIYapEER9K8aikw/videos">Brian Advent youtube channel</a> - Youtube 上的 Swift 教程频道。 <img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="http://www.raywenderlich.com/tutorials">RAYWENDERLICH</a> - 开发者和爱好者的教程。</li><li><a href="http://rypress.com/tutorials/objective-c/index">Ry’s Objective-C Tutorial</a></li><li><a href="https://www.mikeash.com/pyblog/">Mike Ash</a></li><li><a href="https://www.bignerdranch.com/blog/categories/ios/">Big Nerd Ranch</a> <img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="http://code.tutsplus.com/categories/ios-sdk">Tuts+</a> <img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="http://ios-blog.co.uk/">iOS-Blog</a> <img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://thinkster.io/a-better-way-to-learn-swift">Thinkster</a> <img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://github.com/swifteducation">Swift Education</a> - 一个供教育者分享 Swift 和 app 开发学习材料的社区。<img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="http://cocoadevcentral.com">Cocoa Dev Central</a></li><li><a href="http://useyourloaf.com">Use Your Loaf</a></li><li><a href="http://jamesonquave.com/blog/tutorials/">Swift Tutorials by Jameson Quave</a> <img src="/images/swift_logo.png" width="20" height="20"></li></ul><h3 id="iOS-UI-模版"><a href="#iOS-UI-模版" class="headerlink" title="iOS UI 模版"></a><a name></a>iOS UI 模版</h3><ul><li><a href="http://appicontemplate.com/ios8/">App Icon Template</a></li><li><a href="http://www.teehanlax.com/tools/iphone/">iOS 8 GUI PSD Template</a></li><li><a href="http://www.invisionapp.com/tethr">iOS UI Design Kit</a></li><li><a href="http://iosdesign.ivomynttinen.com/">iOS Design Guidelines</a></li></ul><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a><a name="prototyping"></a>原型</h3><ul><li><a href="https://www.fluidui.com">FluidUI</a></li><li><a href="https://proto.io/">Proto.io</a></li><li><a href="http://framerjs.com/">Framer</a></li><li><a href="http://www.pixate.com/">Pixate</a></li><li><a href="http://principleformac.com">Principle</a></li></ul><h1 id="Twitter"><a href="#Twitter" class="headerlink" title="Twitter"></a><a name="twitter"></a>Twitter</h1><ul><li><a href="https://twitter.com/objcio">@objcio</a></li><li><a href="https://twitter.com/NSHipster">@nshipster</a></li><li><a href="https://twitter.com/CocoaPods">@CocoaPods</a></li><li><a href="https://twitter.com/CocoaPodsFeed">@CocoaPodsFeed</a></li><li><a href="https://twitter.com/RubyMotion">@RubyMotion</a></li><li><a href="https://twitter.com/SwiftSandbox">@SwiftSandbox</a> - Swift 开源新闻, 项目和资源。</li></ul><h1 id="Facebook-群组"><a href="#Facebook-群组" class="headerlink" title="Facebook 群组"></a><a name="facebook-groups"></a>Facebook 群组</h1><ul><li><a href="https://www.facebook.com/groups/hhios/">HH iOS</a></li><li><a href="https://www.facebook.com/groups/sketchformac/">Sketch - Official group</a></li><li><a href="https://www.facebook.com/groups/designcode/">Design-Code</a></li><li><a href="https://www.facebook.com/groups/sketchdesignio">Sketch-Design.io</a></li><li><a href="https://www.facebook.com/groups/origami.community/">Origami Community</a></li><li><a href="https://www.facebook.com/groups/framerjs/">Framer JS</a></li></ul><h1 id="播客"><a href="#播客" class="headerlink" title="播客"></a><a name="podcasts"></a>播客</h1><ul><li><a href="http://www.raywenderlich.com/rwpodcast">The Ray Wenderlich Podcast</a></li><li><a href="http://www.imore.com/debug">Debug</a></li><li><a href="http://ideveloper.co/">iDeveloper</a></li><li><a href="http://www.appstorypodcast.com">App Story</a></li><li><a href="http://mobilecouch.co/">Mobile Couch</a></li><li><a href="https://iosbytes.codeschool.com/">iOS Bytes</a></li></ul><h1 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a><a name="books"></a>书籍</h1><ul><li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/ProgrammingWithObjectiveC.pdf">Programming with Objective-C by Apple</a></li><li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/OOP_ObjC/OOP_ObjC.pdf">Object-Oriented Programming with Objective-C by Apple</a></li><li><a href="https://itunes.apple.com/us/book/swift-programming-language/id881256329?mt=11">The Swift Programming Language by Apple</a> <img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://itunes.apple.com/us/book/using-swift-cocoa-objective/id888894773?mt=11">Using Swift with Cocoa and Objective C by Apple</a> <img src="/images/swift_logo.png" width="20" height="20"></li><li><a href="https://www.bignerdranch.com/we-write/ios-programming/">iOS Programming: The Big Nerd Ranch Guide by Christian Keur, Aaron Hillegass, Joe Conway</a></li><li><a href="http://www.amazon.com/Programming-Objective-C-6th-Developers-Library/dp/0321967607">Programming in Objective-C by Stephen G. Kochan</a></li><li><a href="https://leanpub.com/your-first-ios-app">Your First iOS App by Ash Furrow</a></li><li><a href="https://www.mikeash.com/book.html">The Complete Friday Q &amp; A: Volume 1</a></li><li><a href="http://www.amazon.com/Core-Data-iOS-Data-Driven-Applications/dp/0321670426/">Core Data for iOS: Developing Data-Driven Applications for the iPad, iPhone, and iPod touch</a></li><li><a href="http://www.amazon.com/Cocoa-Design-Patterns-Erik-Buck/dp/0321535022">Cocoa Design Patterns</a></li></ul><h1 id="其他优秀的列表"><a href="#其他优秀的列表" class="headerlink" title="其他优秀的列表"></a><a name="other-awesome-lists"></a>其他优秀的列表</h1><p>你可以在下面找到其他十分优秀的列表</p><ul><li><a href="https://github.com/bayandin/awesome-awesomeness">awesome-awesomeness</a> 列表。</li><li><a href="https://github.com/dkhamsing/open-source-ios-apps">Open Source apps</a> 开源 iOS app 列表。</li><li>优秀的 Swift 列表<ul><li><a href="https://github.com/matteocrippa/awesome-swift">@matteocrippa</a> - 一个优秀的 Swift 资源合集列表。</li><li><a href="https://github.com/Wolg/awesome-swift">@Wolg</a> - 一个很棒的 Swift 框架，库和软件的策划列表。</li></ul></li><li><a href="https://github.com/sanketfirodiya/sample-watchkit-apps">awesome watchkit apps</a>  watchkit app 例程和教程的列表。<img src="/images/applewatch_logo.png" width="20" height="20"></li><li><a href="https://github.com/sanketfirodiya/iOS-learning-resources">iOS Learning Resources</a> 一个高质量，频繁更新并且被很好维护的 iOS 教程网站的完整集合。</li><li><a href="https://github.com/sxyx2008/awesome-ios-animation">awesome-ios-animation</a> - 包括了 Objective-C 和 Swift 实现的 iOS 动画库列表。</li><li><a href="https://github.com/sxyx2008/awesome-ios-chart">awesome-ios-chart</a> - 很棒的 iOS 图表库列表。包括了 Objective-C 和 Swift 两种语言。</li><li><a href="https://github.com/vsouza/awesome-gists#ios">awesome-gists</a> - 很棒的 Gist 列表 (iOS 章节).</li><li><a href="https://github.com/cjwirth/awesome-ios-ui">awesome-ios-ui</a> - 优秀的 iOS UI/UX 库列表。</li></ul><h1 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a><a name="contributing"></a>贡献</h1><p><a href="https://github.com/vsouza/awesome-ios/blob/master/CONTRIBUTING.md">详见指南</a></p><h1 id="许可"><a href="#许可" class="headerlink" title="许可"></a><a name></a>许可</h1><a rel="license" href="http://creativecommons.org/publicdomain/mark/1.0/"><img src="/images/public_domain.png" style="border-style: none;" alt="Public Domain Mark"></a><p>在法律允许的范围内, <a href="https://github.com/vsouza">Vinicius Souza</a> 放弃了版权以及有关这份成果的全部权益。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/images/awesome_logo.png&quot; width=&quot;400&quot;&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/sindresorhus/awesome&quot;&gt;&lt;img src=&quot;https://cdn.rawgit.com/sindresorhus/awesome/d7305f38d29fed78fa85652e3a63e154dd8e8829/media/badge.svg&quot; alt=&quot;Awesome&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/vsouza/awesome-ios/blob/master/README.md#image&quot;&gt;原文在此&lt;/a&gt; 翻译 by skyfly.xyz&lt;/p&gt;
&lt;p&gt;这是个精心编排的列表，它包含了优秀的 iOS 框架，库，教程，XCode 插件，组件等等。&lt;/p&gt;
&lt;p&gt;这个列表分为以下几个部分：框架（ Frameworks ），组件（ Components ），测试（ Testing ）和其他的开源项目，免费的和付费的服务。每个部分中的项目没有先后顺序，均是按照提交的先后顺序排列的。如果你想为这个列表作出贡献，请阅读这个&lt;a href=&quot;https://github.com/vsouza/awesome-ios/blob/master/CONTRIBUTING.md&quot;&gt;指南&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Swift 语言写成的项目会被标记为 &lt;img src=&quot;/images/swift_logo.png&quot; width=&quot;20&quot; height=&quot;20&quot;&gt; ，AppleWatch 的项目则会被标记为 &lt;img src=&quot;/images/applewatch_logo.png&quot; width=&quot;20&quot; height=&quot;20&quot;&gt;。你可以自由添加你的项目。&lt;/p&gt;
&lt;h3 id=&quot;内容&quot;&gt;&lt;a href=&quot;#内容&quot; class=&quot;headerlink&quot; title=&quot;内容&quot;&gt;&lt;/a&gt;&lt;a name&gt;&lt;/a&gt;内容&lt;/h3&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://ufolux.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift学习笔记-深入理解可选类型</title>
    <link href="https://ufolux.github.io/2015/12/20/Swift/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8F%AF%E9%80%89%E7%B1%BB%E5%9E%8B/"/>
    <id>https://ufolux.github.io/2015/12/20/Swift/Swift学习笔记-可选类型/</id>
    <published>2015-12-20T07:38:07.000Z</published>
    <updated>2021-03-11T07:20:00.109Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="和-是什么"><a href="#和-是什么" class="headerlink" title="? 和 ! 是什么"></a>? 和 ! 是什么</h2><p>接触 Swift 的小伙伴们肯定对 <code>?</code> 和 <code>!</code> 这俩符号不陌生。他们广泛地出现在 iOS SDK 的各个地方。IDE 也会自动补全这两个家伙。但是这两个家伙到底是啥?</p><span id="more"></span><p>这两个符号表达了 Swift 的一个重要的特性，那就是可选类型（Optional Type）。可选类型是 Swift 引入的一个概念，它为那些在编译时不能确定是否有值的变量做了一个包装。</p><h3 id><a href="#" class="headerlink" title="?"></a>?</h3><p>可选类型实际上是这样一个枚举：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public enum Optional&lt;Wrapped&gt; : _Reflectable, NilLiteralConvertible &#123;</span><br><span class="line">    case None</span><br><span class="line">    case Some(Wrapped)</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Construct a &#96;nil&#96; instance.</span><br><span class="line">    public init()</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Construct a non-&#96;nil&#96; instance that stores &#96;some&#96;.</span><br><span class="line">    public init(_ some: Wrapped)</span><br><span class="line">    &#x2F;&#x2F;&#x2F; If &#96;self &#x3D;&#x3D; nil&#96;, returns &#96;nil&#96;.  Otherwise, returns &#96;f(self!)&#96;.</span><br><span class="line">    @warn_unused_result</span><br><span class="line">    public func map&lt;U&gt;(@noescape f: (Wrapped) throws -&gt; U) rethrows -&gt; U?</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Returns &#96;nil&#96; if &#96;self&#96; is nil, &#96;f(self!)&#96; otherwise.</span><br><span class="line">    @warn_unused_result</span><br><span class="line">    public func flatMap&lt;U&gt;(@noescape f: (Wrapped) throws -&gt; U?) rethrows -&gt; U?</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Create an instance initialized with &#96;nil&#96;.</span><br><span class="line">    public init(nilLiteral: ())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于这个枚举需要经常被使用，总是让大家写 <code>var num: Optional&lt;Int&gt;</code> 这样的代码，恐怕没几个人愿意。所以苹果的工程师把它包装成了 <code>?</code> 给大家吃了个糖。</p><p>可见，<code>Optional</code> 枚举有两种状态，<code>None</code> 代表没有值，<code>Some</code> 代表有值。<br>基本类型的变量在使用之前必须被初始化，否则无法通过编译。可选类型可以不经过初始化就直接使用，可选类型会被初始化为 nil。</p><p>也就是说在 Swift 中，所有的非可选类型在使用时都是一定被初始化过的。这保证了非可选变量在使用的时候只有一种状态：有值。这为 Swift 程序提供了极强的安全性。</p><p>但是在实际应用中有些变量的值并不能在编译时确定下来，所以光有非可选类型是不够的，这时候就需要可选类型的支持了。可选类型的作用也就在于提供可空类型的变量。</p><p>对于可选值，我们并不能直接访问被它包装的值。这些值需要我们对可选值解包之后才能访问。</p><p>如以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a:NSString? &#x3D; &quot;test&quot;</span><br><span class="line">print(a)</span><br><span class="line">&#x2F;&#x2F; output: Optional(test)</span><br></pre></td></tr></table></figure><p>我们可以看到字符串 test 是被 Optional 泛型枚举包装着的，如果这是直接调用 <code>NSString</code> 的方法是不能编译通过的。</p><h3 id="-1"><a href="#-1" class="headerlink" title="!"></a>!</h3><p><code>!</code> 表示对可选类型的变量强制拆包，和 <code>?</code> 一样，它也是一个语法糖，实际上它是这个枚举：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public enum ImplicitlyUnwrappedOptional&lt;Wrapped&gt; : _Reflectable, NilLiteralConvertible &#123;</span><br><span class="line">    case None</span><br><span class="line">    case Some(Wrapped)</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Construct a &#96;nil&#96; instance.</span><br><span class="line">    public init()</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Construct a non-&#96;nil&#96; instance that stores &#96;some&#96;.</span><br><span class="line">    public init(_ some: Wrapped)</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Construct an instance from an explicitly unwrapped optional</span><br><span class="line">    &#x2F;&#x2F;&#x2F; (&#96;Wrapped?&#96;).</span><br><span class="line">    public init(_ v: Wrapped?)</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Create an instance initialized with &#96;nil&#96;.</span><br><span class="line">    public init(nilLiteral: ())</span><br><span class="line">    &#x2F;&#x2F;&#x2F; If &#96;self &#x3D;&#x3D; nil&#96;, returns &#96;nil&#96;.  Otherwise, returns &#96;f(self!)&#96;.</span><br><span class="line">    @warn_unused_result</span><br><span class="line">    public func map&lt;U&gt;(@noescape f: (Wrapped) throws -&gt; U) rethrows -&gt; U!</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Returns &#96;nil&#96; if &#96;self&#96; is nil, &#96;f(self!)&#96; otherwise.</span><br><span class="line">    @warn_unused_result</span><br><span class="line">    public func flatMap&lt;U&gt;(@noescape f: (Wrapped) throws -&gt; U!) rethrows -&gt; U!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以这样声明变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var label:UILabel!</span><br></pre></td></tr></table></figure><p>这个枚举直译过来就是 <strong>隐式拆包 Optional</strong>，其实就是在你每次操作这种类型的值时候都会自动在操作前面补上一个 <code>!</code> 拆包。</p><p><code>!</code> 用于 Optional 类型变量的时候表示对变量进行强制拆包，而不管该变量又没有值。这样一来，当变量没有值的时候（nil）强制拆包将导致程序运行时崩溃。</p><p>可选类型的好处在于在编译时为语言提供了安全性，最大程度上避免了野指针调用使程序崩溃的情况发生。</p><h2 id="调用可选类型变量的属性和方法"><a href="#调用可选类型变量的属性和方法" class="headerlink" title="调用可选类型变量的属性和方法"></a>调用可选类型变量的属性和方法</h2><p>上面说到了，我们不能直接对可选类型变量调用方法和属性。这时我们需要对这个可选类型解包。<br>假设现在有 Person 和 Name 类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Name &#123;</span><br><span class="line">    var firstName: String &#x3D; &quot;&quot;</span><br><span class="line">    var lastName: String &#x3D; &quot;&quot;</span><br><span class="line">    init (firstName:String, lastName:String)</span><br><span class="line">    &#123;</span><br><span class="line">        self.firstName &#x3D; firstName</span><br><span class="line">        self.lastName &#x3D; lastName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    var name:Name</span><br><span class="line">    init (name:Name)</span><br><span class="line">    &#123;</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="强制解包"><a href="#强制解包" class="headerlink" title="强制解包"></a>强制解包</h3><p>使用感叹号 <code>!</code> 进行强制解包。顾名思义，强制解包就是不管变量是否有值都对其进行解包。有值的时候，解包成功，程序正常运行。如果没有值(等于 nil)，解包会失败，程序在运行时发生崩溃。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 下面代码正常运行</span><br><span class="line">var p1: Person? &#x3D; Person(name: Name(firstName: &quot;Richard&quot;, lastName: &quot;Lu&quot;))</span><br><span class="line">print(p1!.name.firstName)</span><br><span class="line">&#x2F;&#x2F;output: Richard</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 下面代码会发生错误</span><br><span class="line">var p2: Person?</span><br><span class="line">print(p2!.name.firstName)</span><br><span class="line">&#x2F;&#x2F; error: EXC_BAD_INSTRUCTION</span><br></pre></td></tr></table></figure><p>强制解包是一种不安全的做法。很可能导致程序在运行时崩溃。所以不经判断直接解包的方式一般是不推荐使用的。除非用在那些你确定一定会有值的变量上，比如 IBOutlet 等。</p><p>改进一下，添加一些安全代码就可以了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var p4: Person? &#x3D; Person(name: Name(firstName: &quot;Richard&quot;, lastName: &quot;Lu&quot;))</span><br><span class="line">if p4 !&#x3D; nil &#123;</span><br><span class="line">   print(p4!.name.firstName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Optional-Binding"><a href="#Optional-Binding" class="headerlink" title="Optional Binding"></a>Optional Binding</h3><p>在 if 语句中可以对可选类型变量进行隐式解包，同时判断可选类型是否有值，根据判断的结果进行进一步的操作。这也是推荐的一种做法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var p3: Person? &#x3D; Person(name: Name(firstName: &quot;Richard&quot;, lastName: &quot;Lu&quot;))</span><br><span class="line">if let person &#x3D; p3 &#123;</span><br><span class="line">    print(person.name.firstName)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; output: Richard</span><br></pre></td></tr></table></figure><h3 id="可选链（Optional-Chaining）"><a href="#可选链（Optional-Chaining）" class="headerlink" title="可选链（Optional Chaining）"></a>可选链（Optional Chaining）</h3><p>上面的情况是比较简单的，毕竟只有最外层的对象是可选类型的。如果对象的属性也是可选类型呢？假设我们的 Person 和 Name 类变成了下面的样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Name &#123;</span><br><span class="line">    var firstName: String ＝ &quot;&quot;</span><br><span class="line">    var lastName: String &#x3D; &quot;&quot;</span><br><span class="line">    init (firstName:String, lastName:String)</span><br><span class="line">    &#123;</span><br><span class="line">        self.firstName &#x3D; firstName</span><br><span class="line">        self.lastName &#x3D; lastName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    var name: Name?</span><br><span class="line">    init (name: Name)</span><br><span class="line">    &#123;</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在想要取到 <code>firstName</code> 的值，使用 Optional Binding 或者强制拆包的方法要这么写：</p><p>Optional Binding</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var p: Person? &#x3D; Person(name: Name(firstName: &quot;Richard&quot;, lastName: &quot;Lu&quot;))</span><br><span class="line">if let person &#x3D; p &#123;</span><br><span class="line">    if let name &#x3D; person.name &#123;</span><br><span class="line">            print(name.firstName)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强制拆包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var p: Person? &#x3D; Person(name: Name(firstName: &quot;Richard&quot;, lastName: &quot;Lu&quot;))</span><br><span class="line">if p !&#x3D; nil &#123;</span><br><span class="line">    if p!.name !&#x3D; nil &#123;</span><br><span class="line">       print(p!.name!.firstName)  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见不是一般的麻烦，一层套一层的判断逻辑搞的人头大。不过 Swift 早就为你设计了可选链（ Optional Chaining ）这种功能来实现方便的调用。</p><p>使用可选链，对于如上的调用我们只要这样写就够了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var p: Person? &#x3D; Person(name: Name(firstName: &quot;Richard&quot;, lastName: &quot;Lu&quot;))</span><br><span class="line">if let firstName &#x3D; p?.name?.firstName</span><br><span class="line">&#123;</span><br><span class="line">    print(firstName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对可选值直接进行链式操作，使得调用变得很方便。但是这里有个细节需要注意。<strong>可选链表达式中只要有一个 Optional 值，整个表达式的结果就都是 Optional 值，不管最后取到的值是不是 Optional 值，也不管表达式中有多少个 Optional 值。</strong> 所以对于可选链表达式的结果需要按照如上方法来取真实的值。如果我们直接打印 <code>p?.name?.firstName</code> 最终得到的将是一个被 Optional 包装的 firstName 值。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;和-是什么&quot;&gt;&lt;a href=&quot;#和-是什么&quot; class=&quot;headerlink&quot; title=&quot;? 和 ! 是什么&quot;&gt;&lt;/a&gt;? 和 ! 是什么&lt;/h2&gt;&lt;p&gt;接触 Swift 的小伙伴们肯定对 &lt;code&gt;?&lt;/code&gt; 和 &lt;code&gt;!&lt;/code&gt; 这俩符号不陌生。他们广泛地出现在 iOS SDK 的各个地方。IDE 也会自动补全这两个家伙。但是这两个家伙到底是啥?&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://ufolux.github.io/categories/Swift/"/>
    
    
      <category term="学习" scheme="https://ufolux.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习笔记-动态特性</title>
    <link href="https://ufolux.github.io/2015/12/20/Swift/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7/"/>
    <id>https://ufolux.github.io/2015/12/20/Swift/Swift学习笔记-动态特性/</id>
    <published>2015-12-20T06:32:37.000Z</published>
    <updated>2021-03-11T07:20:00.109Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们知道 Objective-C 的最显著的特性就是强大的运行时能力，这使得 Objective-C 几乎是完全灵活的一本语言。强大的自省，反射，运行时的消息派发，KVC，KVO 都让这个有着几十年历史的语言依然焕发着生机。Swift 作为一门现代化的编程语言，是十分安全的语言。绝大多数的内容都是在编译期就已经决定了的。这使得 Swift 的运行时灵活性有所折扣。但需求总是千变万化的，运行时特性往往能起到四两拨千斤的强大作用，所以 Swift 还是引入了一些动态特性，我们来逐一看一下。</p><span id="more"></span><h2 id="获取对象类型"><a href="#获取对象类型" class="headerlink" title="获取对象类型"></a>获取对象类型</h2><p>在 Objective-C 中我们可以很容易地做到这件事，只要使用 <code>-class</code> 方法就可以轻松地获取到到对象的类，使用 <code>NSStringFromClass</code> 方法还可以将类的名称转换成字符串。</p><p>Swift 中分为两种情况来考虑，第一种情况是 NSObject 的子类，另一种情况是纯 Swift class</p><h3 id="NSObject-子类"><a href="#NSObject-子类" class="headerlink" title="NSObject 子类"></a>NSObject 子类</h3><p>对于 NSObject 子类来讲，其实它们类的信息的存储方式和在 Obj-C 中并没有什么变化，只是没有了 <code>-class</code> 方法供你直接使用了而已。所以这时候可以使用 Objective-C 运行时（runtime）来获取类的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let name &#x3D; object_getClass(NSDate())</span><br><span class="line">print(name) &#x2F;&#x2F;__NSDate</span><br></pre></td></tr></table></figure><p>这里使用的其实是 Objective-C runtime 中的方法 <code>object_getClass</code> 这个方法接受一个 AnyObject! 参数，并返回 AnyClass! 类型。也就是说这个方法可以接受 nil 作为参数并返回一个 nil。</p><h3 id="纯-Swift-class"><a href="#纯-Swift-class" class="headerlink" title="纯 Swift class"></a>纯 Swift class</h3><p>这里需要使用 <code>dynamicType</code> 来获取类型，值得一提的是在 Swift 1.2 版本之后，我们就也可以对 NSObject 子类使用 <code>dynamicType</code> 来获取类型了。这样的话，在 Swift 中获取对象类型的方法就变得统一起来。</p><h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>在 Objective-C 中我们可以通过 selector 做很多事情，包括询问对象是否接受某个方法，指定通知调用的方法，设定 target-action 等等都是由 selector 来完成的。在 Obj-C 中我们可以很方便的使用 @selector 创建 selector 或者 NSSelectorFromString 来根据字符串动态创建 selector。Swift 中不再提供 <code>@selector</code> 我们只能够通过字符串来创建 Selector。</p><p>原来的 SEL 在 Swift 中对应的是一个 Selector 结构体，它提供了只接受一个字符串的初始化方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let selector &#x3D; Selector(&quot;test&quot;)</span><br></pre></td></tr></table></figure><p>Swift 中的 Selector 实现了 <code>StringLiteralCovertible</code> 协议，所以我们可以直接使用字符串赋值来完成创建 Selector 的工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.performSelector(&quot;test&quot;)</span><br></pre></td></tr></table></figure><p>注意：</p><p>在 Swift 中，如果 selector 对应的方法是被 <em>private</em> 修饰的话（也就是说这个方法仅在 Swift 中可见），在运行时会寻找不到对应的方法，报出<code>unrecongnized selector</code>错误。这时需要在 private 前面加上 @objc 关键字来修饰。这样在运行时就可以找到相应的方法了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@objc private func test()</span><br><span class="line">&#123;</span><br><span class="line">   print(&quot;test&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当第一个参数有外部变量的话，需要在方法名和第一个外部参数之间加上 <code>with</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func test(external name:String)</span><br><span class="line">&#123;</span><br><span class="line">   print(&quot;test&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self.performSelector(&quot;testWithExternal:&quot;, withObject: &quot;&quot;)</span><br></pre></td></tr></table></figure><h2 id="动态创建对象"><a href="#动态创建对象" class="headerlink" title="动态创建对象"></a>动态创建对象</h2><p>Objective-C 可以直接使用字符串或者 Class 来创建对象实例，但是 Swift 中尚未发现有这样的方法。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射是一种在运行时检测，访问或者修改类型的的行为的特性。在 Objective-C 中一般很少提及“反射”这个词，更多的是“运行时”（runtime）这种说法。这是因为 Objective-C 能够提供的运行时特性比一般的反射要强大得多。对于NSObject 子类来讲，使用 Swift 的时候也可以无缝地使用这些特性。如果抛开这些 Objective-C 的特性的话，纯 Swift 虽然也提供了一些反射的内容，但是相对要弱得多。以下内容均是基于 Swift2.2 环境：</p><p>Swift 中定义的类型都实现了 <code>_Reflectable</code> 接口，这个接口提供了一个 <code>getMirror</code> 方法用于获取实现了 <code>MirrorType</code> 接口的镜像，这个镜像对象包含了类内部基本的信息。开发者需要通过 reflect 方法来获取这个对象。进而在不了解对象类型的情况下对其内部进行操作。</p><p><code>_reflect</code> 可以作用于所有的类型，下面举一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class superapple : NSObject &#123;</span><br><span class="line">    var name:String</span><br><span class="line">    init (name: String)</span><br><span class="line">    &#123;</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class apple : superapple</span><br><span class="line">&#123;</span><br><span class="line">    var color:String</span><br><span class="line">    </span><br><span class="line">    init (color:String)</span><br><span class="line">    &#123;</span><br><span class="line">        self.color &#x3D; color</span><br><span class="line">        print(self.color)</span><br><span class="line">        super.init(name:&quot;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    convenience init(name: String, color: String)</span><br><span class="line">    &#123;</span><br><span class="line">        self.init(color : color)</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var app &#x3D; apple.init(name: &quot;apple&quot;, color: &quot;red&quot;)</span><br><span class="line">let mirt &#x3D; _reflect(app)</span><br><span class="line">print(&quot;属性个数\(mirt.count)&quot;)</span><br><span class="line">print(&quot;属性1:\(mirt[0].0) 值:\(mirt[0].1.summary)&quot;)</span><br><span class="line">print(&quot;属性2:\(mirt[1].0) 值:\(mirt[1].1.summary)&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出：</span><br><span class="line">&#x2F;&#x2F;属性个数2</span><br><span class="line">&#x2F;&#x2F;属性1:super 值:superapple</span><br><span class="line">&#x2F;&#x2F;属性2:color 值:red</span><br></pre></td></tr></table></figure><p>我们发现 <code>MirrorType</code> 类型的对象中包含了所有的属性，我们可以通过下标来访问这些属性，每一个下标对应着一个元组（Tuple），每个元组的第一位表示属性的名称，第二位是封装了属性的值的一个 Mirror 类型，值需要通过 summary 或者 MirrorType 的 value 来访问。</p><p>现时的 Swift 版本中反射功能仍然很弱，我们只可以读取属性的值，但是并不能设置属性的值。希望之后的版本可以提供类似 KVC 的强大反射特性。</p><h2 id="自省（Introspection）"><a href="#自省（Introspection）" class="headerlink" title="自省（Introspection）"></a>自省（Introspection）</h2><p>Swift 的类型绝大多数都是在编译期就已经确定的，但是实际中有时候还是需要在运行时来判断对象属于什么类型，这时可以使用 <code>is</code> 运算符来进行判断，<code>is</code> 相当于 Objective-C 中的 <code>isKindOfClass</code> 方法，用于判断一个对象是否属于一个类或者他的子类。不同点在于，<code>is</code> 不但可以用于 class 类型，也可以用于 struct ，enum 甚至基本类型的判断。用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">    var name &#x3D; &quot;skyfly&quot;</span><br><span class="line">&#125;</span><br><span class="line">var instance: AnyObject &#x3D; Test()</span><br><span class="line"></span><br><span class="line">if instance is Test</span><br><span class="line">&#123;</span><br><span class="line">    print(&quot;instance is Test&#39;s Instance&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是就返回 true，不是就会返回 false。<br>但是注意的一点是，编译器会检查类型判定的必要性，没有必要的判定会被编译器发出警告。比如如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">    var name &#x3D; &quot;skyfly&quot;</span><br><span class="line">&#125;</span><br><span class="line">var instance &#x3D; Test()</span><br><span class="line"></span><br><span class="line">if instance is Test</span><br><span class="line">&#123;</span><br><span class="line">    print(&quot;instance is Test&#39;s Instance&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; warning: is Test is always true</span><br></pre></td></tr></table></figure><h2 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h2><p><strong>纯 Swift 中并没有提供 KVC 的功能</strong>，不过所有继承自 NSObject 的子类还是可以直接使用 KVC 的，因为 NSObject 有 NSKeyValueCoding 扩展。使用方法也大同小异，基本上只是语法变形而已。</p><h2 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h2><p>同 KVC 一样，<strong>纯 Swift 并没有提供 KVO 的功能</strong>，使用 KVO 仍然是基于 NSObject 子类对象的，实质上 KVO 和 KVC 依然是基于 Objective-C 运行时实现的，这一点也无可非议。在 Swift 中使用 KVO 需要将 观察的属性使用 dynamic 来修饰。</p><p>Swift 中使用 KVO 面临的阻碍较多，我们只能观测被 dynamic 修饰的属性，而往往第三方框架中的属性没有这个修饰，或者我们无法修改使用的源码，这时就需要继承这个类并且使用 dynamic 重写想要观察的属性。</p><p>对于纯 Swift 类型来讲，由于实现原理的问题，暂时没有对其实现 KVO 的办法。目前只能使用<em>属性观察</em>来做替代了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class TestForKVC:NSObject&#123;</span><br><span class="line">    var name &#x3D; &quot;skyfly&quot;</span><br><span class="line">&#125;</span><br><span class="line">var instance &#x3D; TestForKVC()</span><br><span class="line">var value &#x3D; instance.valueForKey(&quot;name&quot;) as! String</span><br><span class="line">instance.setValue(&quot;hello world&quot;,forKey:&quot;name&quot;)</span><br></pre></td></tr></table></figure><h2 id="方法调配（Method-Swizzing）"><a href="#方法调配（Method-Swizzing）" class="headerlink" title="方法调配（Method Swizzing）"></a>方法调配（Method Swizzing）</h2><p>对于 NSObject 子类，使用方法和 Objective-C 中基本类似，只是对语法做一些变形。对于纯 Swift 类型来讲，如果想要使用 Swizzle 就需要在原来的方法和替换的方法前面都加上 <code>dynamic</code> 标记以声明他们使用动态派发机制。</p><p>虽然 Swift 的 Method Swizzing 完全依赖了 Objective-C 运行时，但是仍然有一个的第三方实现了完全不借助 Objective-C 运行时来实现了 Method Swizzing，详见 <a href="https://github.com/rodionovd/SWRoute">SWRoute</a>，他利用了一些内存的 hack 手段，利用 Swift 封装过的类似函数指针的东西来实现了方法调配。  </p><h2 id="关联对象（Associated-Object）"><a href="#关联对象（Associated-Object）" class="headerlink" title="关联对象（Associated Object）"></a>关联对象（Associated Object）</h2><p>Swift 中仍然可以使用关联对象。仍然是对原有方法进行语法变形即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道 Objective-C 的最显著的特性就是强大的运行时能力，这使得 Objective-C 几乎是完全灵活的一本语言。强大的自省，反射，运行时的消息派发，KVC，KVO 都让这个有着几十年历史的语言依然焕发着生机。Swift 作为一门现代化的编程语言，是十分安全的语言。绝大多数的内容都是在编译期就已经决定了的。这使得 Swift 的运行时灵活性有所折扣。但需求总是千变万化的，运行时特性往往能起到四两拨千斤的强大作用，所以 Swift 还是引入了一些动态特性，我们来逐一看一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://ufolux.github.io/categories/Swift/"/>
    
    
      <category term="学习" scheme="https://ufolux.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习笔记-内存管理</title>
    <link href="https://ufolux.github.io/2015/12/18/Swift/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://ufolux.github.io/2015/12/18/Swift/Swift学习笔记-内存管理/</id>
    <published>2015-12-18T14:12:49.000Z</published>
    <updated>2021-03-11T07:20:00.108Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="避免循环引用"><a href="#避免循环引用" class="headerlink" title="避免循环引用"></a>避免循环引用</h2><p>Swift 和 Objective-C 一样使用了自动引用计数来进行内存管理。引用计数的内存管理就无可避慢的会产生循环引用这种问题。Swift 针对这个问题也给出了 <code>weak</code> 和 <code>unowned</code> 两种声明非持有所有权的引用修饰符。二者的区别在于 <code>weak</code> 和 Obj-C 中的 <code>weak</code> 完全相同，声明一个弱引用，不会增加被引用内存的引用计数，在所指向的内存被释放时指针会自动被置为 <code>nil</code>。<code>unowned</code> 则类似于 Obj-C 中的 <code>unsafe_unretain</code> 修饰符，作用和 <code>weak</code> 相同，但在所致内存被释放后不会被自动置为 <code>nil</code>，而是<strong>保留指向原来内存空间的引用</strong>，若对象已经被释放后对其发生了方法调用则会造成崩溃。</p><p>苹果的推荐使用方法是：<strong>在能够确定在访问时对象一定没有被释放的情况下使用 <code>unowned</code>，在不能够确定时使用 <code>weak</code></strong>，这么做的原因我想是因为使用 <code>weak</code> 时由于在内存释放时需要对指针进行置空操作，耗费了一定的性能，所以能够确定的情况下使用 <code>unowned</code> 比较好。</p><p>使用弱引用的情况：</p><ol><li>设置 delegate 时</li><li>在 self 持有的闭包中引用 self 时</li></ol><p>可以这样标注闭包中的元素，指定它们的内存管理语义：</p><span id="more"></span><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getaclosure(&quot;as&quot;) &#123;[weak self] (name) -&gt; Int in</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如需要标注多个元素则需要使用逗号将它们分开：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getaclosure(&quot;as&quot;) &#123;[weak self, unowned someObject] (name) -&gt; Int in</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="@autoreleasepool"></a>@autoreleasepool</h2><p>Swift 同样采用 ARC 管理内存，所以 autoreleasepool 这个东西也照旧被搬了过来。自动释放池的作用是将所有需要<strong>稍后释放</strong>的对象放进去，在使用之后进行统一的释放。避免对象在尚未被使用之前就已经被释放。是一种延迟释放的方式。在 Swift 项目中不再需要像 Objective-C 那样在 main 函数手动为整个程序包一个 @autoreleasepool 了，编译器已经帮你完成了这些操作。但是有一种情况还是需要自动释放，当一个代码块生成了大量的 autorelease 对象的时候，需要使用 autoreleasepool 来包裹这部分代码。</p><p>在循环中，使用工厂方法创建对象的时候，往往创建出的都是 autorelease 对象，这是需要使用 autorelease 闭包来进行包装。防止内存突增。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for _ in 1...1000 &#123;</span><br><span class="line">   let date &#x3D; NSData.dataWithContentsOfMappedFile(&quot;filename&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码会造成内存的暴涨，因为在循环过程中产生了大量的 autorelease 变量，这些变量并不会立即被释放，而是在 runloop 周期执行结束时才会被释放。正确的做法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for _ in 1...1000 &#123;</span><br><span class="line">    autoreleasepool &#123;</span><br><span class="line">       let date &#x3D; NSData.dataWithContentsOfMappedFile(&quot;filename&quot;)</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做就不会有问题了。</p><p>但是需要注意的是，在 Swift 1.1 之后，以上的工厂方法生成对象已经不是 Swift 推荐的做法，推荐的做法是使用可以返回 nil 的初始化方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let date &#x3D; Data(contentsOfFile: path)</span><br></pre></td></tr></table></figure><p>这样就不会存在自动释放的问题了，每次循环结束的时候 ARC 会自动为我们处理好内存管理的事情。</p><h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><p>和大多数语言一样，Swift 的数据类型分为值类型和引用类型两种，值类型在传递和复制的时候将会进行复制，引用类型则只会使用引用对象的一个<code>指向</code>。</p><blockquote><p>Swift 中的 <em>struct 和 enum</em> 定义的类型都是值类型，<em>class</em> 定义的类型都是引用类型。</p></blockquote><p>这样一来我们就知道一个问题，Swift 的所有内建类型全部都是值类型的。甚至连集合类型都是值类型的数据。这也是 Swift 和其他主流语言的一个比较大的区别。清一色的值类型数据给 Swift 带来了较好的性能，因为相对于使用引用类型而言，使用值类型的数据可以有效的减少堆上内存的分配和回收，这无疑会有很大的性能提升。值类型的复制肯定也会产生开销，但是在 Swift 的精心设计下，应将这种复制的开销降到了最低。为什么这么说呢，看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func test(arr:[Int])&#123;</span><br><span class="line">    print(arr.first!)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a &#x3D; [1,2,3]</span><br><span class="line">var b &#x3D; a</span><br><span class="line">let c &#x3D; b</span><br><span class="line">test(c)</span><br></pre></td></tr></table></figure><p>以上代码中的 <code>a,b,c</code> 和方法中的 <code>arr</code> 事实上指向的是同一块内存，这样的代码并没有改变 <code>a</code> 的内部数据，Swift 对此进行了优化，在没有必要复制的情况下不会对值类型进行复制操作。这样的值类型操作完全是在栈内存上进行的，这里我个人觉得可以理解为是对栈内存的“引用”，并没有产生任何的堆内存分配和释放操作，运行效率很高。</p><p>以下代码会产生复制的动作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func test(arr:[Int])&#123;</span><br><span class="line">    print(arr.first!)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a &#x3D; [1,2,3]</span><br><span class="line">var b &#x3D; a</span><br><span class="line">b.append(4)</span><br></pre></td></tr></table></figure><p>由于改变了数组的内容，为了遵守值类型语义，所以会对其进行复制操作。</p><p>对于集合类型，在复制的时候会将集合类型内部的值类型元素进行复制，集合类型内部的引用类型元素则会被复制一份引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class testobj &#123;</span><br><span class="line">    var num &#x3D; 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; testobj()</span><br><span class="line">var arr &#x3D; [obj]</span><br><span class="line">var b &#x3D; arr</span><br><span class="line">b.append(obj)</span><br><span class="line"></span><br><span class="line">obj.num &#x3D; 100</span><br><span class="line">print(b[0].num) &#x2F;&#x2F;100</span><br><span class="line">print(b[1].num) &#x2F;&#x2F;100 </span><br><span class="line">&#x2F;&#x2F;数组中复制的是obj的引用，对obj的操作使得b[0],b[1]同时受到了影响</span><br></pre></td></tr></table></figure><p>通过以上可以看出，对于容器内容数据量小变化少，容器个数多，对内容变化不频繁的情况，使用 Swift 值类型集合会显著的提高性能，降低开销。对于容器内容数据量大，且需要频繁对容器进行内容的增减操作的情况，使用 Cocoa 提供的引用类型集合会更好，这样可以避免在改变内容的时候进行大量的复制操作。具体的使用需要根据实际情况来考虑。</p><h2 id="C-指针的内存管理"><a href="#C-指针的内存管理" class="headerlink" title="C 指针的内存管理"></a>C 指针的内存管理</h2><p>在 Swift 中直接对指针进行操作是不提倡的，但是为了和 C 语言接口进行交互，Swift 还是提供了操作指针的方法。那就是 <code>UnsafePointer</code> 系列类型。这个系列目前（Swift 2.2）包括以下几种类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UnsafePointer</span><br><span class="line">UnsafeMutablePointer</span><br><span class="line">UnsafeBufferPointer</span><br><span class="line">UnsafeMutableBufferPointer</span><br><span class="line">COpaquePointer</span><br></pre></td></tr></table></figure><ol><li><p>UnsafePointer </p><p> 是对 C 语言指针的包装类型，在 Swift 中需要遵守统一的命名规则，对于 C 语言的基础类型在 Swift 中都有着以大写 C 开头的对应类型。如果我们 C API 接收的是一个 <code>int*</code> 类型的指针参数，这时对应的应该是用一个 <code>UnsafePointer&lt;CInt&gt;</code> 类型作为 Swift 的参数类型。 这里 UnsafePointer 对应的是不可变的版本的<code>const int *</code> <strong>常量指针</strong></p></li><li><p>UnsafeMutablePointer</p><p> 是 UnsafePointer 的可变版本。</p></li><li><p>UnsafeBufferPointer</p><p> 是不可变数组指针的包装类型，使用 <code>baseAddress</code> 取得 <code>UnsafePointer</code> 来对数组元素使用 <code>memory</code> 进行访问。</p></li><li><p>UnsafeMutableBufferPointer</p><p> 是可变数组的包装类型，使用 <code>baseAddress</code> 取得 <code>UnsafeMutablePointer</code> 来对数组元素使用 <code>memory</code> 进行访问。</p></li><li><p>COpaquePointer</p><p> 这是一类比较特殊的指针，用于包装 C 语言中那些在头文件中无法找到具体定义，只能拿到类型和名字的指针，即<code>不透明指针</code>。</p></li><li><p>CFunctionPointer</p><p> 顾名思义，函数指针。形式如：<code>CFunctionPointer&lt;()-&gt;CInt&gt;</code></p></li></ol><p>Swift 自动引用计数无法直接管理指针类型对象的内存。这部分的内存需要我们手动来管理。对于 <code>UnsafePointer</code> 在 Swift 中我们无法直接创建这个类型的实例，只能创建 <code>UnsafeMutablePointer</code> 的实例。一般的步骤是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">通过 alloc 向系统申请一块内存；</span><br><span class="line">使用 initialize 方法初始化这块内存；</span><br><span class="line">然后使用这块内存；</span><br><span class="line">调用 destroy 方法销毁内存；</span><br><span class="line">使用 dealloc 方法销毁指针本身；</span><br><span class="line">将指针置为 nil 。</span><br></pre></td></tr></table></figure><blockquote><p>需要把握的原则是，内存由谁创建就要由谁销毁。除非 API 文档明确告知需要用户来负责销毁内存。alloc 和 destroy dealloc 要成对的出现。</p></blockquote><p>需要说明的是，这里也可以使用 malloc 和 calloc 申请内存，Swift 提供了这两个方法均返回 UnsafeMutablePointer 类型的对象，这时需要使用 free 方法来释放内存。</p><p>对于这些直接操作内存的方法，Swift 中是十分不提倡的，因为会带来未知的错误和难以调试的 bug ，在使用这些方法之前，最好搞清楚自己在做什么，是不是真的别无他法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;避免循环引用&quot;&gt;&lt;a href=&quot;#避免循环引用&quot; class=&quot;headerlink&quot; title=&quot;避免循环引用&quot;&gt;&lt;/a&gt;避免循环引用&lt;/h2&gt;&lt;p&gt;Swift 和 Objective-C 一样使用了自动引用计数来进行内存管理。引用计数的内存管理就无可避慢的会产生循环引用这种问题。Swift 针对这个问题也给出了 &lt;code&gt;weak&lt;/code&gt; 和 &lt;code&gt;unowned&lt;/code&gt; 两种声明非持有所有权的引用修饰符。二者的区别在于 &lt;code&gt;weak&lt;/code&gt; 和 Obj-C 中的 &lt;code&gt;weak&lt;/code&gt; 完全相同，声明一个弱引用，不会增加被引用内存的引用计数，在所指向的内存被释放时指针会自动被置为 &lt;code&gt;nil&lt;/code&gt;。&lt;code&gt;unowned&lt;/code&gt; 则类似于 Obj-C 中的 &lt;code&gt;unsafe_unretain&lt;/code&gt; 修饰符，作用和 &lt;code&gt;weak&lt;/code&gt; 相同，但在所致内存被释放后不会被自动置为 &lt;code&gt;nil&lt;/code&gt;，而是&lt;strong&gt;保留指向原来内存空间的引用&lt;/strong&gt;，若对象已经被释放后对其发生了方法调用则会造成崩溃。&lt;/p&gt;
&lt;p&gt;苹果的推荐使用方法是：&lt;strong&gt;在能够确定在访问时对象一定没有被释放的情况下使用 &lt;code&gt;unowned&lt;/code&gt;，在不能够确定时使用 &lt;code&gt;weak&lt;/code&gt;&lt;/strong&gt;，这么做的原因我想是因为使用 &lt;code&gt;weak&lt;/code&gt; 时由于在内存释放时需要对指针进行置空操作，耗费了一定的性能，所以能够确定的情况下使用 &lt;code&gt;unowned&lt;/code&gt; 比较好。&lt;/p&gt;
&lt;p&gt;使用弱引用的情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设置 delegate 时&lt;/li&gt;
&lt;li&gt;在 self 持有的闭包中引用 self 时&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以这样标注闭包中的元素，指定它们的内存管理语义：&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://ufolux.github.io/categories/Swift/"/>
    
    
      <category term="学习" scheme="https://ufolux.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习笔记-可选协议</title>
    <link href="https://ufolux.github.io/2015/12/18/Swift/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8F%AF%E9%80%89%E5%8D%8F%E8%AE%AE/"/>
    <id>https://ufolux.github.io/2015/12/18/Swift/Swift学习笔记-可选协议/</id>
    <published>2015-12-18T08:10:45.000Z</published>
    <updated>2021-03-11T07:20:00.109Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在 Objective-C 中的协议方法分为可选 <code>@optional</code> 和必须 <code>@required</code> 两种。但是在 Swift 中则不同，所有的协议方法都是必须的。如果我们想要声明一个可选的接口，这该怎么做呢？</p><p>上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@objc protocol OptionalProtocol &#123;</span><br><span class="line">    optional func optionalFunc1() &#x2F;&#x2F;可选</span><br><span class="line">    func requiredFunc() &#x2F;&#x2F;必须</span><br><span class="line">    optional func optionalFunc2() &#x2F;&#x2F;可选</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们需要在协议定义之前加上 <code>@objc</code> 修饰，实际上是让这个协议本身被定义为 Objective-C 的。这里的声明和 Objective-C 不同的是没有 <code>@</code> 做开头。而且在 Swift 中，所有的前缀修饰符和声明都是完全分开的。也就是说必须为每一个声明都添加一个修饰符。对于没有修饰符的方法来说，他们都是必须实现的。</p><p>可选的协议不能被 Struct 和 enum 类型实现，也就是说只能被 class 实现，struct 和 enum 类型中不能包括可选方法或者属性，这算是一个弊端吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Swift" scheme="https://ufolux.github.io/categories/Swift/"/>
    
    
      <category term="学习" scheme="https://ufolux.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Swift和Objective-C的共同使用</title>
    <link href="https://ufolux.github.io/2015/12/18/Swift/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8DSwift%E5%92%8CObjective-C%E7%9A%84%E5%85%B1%E5%90%8C%E4%BD%BF%E7%94%A8/"/>
    <id>https://ufolux.github.io/2015/12/18/Swift/Swift学习笔记－Swift和Objective-C的共同使用/</id>
    <published>2015-12-18T07:14:12.000Z</published>
    <updated>2021-03-11T07:20:00.109Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-在-Swift-中使用-Objective-C-代码"><a href="#1-在-Swift-中使用-Objective-C-代码" class="headerlink" title="1.在 Swift 中使用 Objective-C 代码"></a>1.在 Swift 中使用 Objective-C 代码</h2><p>这种情况下的做法很简单，只需要在项目中添加名为 <code>&#123;product-module-name&#125;-Bridging-Header.h</code> 即 <code>target名称-Bridging-Header.h</code> 文件，并在这个文件中添加你想要引用的头文件即可。为求方便， Xcode 还会在向项目中第一次添加 Objective-C 文件时候提示是否需要自动添加这个文件。</p><span id="more"></span><h2 id="2-在-Objective-C-中使用-Swift-代码"><a href="#2-在-Objective-C-中使用-Swift-代码" class="headerlink" title="2.在 Objective-C 中使用 Swift 代码"></a>2.在 Objective-C 中使用 Swift 代码</h2><p>如果所使用的 Swift 代码来自于外部框架（Framework），这时只需要使用 <code>@import</code> 导入框架即可。<br>如果只想使用某一个文件中的代码，这时可以直接导入自动生成的头文件 <code>&#123;product-module-name&#125;-Swift.h</code> 来完成。<br>但是这里存在的问题是，Obj-C 和 Swift 的底层实现是两套完全不同的机制，Cocoa 中的 Obj-C 对象是完全基于运行时的，是通过 KVC 和消息动态派发机制来运作的。但 Swift 为了提升程序的性能，没有特殊需求的情况下不再使用运行时来决定这些。而是在编译时将类的方法活着成员全部确定下来。运行时不需要再去进行查找等操作，直接根据内存地址来调用。</p><p>所以，当我们的 Objective-C 程序需要使用 Obj-C 的代码或者特性来调用纯 Swift 类的时候就会因为找不到对应的运行时信息而失败。所以在使用这些代码之前需要做一些简单的处理。即，为所有可能被 Obj-C 代码调用的地方添加 <code>@objc</code> 修饰。包括类，类的成员和方法。但是如果你写的 Swift class 继承自 <code>NSObject</code> 的话就不需要做这一步，因为 Swift 已经默认为所有继承自 <code>NSObject</code>的<strong>非 <code>private</code> 类和成员或方法</strong> 添加了 <code>@objc</code> 修饰，使用这些代码的时候，你就只需要简单的引入头文件就可以了。（也就是说 <strong><code>private</code> 的类和成员并不会被自动添加，如果我们需要使用这些内容的动态特性的话，就必须手动为其添加<code>@objc</code>修饰</strong>）。</p><p>需要说明的一点是，<strong>使用了 <code>@objc</code> 修饰的 Swift 代码并不意味着会变成动态派发</strong>，Swift 仍然可能会对其进行编译优化。所以不能将这些内容当作运行时特性的代码来使用，如果需要类似 Objective-C 的完全运行时特性的话，这时你需要添加 <code>dynamic</code> 修饰符。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-在-Swift-中使用-Objective-C-代码&quot;&gt;&lt;a href=&quot;#1-在-Swift-中使用-Objective-C-代码&quot; class=&quot;headerlink&quot; title=&quot;1.在 Swift 中使用 Objective-C 代码&quot;&gt;&lt;/a&gt;1.在 Swift 中使用 Objective-C 代码&lt;/h2&gt;&lt;p&gt;这种情况下的做法很简单，只需要在项目中添加名为 &lt;code&gt;&amp;#123;product-module-name&amp;#125;-Bridging-Header.h&lt;/code&gt; 即 &lt;code&gt;target名称-Bridging-Header.h&lt;/code&gt; 文件，并在这个文件中添加你想要引用的头文件即可。为求方便， Xcode 还会在向项目中第一次添加 Objective-C 文件时候提示是否需要自动添加这个文件。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://ufolux.github.io/categories/Swift/"/>
    
    
      <category term="学习" scheme="https://ufolux.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习笔记-结构体，类和协议</title>
    <link href="https://ufolux.github.io/2015/12/17/Swift/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB/"/>
    <id>https://ufolux.github.io/2015/12/17/Swift/Swift学习笔记-结构体和类/</id>
    <published>2015-12-17T05:06:46.000Z</published>
    <updated>2021-03-11T07:20:00.109Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="class-和-struct"><a href="#class-和-struct" class="headerlink" title="class 和 struct"></a>class 和 struct</h2><p>Swift 中的类和结构体很相像，他们共有了很多功能。最大的区别在于 struct 是值类型而 class 是引用类型。</p><span id="more"></span><h3 id="class-和-struct-都能做的："><a href="#class-和-struct-都能做的：" class="headerlink" title="class 和 struct 都能做的："></a>class 和 struct 都能做的：</h3><ul><li>可以拥有属性来存储数据。</li><li>可以定义方法。</li><li>可以使用下标来访问内容。</li><li>可以使用构造器来初始化。</li><li>可以被扩展。</li><li>可以遵守协议。</li></ul><h3 id="class-能做但-strcut-不能做的："><a href="#class-能做但-strcut-不能做的：" class="headerlink" title="class 能做但 strcut 不能做的："></a>class 能做但 strcut 不能做的：</h3><ul><li>可以使用析构器来释放持有的资源。</li><li>可以继承自其他类。</li><li>可以在运行时得知类实例的类型。</li><li>类实例可以被多次引用。</li></ul><p>所有的 class 实例都是引用类型数据而 struct 实例是值类型数据，也就是说 struct 实例在传递时会被复制。</p><p>struct（或 enum，protocol） 中的类型作用域方法／属性 需要使用 static 来声明，对应的 class 中使用 class 来声明。目前 class 中不允许类作用域的存储属性，如果要在 class 中使用类型作用域的存储属性，可以使用 static 来解决。</p><h2 id="protocol"><a href="#protocol" class="headerlink" title="protocol"></a>protocol</h2><p>Swift 中的协议相比 Objective-C 中的协议更加的强大。Swift 2.1 之后，由于协议扩展（protocol extension）的出现使得 Protocol 更像是一个类头文件一样的存在。程序猿们可以利用面向协议编程来大展身手。苹果甚至建议，在可能的情况下尽量使用协议来替代类。具体的说明详见我的<a href="http://skyfly.xyz/2015/10/27/Translation/iOS%209%20Tutorial%20Series-%20Protocol-Oriented%20Programming%20with%20UIKit/">另一篇文章</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;class-和-struct&quot;&gt;&lt;a href=&quot;#class-和-struct&quot; class=&quot;headerlink&quot; title=&quot;class 和 struct&quot;&gt;&lt;/a&gt;class 和 struct&lt;/h2&gt;&lt;p&gt;Swift 中的类和结构体很相像，他们共有了很多功能。最大的区别在于 struct 是值类型而 class 是引用类型。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://ufolux.github.io/categories/Swift/"/>
    
    
      <category term="学习" scheme="https://ufolux.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>[转]NSDictionary的setValue:forKey与setObject:forKey、objectForKey与valueForKey的差异</title>
    <link href="https://ufolux.github.io/2015/12/11/iOS/iOS%E6%9C%AD%E8%AE%B0/NSDictionary%E7%9A%84setValue-forKey%E4%B8%8EsetObject-forKey%E3%80%81objectForKey%E4%B8%8EvalueForKey%E7%9A%84%E5%B7%AE%E5%BC%82/"/>
    <id>https://ufolux.github.io/2015/12/11/iOS/iOS札记/NSDictionary的setValue-forKey与setObject-forKey、objectForKey与valueForKey的差异/</id>
    <published>2015-12-11T15:53:21.000Z</published>
    <updated>2021-03-11T07:20:00.113Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>setValue:forKey与setObject:forKey的差异<br>在使用NSMutableDictionary的时候经常会使用setValue forKey与setObject forKey，他们经常是可以交互使用的，代码中经常每一种的使用都有。</p><span id="more"></span><p>1,先看看setValue： forKey：的定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface NSMutableDictionary(NSKeyValueCoding)</span><br><span class="line">&#x2F;* Send -setObject:forKey: to the receiver, unless the value is nil, in which case send -removeObject:forKey:.</span><br><span class="line">*&#x2F;</span><br><span class="line">- (void)setValue:(id)value forKey:(NSString *)key;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>扩展NSMutableDictionary的一个类别，上面注释说的很清楚，发送setObject:forKey 给接收者，也就是调用setObject:forKey方法<br>除非value为nil的时候，调用方法removeObject:forKey</p><p>2,看看setObject：forKey：的定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface NSMutableDictionary :NSDictionary</span><br><span class="line">- (void)removeObjectForKey:(id)aKey;</span><br><span class="line">- (void)setObject:(id)anObject forKey:(id &lt;NSCopying&gt;)aKey;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>注意：setObject：forKey：中Key的对象是一个id类型，并不是NSString，只不过我们经常使用NSString而已。</p><p>现在总结他们2者的区别就是：<br>1, setObject：forkey：中value是<strong>不能</strong>够为nil的，不然会报错。<br>setValue：forKey：中value能够为nil，但是当value为nil的时候，会<strong>自动调用</strong>removeObject：forKey方法<br>2, setValue：forKey：中key的参数<strong>只能够是*</strong>NSString类型，而setObject：forKey：的可以是<strong>任何类型</strong></p><p>注意：setObject：forKey：对象不能存放nil要与下面的这种情况区分：<br>1, [imageDictionarysetObject:[NSNullnull] forKey:indexNumber];<br><code>[NSNull null]表示的是一个空对象，并不是nil</code>，注意这点</p><p>2, setObject：forKey：中Key是NSNumber对象的时候，如下：<br>    <code>[imageDictionarysetObject:obj forKey:[NSNumber numberWithInt：10]];</code></p><p>注意：<br>上面说的区别是针对调用者是dictionary而言的。<br>setObject:forKey:方法NSMutabledictionary特有的,而<br>setValue:forKey:方法是KVC（键-值编码）的主要方法。</p><p>当 setValue:forKey:方法调用者是对象的时候：<br>setValue:forKey:方法是在NSObject对象中创建的，也就是说所有的oc对象都有这个方法，所以可以用于任何类。<br>比如使用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SomeClass *someObj &#x3D; [[SomeClass alloc] init];</span><br><span class="line">[someObj setValue:self forKey:@&quot;delegate&quot;];</span><br></pre></td></tr></table></figure><p>表示的意思是：对象someObj设置他的delegate属性的值为当前类，当然调用此方法的对象必须要有delegate属性才能设置，不然调用了也没效果</p><p>objectForKey与valueForKey的差异<br>从 NSDictionary 取值的时候有两个方法，objectForKey: 和 valueForKey:，这两个方法具体有什么不同呢？ </p><p>先从 NSDictionary 文档中来看这两个方法的定义： </p><p>objectForKey: returns the value associated with aKey, or nil if no value is associated with aKey. 返回指定 key 的 value，若没有这个 key 返回 nil. </p><p>valueForKey: returns the value associated with a given key. 同样是返回指定 key 的 value。 </p><p>直观上看这两个方法好像没有什么区别，但文档里 valueForKey: 有额外一点： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">If key does not start with “@”, invokes objectForKey:. If key does start </span><br><span class="line">with “@”, strips the “@” and invokes [super valueForKey:] with the rest </span><br><span class="line">of the key. via Discussion </span><br></pre></td></tr></table></figure><p>一般来说 key 可以是任意字符串组合，如果 key 不是以 @ 符号开头，这时候 valueForKey: 等同于 objectForKey:，如果是以 @ 开头，去掉 key 里的 @ 然后用剩下部分作为 key 执行 [super valueForKey:]。 </p><p>比如： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *dict &#x3D; [NSDictionary dictionaryWithObject:@&quot;theValue&quot; </span><br><span class="line"></span><br><span class="line">forKey:@&quot;theKey&quot;]; </span><br><span class="line"></span><br><span class="line">NSString *value1 &#x3D; [dict objectForKey:@&quot;theKey&quot;]; </span><br><span class="line"></span><br><span class="line">NSString *value2 &#x3D; [dict valueForKey:@&quot;theKey&quot;]; </span><br></pre></td></tr></table></figure><p>这时候 value1 和 value2 是一样的结果。如果是这样一个 dict： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *dict &#x3D; [NSDictionary dictionaryWithObject:@&quot;theValue&quot; </span><br><span class="line"></span><br><span class="line">forKey:@&quot;@theKey&quot;];&#x2F;&#x2F; 注意这个 key 是以 @ 开头 </span><br><span class="line"></span><br><span class="line">NSString *value1 &#x3D; [dict objectForKey:@&quot;@theKey&quot;]; </span><br><span class="line"></span><br><span class="line">NSString *value2 &#x3D; [dict valueForKey:@&quot;@theKey&quot;]; </span><br></pre></td></tr></table></figure><p>value1 可以正确取值，但是 value2 取值会直接 crash 掉，报错信息： </p><p>Terminating app due to uncaught exception ‘NSUnknownKeyException’, reason: ‘[&lt;__NSCFDictionary 0x892fd80&gt; valueForUndefinedKey:]: this class is not key value coding-compliant for the key theKey.’ </p><p>这是因为 valueForKey: 是 KVC(NSKeyValueCoding) 的方法，在 KVC 里可以通过 property 同名字符串来获取对应的值。比如： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject </span><br><span class="line"></span><br><span class="line">@property (nonatomic, retain) NSString *name; </span><br><span class="line"></span><br><span class="line">@end </span><br><span class="line"></span><br><span class="line">... </span><br><span class="line"></span><br><span class="line">Person *person &#x3D; [[Person alloc] init]; </span><br><span class="line"></span><br><span class="line">person.name &#x3D; @&quot;fannheyward&quot;; </span><br><span class="line"></span><br><span class="line">NSLog(@&quot;name:%@&quot;, [person name]); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;name:fannheyward </span><br><span class="line"></span><br><span class="line">NSLog(@&quot;name:%@&quot;, [person valueForKey:@&quot;name&quot;]); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;name:fannheyward </span><br><span class="line"></span><br><span class="line">[person release]; </span><br></pre></td></tr></table></figure><p>valueForKey: 取值是找和指定 key 同名的 property accessor，没有的时候执行 valueForUndefinedKey:，而 valueForUndefinedKey: 的默认实现是抛出 NSUndefinedKeyException 异常。 </p><p>回过头来看刚才 crash 的例子， <code>[dict valueForKey:@&quot;@theKey&quot;];</code> <strong>会把 key 里的 <code>@</code> 去掉</strong>，也就变成了 <code>[dict valueForKey:@&quot;theKey&quot;];</code>，而 dict 不存在 theKey 这样的 property，转而执行 <code>[dict valueForUndefinedKey:@&quot;theKey&quot;]</code>;，抛出 NSUndefinedKeyException 异常后 crash 掉。 </p><p>objectForKey: 和 valueForKey: 在多数情况下都是一样的结果返回，但是如果 key 是以 @ 开头，valueForKey: 就成了一个大坑，建议在 NSDictionary 下只用 objectForKey: 来取值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;setValue:forKey与setObject:forKey的差异&lt;br&gt;在使用NSMutableDictionary的时候经常会使用setValue forKey与setObject forKey，他们经常是可以交互使用的，代码中经常每一种的使用都有。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://ufolux.github.io/categories/iOS/"/>
    
    
      <category term="札记" scheme="https://ufolux.github.io/tags/%E6%9C%AD%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>在Linux平台上配置Swift开发环境</title>
    <link href="https://ufolux.github.io/2015/12/09/Swift/%E5%9C%A8Linux%E5%B9%B3%E5%8F%B0%E4%B8%8A%E9%85%8D%E7%BD%AESwift%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>https://ufolux.github.io/2015/12/09/Swift/在Linux平台上配置Swift开发环境/</id>
    <published>2015-12-09T12:12:44.000Z</published>
    <updated>2021-03-11T07:20:00.109Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>2015年12月4日，苹果正式开放了 Swift 的源代码，Swift 也从此开启了走向了各个平台的征程。苹果首先对 Linux 提供了支持，至于 Windows 嘛…<br><code>(对于Windows平台的支持）在Swift开源的初版中，这并不是我们所首要考虑的问题--费德里希</code><br>反正这件事自然有人会去做的。这篇文章对在 Ubuntu 上部署 Swift 开发环境进行描述（实际上就是翻译啦）。</p><p>本文原文:<a href="https://swift.org/download/#linux">https://swift.org/download/#linux</a></p><span id="more"></span><h2 id="在-Linux-平台上配置-Swift-开发环境"><a href="#在-Linux-平台上配置-Swift-开发环境" class="headerlink" title="在 Linux 平台上配置 Swift 开发环境"></a>在 Linux 平台上配置 Swift 开发环境</h2><p>这份面向 Linux 的开发包以 <code>tar</code> 包的形式提供给公众，里面含有一个 Swift 编译器的副本，lldb 和一些相关的工具。你可以在任何可以解压这个包的地方安装它们。</p><p><strong>请注意</strong>：并没有任何东西阻碍 Swift 被部署到除下面提到的其他 Linux 发行版本上。我们只是在这里提到的几个版本上构建并测试了这些程序。</p><h3 id="你需要（以下只是通过测试的环境，并不局限于这几个-Linux-发行版本）"><a href="#你需要（以下只是通过测试的环境，并不局限于这几个-Linux-发行版本）" class="headerlink" title="你需要（以下只是通过测试的环境，并不局限于这几个 Linux 发行版本）"></a>你需要（以下只是通过测试的环境，并不局限于这几个 Linux 发行版本）</h3><ul><li>Ubuntu 14.04 或者 15.10（64位）</li></ul><h3 id="支持的目标平台"><a href="#支持的目标平台" class="headerlink" title="支持的目标平台"></a>支持的目标平台</h3><ul><li>Ubuntu 14.04 或者 15.10（64位）</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li>安装所需的依赖：</li></ol><p><code>$ sudo apt-get install clang libicu-dev</code></p><ol start="2"><li>下载对应平台的 <code>tar</code> 包，地址如下：</li></ol><table><thead><tr><th align="left">Platform</th><th align="left">Download</th><th align="left">Date</th></tr></thead><tbody><tr><td align="left">Linux</td><td align="left"><a href="https://swift.org/builds/ubuntu1510/swift-2.2-SNAPSHOT-2015-12-01-b/swift-2.2-SNAPSHOT-2015-12-01-b-ubuntu15.10.tar.gz">Ubuntu 15.10 Swift 2.2 Snapshot</a><a href="https://swift.org/builds/ubuntu1510/swift-2.2-SNAPSHOT-2015-12-01-b/swift-2.2-SNAPSHOT-2015-12-01-b-ubuntu15.10.tar.gz.sig">(Signature)</a></td><td align="left">December 1, 2015</td></tr><tr><td align="left">Linux</td><td align="left"><a href="https://swift.org/builds/ubuntu1404/swift-2.2-SNAPSHOT-2015-12-01-b/swift-2.2-SNAPSHOT-2015-12-01-b-ubuntu14.04.tar.gz">Ubuntu 14.04 Swift 2.2 Snapshot</a><a href="https://swift.org/builds/ubuntu1404/swift-2.2-SNAPSHOT-2015-12-01-b/swift-2.2-SNAPSHOT-2015-12-01-b-ubuntu14.04.tar.gz.sig">(Signature)</a></td><td align="left">December 1, 2015</td></tr></tbody></table><p>表格中 <code>swift-&lt;VERSION&gt;-&lt;PLATFORM&gt;.tar.gz</code> 文件是工具链自身。<code>.sig</code> 文件是 tar 包对应的数字签名。</p><p>If you are downloading Swift packages for the first time, import the PGP keys into your keyring:</p><p>如果你是第一次下载 Swift 包，使用如下方法在你的钥匙串中引入 PGP keys 来验证 PGP 签名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gpg --keyserver hkp:&#x2F;&#x2F;pool.sks-keyservers.net \ </span><br><span class="line">--recv-keys \ </span><br><span class="line">&#39;7463 A81A 4B2E EA1B 551F FBCF D441 C977 412B 37AD&#39; \ </span><br><span class="line">&#39;1BE1 E29A 084C B305 F397 D62A 9F59 7F4D 21A5 6D5F&#39;</span><br></pre></td></tr></table></figure><p>或者:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget -q -O - https:&#x2F;&#x2F;swift.org&#x2F;keys&#x2F;all-keys.asc | gpg --import - </span><br><span class="line">Skip this step if you have imported the keys in the past.</span><br></pre></td></tr></table></figure><p>这些 Linux 平台的 .tar.gz 包使用 GnuPG 签名，密钥包含在在 Swift 开源项目中。我们强烈建议所有使用这个包的人都应该验证数字签名。</p><p>首先，刷新密钥来下载新的密钥撤销证书（key revocation certificates）如果有的话。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gpg --keyserver hkp:&#x2F;&#x2F;pool.sks-keyservers.net --refresh-keys Swift </span><br><span class="line">Then, use the signature file to verify that the archive is intact:</span><br><span class="line"></span><br><span class="line">$ gpg --verify swift-&lt;VERSION&gt;-&lt;PLATFORM&gt;.tar.gz.sig ... gpg: Good signature from &quot;Swift Automatic Signing Key #1 &lt;swift-infrastructure@swift.org&gt;&quot; </span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2015年12月4日，苹果正式开放了 Swift 的源代码，Swift 也从此开启了走向了各个平台的征程。苹果首先对 Linux 提供了支持，至于 Windows 嘛…&lt;br&gt;&lt;code&gt;(对于Windows平台的支持）在Swift开源的初版中，这并不是我们所首要考虑的问题--费德里希&lt;/code&gt;&lt;br&gt;反正这件事自然有人会去做的。这篇文章对在 Ubuntu 上部署 Swift 开发环境进行描述（实际上就是翻译啦）。&lt;/p&gt;
&lt;p&gt;本文原文:&lt;a href=&quot;https://swift.org/download/#linux&quot;&gt;https://swift.org/download/#linux&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://ufolux.github.io/categories/Swift/"/>
    
    
      <category term="学习" scheme="https://ufolux.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>快速ssh连接</title>
    <link href="https://ufolux.github.io/2015/12/05/Server/fastSshConnect/"/>
    <id>https://ufolux.github.io/2015/12/05/Server/fastSshConnect/</id>
    <published>2015-12-04T16:24:55.000Z</published>
    <updated>2021-03-11T07:20:00.108Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="本文是一篇快速指南："><a href="#本文是一篇快速指南：" class="headerlink" title="本文是一篇快速指南："></a>本文是一篇快速指南：</h1><h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><p>打开终端在客户机上生成公钥和私钥：</p><p><code>ssh-keygen -t rsa -C &#123;comment_text&#125; -f &#123;my-key-file&#125;</code></p><p>你将会得到两个文件分别是私钥 <code>my-key-file</code> 和公钥 <code>my-key-file.pub</code> </p><h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><p>将公钥上传到你需要访问的服务器上，建议使用 <code>scp</code> 命令：</p><p><code>scp &#123;my-key-file&#125;.pub -P &#123;端口号&#125; &#123;username&#125;@&#123;ip_address&#125;:.</code></p><h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><p>使用密码登陆你的服务器，然后在 <code>~/</code> 下执行:</p><p><code>cat my-key-file &gt;&gt; ~/.ssh/authorized_keys</code></p><h2 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h2><p>退出连接回到本地终端，回到生成公钥私钥的目录下面执行</p><p><code>cp my-key-file ~/.ssh/</code></p><p>将私钥复制到 <code>~/.ssh/</code> 目录下面。</p><h2 id="0x05"><a href="#0x05" class="headerlink" title="0x05"></a>0x05</h2><p>执行 <code>vim ~/.ssh/config</code> 编辑配置文件，以下是个例子，仅供参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host alias-name</span><br><span class="line">User username</span><br><span class="line">HostName ip or domainname</span><br><span class="line">Port port number</span><br><span class="line">IdentityFile ~&#x2F;.ssh&#x2F;my-key-file</span><br></pre></td></tr></table></figure><p>修改后保存。这是还需要一步，就是清除掉之前登陆留下的密钥缓存，之后才可以确保正常登录。<br>执行 <code>vim ~/.ssh/known_hosts</code> 查找 Hostname 对应的记录，将其删除保存文件即可。</p><h2 id="0x06"><a href="#0x06" class="headerlink" title="0x06"></a>0x06</h2><p>这时就可以执行无密码登录了 <code>ssh alias-name</code>，爽爽哒。</p><h2 id="0x07"><a href="#0x07" class="headerlink" title="0x07"></a>0x07</h2><p>可能会遇到配置完成之后连接服务器依然需要输入密码的情况，这一般是由于 .ssh，公钥文件的权限问题导致的，可以按照<a href="https://blog.csdn.net/lisongjia123/article/details/78513244">这个文章</a>中的解决方案进行处理。</p><h1 id="0x08"><a href="#0x08" class="headerlink" title="0x08"></a>0x08</h1><p>ssh 会话默认情况下很快就会过期，这在使用中很不方便，不过不要紧，这同样有<a href="https://15tar.com/linux/2017/07/31/ssh-session-timeout.html">解决办法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Server" scheme="https://ufolux.github.io/categories/Server/"/>
    
    
      <category term="ssh" scheme="https://ufolux.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>iOS经典面试题</title>
    <link href="https://ufolux.github.io/2015/11/09/Campus/iOS%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://ufolux.github.io/2015/11/09/Campus/iOS经典面试题/</id>
    <published>2015-11-09T08:14:29.000Z</published>
    <updated>2021-03-11T07:20:00.079Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="ObjectiveC-questions"><a href="#ObjectiveC-questions" class="headerlink" title="ObjectiveC questions"></a>ObjectiveC questions</h2><p>1.What is category? Can you have properties or ivars in a category?</p><p>可以，但不能在非匿名类别中使用实例变量。非匿名类别中的属性不会被合成setter/getter方法。需要使用关联对象来解决。</p><p>2.What is protocol? What is formal and informal protocol?</p><p>协议是一种用于实现多态的机制，遵守协议意味着协议中规定的必须方法需要被实现。是对象能力的一种保证。调用方只要知道被调用放遵守了协议即可，无需知道被调用方是什么类型。<br>正式协议是使用 <code>protocol</code> 关键字实现的，非正式协议即NSObject类别。</p><p>3.What is ARC? Is it garbage collection?</p><p>ARC 是自动引用计数，不是垃圾收集。实质上 ARC 还是一种手动的内存管理机制。对象是否释放需要根据引用计数是否为0来判断。引用计数将对对象内存的管理集中在了对象内部。而malloc/free new/delete是在外部的。且release只会减少引用计数，并不会直接收回内存。垃圾收集是全自动的，内存完全由垃圾收集器进行管理。</p><p>4.Difference between atomic and nonatomic properties?</p><p>atomic保证了属性setter/getter方法操作的原子性（加锁），会带来一定的开销。但并不意味着线程安全。因为在当前线程第一次读取到属性的当前值，紧接着另一个线程对属性进行了修改，此时当前线程又读取该属性就会造成数据的不一致。<br>nonatomic是不保证原子性的，开销较少。</p><span id="more"></span><p>5.Difference between strong and retain?</p><p>没什么区别，表示强引用，就是说先释放旧的值，再赋值的同时对对象的引用计数加一。</p><p>6.What is unsafe_unretained? Difference between unsafe_unretained, assign and weak?</p><p><code>unsafe_unretain</code> 不会对对象的引用计数加一，对象被释放后也不会将对象置为 <code>nil</code>。</p><p><code>assign</code> 只会对基本类型使用，表示赋值语义，不会对引用计数加一。</p><p><code>weak</code> 表示弱引用，只能针对 <code>Objective-C</code> 对象使用，不会对引用计数加一，在对象被释放时，会自动将对象置为 <code>nil</code>。</p><p>7.What does a copy property do? Is it deep copy or shallow copy?</p><p><code>copy</code> 表示复制语义，在对属性进行复制操作时会将对象复制一份。对于不同类型的对象有着不同的拷贝方法。</p><p>对于<strong>非集合类型</strong>的<strong>不可变</strong>对象copy会进行指针复制（<strong>浅复制</strong>），对<strong>非集合类型</strong>的<strong>可变</strong>对象会进行内容复制（<strong>深复制</strong>），最终产生一个不可变类型的指针。所以，不可以对可变类型的属性使用 <code>copy</code> 修饰，将会导致可变类型属性丧失可变性，在试图对其进行修改时发生错误。</p><p>对于<strong>集合类型</strong>的不可变对象，copy会进行指针复制（<strong>浅复制</strong>）。对于<strong>集合类型</strong>的可变对象仍然只是进行<strong>浅复制</strong>只是产生了一个新的指向<strong>不可变</strong>集合对象的指针，集合对象中的元素并不会被复制（引用的还是原来集合中的对象）。</p><p>Does ObjectiveC have function overloading?</p><p>OC 不支持函数重载</p><p>8.What is messaging? How does the runtime handle message passing? What is message forwarding?</p><p>在 OC 中，调用对象的方法称为向对象发送消息，消息可以理解为是对象的方法。运行时使用objc_msgSend方法发送消息，先在对象的方法缓存中查找相关的方法，没有的话就回去对象的方法列表中去查找方法。找到后直接调用并且将方法缓存到方法缓存中。</p><p>如果对象不能处理消息，则需要启动<strong>动态方法决议</strong>机制，启动前先调用 <code>resolveInstanceMethod:</code> 进行<strong>动态方法解析</strong>。解析失败则进行动态方法决议，首先调用 <code>forwardTargetForSelector:</code> 并根据继承关系查询，如果没有处理，就调用 <code>methodSignatureForSelector:</code> 方法查询方法签名，并根据继承关系查询，如果在此处处理了，就会调用 <code>forwardInvocation:</code> 方法进行最后的处理。默认实现是抛出异常结束程序。</p><p>9.What is ‘id’?</p><p><code>id</code> 是一个动态的类型，可以表示 Objective-C 中的对象。包括 <code>NSObject</code> 和 <code>NSProxy</code> 本类或子类。</p><p>10.What is performSelector:withObject:? What if I have to performSelector:withObject: but pass 3-4 arguments to the method? (Hint: NSInvocationOperation)</p><p><code>performSelector:withObject:</code> 是运行时方法，可以通过 <code>selector</code> 来调用方法并且传递一个参数（其实就是根据字符串调用方法 @selector 不过是个 <code>char*</code>）。<br>使用 <code>NSInvocation</code> 对方法调用进行封装，可以传递任意数量的参数。</p><p>一种实现方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (id)performSelector:(SEL)aSelector withObjects:(NSArray *)objects &#123;</span><br><span class="line">    NSMethodSignature *signature &#x3D; [self methodSignatureForSelector:aSelector];</span><br><span class="line">    NSInvocation *invocation &#x3D; [NSInvocation invocationWithMethodSignature:signature];</span><br><span class="line">    [invocation setTarget:self];</span><br><span class="line">    [invocation setSelector:aSelector];</span><br><span class="line">    </span><br><span class="line">    NSUInteger i &#x3D; 1;</span><br><span class="line">    for (id object in objects) &#123;</span><br><span class="line">        [invocation setArgument:&amp;object atIndex:++i];</span><br><span class="line">    &#125;</span><br><span class="line">    [invocation invoke];</span><br><span class="line">    </span><br><span class="line">    if ([signature methodReturnLength]) &#123;</span><br><span class="line">        id data;</span><br><span class="line">        [invocation getReturnValue:&amp;data];</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NSInvocationQueue：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSInvocation* deleteInvocation &#x3D; [NSInvocation invocationWithMethodSignature:[self methodSignatureForSelector:@selector(deleteDataAtPath:)]];</span><br><span class="line">          [deleteInvocation setTarget:self];</span><br><span class="line">          [deleteInvocation setSelector:@selector(deleteDataAtPath:)];&#x2F;&#x2F;给NSInvocation对象添加对应的动作</span><br><span class="line">    &#x2F;&#x2F; &#x2F;&#x2F; self, _cmd, ... 参数索引必须是2以后</span><br><span class="line">          [deleteInvocation setArgument:&amp;cachePath atIndex:2];</span><br><span class="line">         &#x2F;&#x2F;用NSInvocation对象来初始化一个NSOperation的子类NSInvocationOperation对象</span><br><span class="line">          NSInvocationOperation *operation &#x3D; [[NSInvocationOperation alloc] initWithInvocation:invoction];</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F;初始化一个操作队列</span><br><span class="line">          NSOperationQueue* operationQueue&#x3D;[[NSOperationQueue alloc] init]；</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F;在操作队列中加入操作</span><br><span class="line">          [operationQueue addOperation:operation];</span><br></pre></td></tr></table></figure><p>11.What is delegate? Can delegates be retained?</p><p>代理是用来在将事情交给另外的对象来做的一种方法。代理对象必须是 weak 的，否则会造成循环引用。如果使用 retain，则要在使用过后进行释放。</p><p>12.What is retain cycle?</p><p>循环引用，不解释。。。</p><p>13.Does ObjectiveC have multiple inheritance? Why not? How to imitate multiple inheritance?</p><p>没有多重继承。会带来交叉继承的复杂性。而且容易造成超大对象。可以使用协议来模拟多重继承。</p><p>14.What is class extension? Why do we require them?</p><p>类的扩展就是写在类的实现文件中用于隐藏类的某些属性，方法声明并可以在里面添加实例变量的结构，下面是一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface TestObject ()</span><br><span class="line">&#123;</span><br><span class="line">int _number;</span><br><span class="line">&#125;  </span><br><span class="line">@property int extensionValue;  </span><br><span class="line">-(void)setExtensionName:(NSString*)name;  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>15.Who calls dealloc method? Can we implement dealloc in ARC? If yes, what is the need to do that?</p><p>在对象引用计数为0的时候，系统会在一个合适的时机去调用 <code>dealloc</code> 方法。<code>ARC</code> 中可以实现这个方法，如果程序中使用了 <code>CoreFundation</code> 或者 <code>CoreGraphic</code> 等不支持 <code>ARC</code> 的对象时，需要在这里释放内存。另一个情况是要在这里移除 <code>Notification</code> ，否则会造成意外的结果。</p><p>16.Can you write setter method for a retain property?</p><p><code>retain</code> 的属性，就是需要先释放旧值，然后赋新值，并且 <code>retain</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)setTest:(TestClass *)test</span><br><span class="line">&#123;</span><br><span class="line">    [_test release];</span><br><span class="line">    _test &#x3D; [test retain];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>17.Can you write a singleton class in ObjectiveC?</p><p>自己写吧。。。</p><p>18.What is GCD? What are advantages over NSThread?</p><p><code>GCD</code> 大中枢派发。<code>NSThread</code> 是对 <code>pthread</code> 的一个抽象，每个 <code>NSThread</code> 对象对应一个线程。<code>GCD</code> 相比 <code>NSThread</code> 提供了更加方便的block <code>API</code>，并且提供了更好的封装，不需要自己管理线程的生命周期、线程同步、加锁、睡眠以及唤醒等的复杂的东西。 </p><p>19.What is NSOperation and NSOperationQueue?</p><p><code>NSOperation</code> 是面向对象的多线程技术。相比 <code>GCD</code> 对线程的控制更为灵活，<code>NSOperationQueue</code> 是一个线程队列</p><p>20.How does dispatch_once manages to run only once?</p><p>通过一个静态的 <code>token</code> 来实现，没有发现 token 的时候就执行代码，发现 token 已经存在了就不去执行了。</p><p>21.What are blocks?</p><p>22.What are NSAutoreleasePool? When to use them?</p><p>23.Does a thread created using performSelectorInBackground:withObject: creates its own autorelease<br>pool?</p><p>24.ObjectiveC is dynamic language? True/False, explain.</p><p>是的，完全动态，全部的方法调用都是在运行时决定的，通过 runtime 也可以在运行时进行很多反射的操作。</p><p>25.An NSArray containing Employee model object which has properties like empId, salary, age, designation, rating etc. Write a function that,</p><p>Returns average salary</p><p>Returns minimum age</p><p>Returns maximum rating</p><p>这个考的是 <code>KVC</code> 集合运算符，使用 <code>valueForKeyPath:</code> 方法就可以直接得到了。</p><p><code>valueForKeyPath:@&quot;@max.salary&quot;</code></p><p><code>valueForKeyPath:@&quot;@min.age&quot;</code></p><p><code>valueForKeyPath:@&quot;@avg.rating&quot;</code></p><p>29.Purpose of this question is to know if candidate knows about collection operators: Key-Value Coding Programming Guide</p><h2 id="iOS-questions"><a href="#iOS-questions" class="headerlink" title="iOS questions"></a>iOS questions</h2><p>1.What is the output binary format? Explain .app structure.</p><p>2.What are the CPU architectures supported by iOS devices?</p><p>3.What iOS version onwards ARC can be used?</p><p>4.Can we support same application for iPhone3GS and iPhone5? Why not?</p><p>5.Can I write some C++ function in same .m file? Will it compile? If no, what changes should I do to compile it?</p><p>6.What are the types of iOS binaries you can create using XCode? (.app, .ipa, .a, .framework)</p><p>7.Can a static library (.a) contain resources like images, sound files etc?</p><p>8.What is bundle?</p><p>9.Explain application life cycle.</p><p>10.What is responder chain?</p><p>11.Tell me hierarchy of UIButton.</p><p>12.Why create a custom view?</p><p>13.Why UIControl is provided if we can create custom UIView?</p><p>14.What are lifecycle events of UIViewController?</p><p>15.Difference between viewDidLoad and viewDidAppear?</p><p>16.Is UIKit thread safe?</p><p>17.Why do we override drawRect: method?</p><p>18.What are layers?</p><p>19.What are various singleton instances provided by frameworks? (UIApplication, NSFileManager,<br>NSUserDefaults, etc.)</p><p>20.What is NSUserDefaults? What type of data can we store there?</p><p>21.How do you check if your code has memory leaks?</p><p>22.What does static analyser do?</p><p>23.What are different Instruments Xcode supports for app profiling?</p><p>24.Concepts of notification center, local and remote notifications.</p><p>25.Have you uploaded app on Appstore? What is the process?</p><p>26.Difference between Developer and Enterprise Developer accounts?</p><p>27.Common reasons for app rejection from Appstore review process?</p><p>28.UITableView cell reuse. How to get it working (w/ or w/o XIB)? How would you implement reuse on a<br>UIScrollView?</p><h2 id="Few-questions-on-CoreData-which-I-may-ask-in-an-interview-to-some-one-brave-enough-to-venture"><a href="#Few-questions-on-CoreData-which-I-may-ask-in-an-interview-to-some-one-brave-enough-to-venture" class="headerlink" title="Few questions on CoreData which I may ask in an interview to some one brave enough to venture :)"></a>Few questions on CoreData which I may ask in an interview to some one brave enough to venture :)</h2><p>How do you setup/initialise a core data stack in your application? Is this activity performed on main thread? If not, why?</p><p>What is NSPersistentStoreCoordinator? What duties does it perform?<br>What is NSPersistentStore? Is it thread safe?<br>What is NSManagedObjectContext? What are the different concurrency types? Explain them.<br>Different types of persistent stores? Which all types can we have on iOS?<br>Can my application have multiple models? (Yes)<br>In a single model, can I have few entities in one sqlite db file and remaining  in another sqlite db file? (Yes, Hint: configurations)<br>What are the different store migration options? When are they used? How do they work? What is mapping model?<br>Explain parent-child context setup. How does it work? What are the advantages?<br>What is difference between performBlock: and performBlockAndWait:?<br>Are the NSManagedObjectContext queues serial or concurrent?<br>Can you pass same core data objects between different threads and modify?<br>What performance issues can you face when using CoreData?<br>What is NSFetchedResultsController? How do you turn on content monitoring?<br>How to implement “load more” using NSFetchedResultsController? (Hint: Set fetch offset and fetch limit on the NSFetchRequest of the controller, change the request to fetch more results)<br>What are the different delete rules that a relationship can have? Which one takes ownership?<br>In NSFetchRequest can we fetch only a selective few attributes of an entity? How?<br>Can I have relationship between entities in separate stores (in case of configurations)? (No)<br>What are fetched properties? How do you create a fetched property?<br>What does $FETCH_SOURCE and $FETCHED_PROPERTY in the predicate mean?<br>Why do all model object attributes get marked with @dynamic and not synthesised? What does @dynamic mean?<br>When a NSFetchRequest fetches an entity object from store, does it fetch all of its data at once?</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ObjectiveC-questions&quot;&gt;&lt;a href=&quot;#ObjectiveC-questions&quot; class=&quot;headerlink&quot; title=&quot;ObjectiveC questions&quot;&gt;&lt;/a&gt;ObjectiveC questions&lt;/h2&gt;&lt;p&gt;1.What is category? Can you have properties or ivars in a category?&lt;/p&gt;
&lt;p&gt;可以，但不能在非匿名类别中使用实例变量。非匿名类别中的属性不会被合成setter/getter方法。需要使用关联对象来解决。&lt;/p&gt;
&lt;p&gt;2.What is protocol? What is formal and informal protocol?&lt;/p&gt;
&lt;p&gt;协议是一种用于实现多态的机制，遵守协议意味着协议中规定的必须方法需要被实现。是对象能力的一种保证。调用方只要知道被调用放遵守了协议即可，无需知道被调用方是什么类型。&lt;br&gt;正式协议是使用 &lt;code&gt;protocol&lt;/code&gt; 关键字实现的，非正式协议即NSObject类别。&lt;/p&gt;
&lt;p&gt;3.What is ARC? Is it garbage collection?&lt;/p&gt;
&lt;p&gt;ARC 是自动引用计数，不是垃圾收集。实质上 ARC 还是一种手动的内存管理机制。对象是否释放需要根据引用计数是否为0来判断。引用计数将对对象内存的管理集中在了对象内部。而malloc/free new/delete是在外部的。且release只会减少引用计数，并不会直接收回内存。垃圾收集是全自动的，内存完全由垃圾收集器进行管理。&lt;/p&gt;
&lt;p&gt;4.Difference between atomic and nonatomic properties?&lt;/p&gt;
&lt;p&gt;atomic保证了属性setter/getter方法操作的原子性（加锁），会带来一定的开销。但并不意味着线程安全。因为在当前线程第一次读取到属性的当前值，紧接着另一个线程对属性进行了修改，此时当前线程又读取该属性就会造成数据的不一致。&lt;br&gt;nonatomic是不保证原子性的，开销较少。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://ufolux.github.io/categories/iOS/"/>
    
    
      <category term="面试" scheme="https://ufolux.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>NSString的内存管理</title>
    <link href="https://ufolux.github.io/2015/11/08/iOS/NSString%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://ufolux.github.io/2015/11/08/iOS/NSString的内存管理/</id>
    <published>2015-11-08T06:29:18.000Z</published>
    <updated>2021-03-11T07:20:00.112Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在 Objective-C 的 Fondation 框架中 NSString 对象是很复杂的存在，各种方式创建以及不同长度的字符串都会影响 NSString 对象在内存中所处的位置。Objective-C 在运行时也对其做了很多优化。今天就来研究一下 NSString 这个复杂的对象。</p><span id="more"></span><p>构建一些测试代码：</p><p>为了观察 NSString 的内存管理情况，我选择关闭 ARC 使用 MRC 来进行测试。以观察其引用计数等状况。</p><p>先写一个 Log 宏。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define TLog(_var) (&#123; NSString *name &#x3D; @#_var; NSLog(@&quot;%@: %@ -&gt; %p : %@  %lu&quot;, name, [_var class], _var, _var, [_var retainCount]); &#125;)</span><br></pre></td></tr></table></figure><h2 id="NSString揭秘"><a href="#NSString揭秘" class="headerlink" title="NSString揭秘"></a>NSString揭秘</h2><p>测试代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">NSString *str1 &#x3D; @&quot;sa&quot;;</span><br><span class="line">TLog(str1);</span><br><span class="line">&#x2F;&#x2F;str1: __NSCFConstantString -&gt; 0x100001050 : sa  18446744073709551615</span><br><span class="line"></span><br><span class="line">NSString *str2 &#x3D; [NSString stringWithString:@&quot;sa&quot;];</span><br><span class="line">TLog(str2);</span><br><span class="line">&#x2F;&#x2F;str2: __NSCFConstantString -&gt; 0x100001050 : sa  18446744073709551615</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSString *str3 &#x3D; @&quot;1234567890&quot;;</span><br><span class="line">TLog(str3);</span><br><span class="line">&#x2F;&#x2F;str3: __NSCFConstantString -&gt; 0x100001110 : 1234567890  18446744073709551615</span><br><span class="line"></span><br><span class="line">NSString *str4 &#x3D; [NSString stringWithFormat:@&quot;sa&quot;];</span><br><span class="line">TLog(str4);</span><br><span class="line">&#x2F;&#x2F;str4: NSTaggedPointerString -&gt; 0x617325 : sa  18446744073709551615</span><br><span class="line"></span><br><span class="line">NSString *str5 &#x3D; [NSString stringWithFormat:@&quot;sa&quot;];</span><br><span class="line">TLog(str5);</span><br><span class="line">&#x2F;&#x2F;str5: NSTaggedPointerString -&gt; 0x617325 : sa  18446744073709551615</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSString *str6 &#x3D; [NSString stringWithFormat:@&quot;123456789&quot;];</span><br><span class="line">TLog(str6);</span><br><span class="line">&#x2F;&#x2F;str6: NSTaggedPointerString -&gt; 0x1ea1f72bb30ab195 : 123456789  18446744073709551615</span><br><span class="line"></span><br><span class="line">NSString *str7 &#x3D; [NSString stringWithFormat:@&quot;1234567890&quot;];</span><br><span class="line">TLog(str7);</span><br><span class="line">&#x2F;&#x2F;str7: __NSCFString -&gt; 0x100300800 : 1234567890  1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果是很复杂的，按照产生对象的isa大致可以分为三种情况：</p><ol><li>产生的对象是 __NSCFConstantString</li><li>产生的对象是 __NSCFString</li><li>产生的对象是 NSTaggedPointerString</li></ol><p>而且可以看到，在 MRC 下的引用计数也是不尽相同的：</p><table><thead><tr><th align="left">引用计数</th><th align="left">类型</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">__NSCFString</td></tr><tr><td align="left">18446744073709551615（2^64-1）</td><td align="left">NSTaggedPointerString, __NSCFConstantString</td></tr></tbody></table><p>这样的话就提出了几个疑问：</p><ul><li>三种类型分别是什么，有什么不同？</li><li>三种类型的字符串指针分别是在什么情况下产生的？</li><li>三种类型的字符串分别处于内存的那个区域？</li><li>引用计数为什么会是18446744073709551615？</li></ul><h3 id="三种类型分别是什么，分别是在什么情况下产生的，分别处于内存的那个区域？"><a href="#三种类型分别是什么，分别是在什么情况下产生的，分别处于内存的那个区域？" class="headerlink" title="三种类型分别是什么，分别是在什么情况下产生的，分别处于内存的那个区域？"></a>三种类型分别是什么，分别是在什么情况下产生的，分别处于内存的那个区域？</h3><h4 id="NSCFConstantString"><a href="#NSCFConstantString" class="headerlink" title="__NSCFConstantString"></a>__NSCFConstantString</h4><p>字符串常量，是一种<strong><code>编译时</code></strong>常量，它的 <code>retainCount</code> 值很大，是 <code>4294967295</code>，在控制台打印出的数值则是 <code>18446744073709551615==2^64-1</code>，测试证明，即便对其进行 <code>release</code> 操作，<code>retainCount</code> 也不会产生任何变化。是创建之后便是放不掉的对象。相同内容的 <code>__NSCFConstantString</code> 对象的地址相同，也就是说常量字符串对象是一种单例。</p><p>这种对象一般通过字面值 <code>@&quot;...&quot;</code>、<code>CFSTR(&quot;...&quot;)</code> 或者 <code>stringWithString:</code> 方法（需要说明的是，这个方法在 iOS6 SDK 中已经被称为<code>redundant</code>，使用这个方法会产生一条编译器警告。这个方法等同于字面值创建的方法）产生。</p><p>这种对象存储在字符串常量区。</p><h4 id="NSCFString"><a href="#NSCFString" class="headerlink" title="__NSCFString"></a>__NSCFString</h4><p>和 <code>__NSCFConstantString</code> 不同， <code>__NSCFString</code> 对象是在<strong><code>运行时</code></strong>创建的一种 <code>NSString</code> 子类，他并不是一种字符串常量。所以和其他的对象一样在被创建时获得了 <code>1</code> 的引用计数。</p><p>通过 <code>NSString</code> 的 <code>stringWithFormat</code> 等方法创建的 <code>NSString</code> 对象一般都是这种类型。</p><p>这种对象被存储在堆上。</p><h4 id="NSTaggedPointerString"><a href="#NSTaggedPointerString" class="headerlink" title="NSTaggedPointerString"></a>NSTaggedPointerString</h4><p>理解这个类型，需要明白什么是<code>标签指针</code>，这是苹果在 64 位环境下对 <code>NSString</code>,<code>NSNumber</code> 等对象做的一些优化。简单来讲可以理解为把指针指向的内容直接放在了指针变量的内存地址中，因为在 64 位环境下指针变量的大小达到了 8 位足以容纳一些长度较小的内容。于是使用了<code>标签指针</code>这种方式来优化数据的存储方式。从他的引用计数可以看出，这货也是一个释放不掉的单例常量对象。在<strong><code>运行时</code></strong>根据实际情况创建。</p><p>对于 <code>NSString</code> 对象来讲，当<strong>非字面值常量</strong>的<strong>数字，英文字母</strong>字符串的长度小于等于 <strong>9</strong> 的时候会自动成为 <code>NSTaggedPointerString</code> 类型，如果有中文或其他特殊符号（可能是非 ASCII 字符）存在的话则会直接成为 ）<code>__NSCFString</code> 类型。</p><p>这种对象被直接存储在指针的内容中，可以当作一种伪对象。</p><h3 id="0x01-引用计数为什么会是18446744073709551615？"><a href="#0x01-引用计数为什么会是18446744073709551615？" class="headerlink" title="0x01 引用计数为什么会是18446744073709551615？"></a>0x01 引用计数为什么会是18446744073709551615？</h3><p>这个值意味着<strong>无限的retainCount</strong>，这个对象是不能被释放的。<br>所有的 __NSCFConstantString对象的retainCount都是这个值，这就意味着 __NSCFConstantString不会被释放，使用第一种方法创建的NSString，如果值一样，无论写多少遍，都是同一个对象。而且这种对象可以直接用 == 来比较。</p><h2 id="分析NSString的-copy，retain，mutableCopy表现"><a href="#分析NSString的-copy，retain，mutableCopy表现" class="headerlink" title="分析NSString的 copy，retain，mutableCopy表现"></a>分析NSString的 copy，retain，mutableCopy表现</h2><p>测试代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">NSString *testOutput;</span><br><span class="line"></span><br><span class="line">NSString *str9 &#x3D; @&quot;as&quot;;</span><br><span class="line"></span><br><span class="line">TLog(str9);</span><br><span class="line">TLog(str9);</span><br><span class="line">[str9 retain];</span><br><span class="line">TLog(str9);</span><br><span class="line">NSString *str &#x3D; [str9 copy];</span><br><span class="line">TLog(str);</span><br><span class="line">TLog(str9);</span><br><span class="line">str &#x3D; [str9 mutableCopy];</span><br><span class="line">TLog(str);</span><br><span class="line">TLog(str9);</span><br><span class="line"></span><br><span class="line">NSString *str10 &#x3D; [NSString stringWithFormat:@&quot;as&quot;];</span><br><span class="line">TLog(str10);</span><br><span class="line">[str10 retain];</span><br><span class="line">TLog(str10);</span><br><span class="line">str &#x3D; [str10 copy];</span><br><span class="line">TLog(str);</span><br><span class="line">TLog(str10);</span><br><span class="line">str &#x3D; [str10 mutableCopy];</span><br><span class="line">TLog(str);</span><br><span class="line">TLog(str10);</span><br><span class="line"></span><br><span class="line">NSString *str11 &#x3D; [NSString stringWithFormat:@&quot;1234567890&quot;];</span><br><span class="line"></span><br><span class="line">TLog(str11);</span><br><span class="line">[str11 retain];</span><br><span class="line">TLog(str11);</span><br><span class="line">str &#x3D; [str11 copy];</span><br><span class="line">TLog(str);</span><br><span class="line">TLog(str11);</span><br><span class="line">str &#x3D;[str11 mutableCopy];</span><br><span class="line">TLog(str);</span><br><span class="line">TLog(str11);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实验证明：copy 会使原来的对象引用计数加一，并拷贝对象地址给新的指针。<br>mutableCopy 不会改变引用计数，会拷贝内容到堆上，生成一个 <code>__NSCFString</code> 对象，新对象的引用计数为1.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Objective-C 的 Fondation 框架中 NSString 对象是很复杂的存在，各种方式创建以及不同长度的字符串都会影响 NSString 对象在内存中所处的位置。Objective-C 在运行时也对其做了很多优化。今天就来研究一下 NSString 这个复杂的对象。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://ufolux.github.io/categories/iOS/"/>
    
    
      <category term="iOS核心编程" scheme="https://ufolux.github.io/tags/iOS%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C的消息转发过程</title>
    <link href="https://ufolux.github.io/2015/11/06/iOS/Objective-C%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E8%BF%87%E7%A8%8B/"/>
    <id>https://ufolux.github.io/2015/11/06/iOS/Objective-C的消息转发过程/</id>
    <published>2015-11-06T08:59:07.000Z</published>
    <updated>2021-03-11T07:20:00.112Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>实例</strong>方法（实例方法）消息转发的顺序如下：</p><p>1、检查忽略的Selector，比如当我们运行在有垃圾回收机制的环境中，将会忽略retain和release消息。</p><p>2、检查receiver是否为nil。不像其他语言，nil在objective-C中是完全合法的，并且这里有很多原因你也愿意这样，比如，至少我们省去了给一个对象发送消息前检查对象是否为空的操作。如果receiver为空，则会将 selector也设置为空，并且直接返回到消息调用的地方。如果对象非空，就继续下一步。</p><span id="more"></span><p>3、接下来会根据SEL到当前类中查找对应的IMP，首先会在cache中检索它，如果找到了就根据函数指针跳转到这个函数执行，否则进行下一步。</p><p>4、检索当前类对象中的方法表（method list），如果找到了，加入cache中，并且就跳转到这个函数之行，否则进行下一步。</p><p>5、从父类中寻找,直到根类：NSObject类。找到了就将方法加入对应类的cache表中，如果仍为找到，则要进入<strong>动态方法决议</strong>，也就是说，如果你在父类中实现了这个方法，也是不会开启动态方法决议机制的，动态方法决议机制是在程序中没有这个selector的情况下才运作的。</p><p>6.<strong>动态方法决议过程</strong></p><p>6.1.动态方法解析（resolveInstanceMethod:）,<strong>调用时机为当被调用的方法实现部分没有找到，而消息转发机制启动之前的这个中间时刻</strong>，这之后将会开启消息转发机制。</p><p>6.2.当动态方法解析发现无法找到方法之后，会启动消息转发机制。首先消息会发送到 本类的 <code>forwardingTargetForSelector:</code> 方法中，如果没有做任何处理默认情况下则是按照继承关系向父类直到根类转发消息。</p><p>6.3.如果直到根类仍未发现进行任何处理，则会调用 <code>methodSignatureForSelector:</code> 方法，如果没有实现则会按照继承关系向父类直到根类查询方法签名。</p><p>6.4.如果在 <code>methodSignatureForSelector:</code> 方法中进行了处理，则会调用 <code>forwardInvocation:</code> 方法进行最后的处理，该方法的默认实现是发送 <code>doesNotRecognizeSelector:</code> 消息，这个消息的默认实现是直接抛出异常，如果重写了 <code>forwardInvocation:</code> 方法对调用进行了处理，程序就可以继续运行。</p><p>对于类方法则会调用相应的 <code>resolveClassMethod:</code> 方法来进行动态方法解析，之后按照这个过程进行消息的转发。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;实例&lt;/strong&gt;方法（实例方法）消息转发的顺序如下：&lt;/p&gt;
&lt;p&gt;1、检查忽略的Selector，比如当我们运行在有垃圾回收机制的环境中，将会忽略retain和release消息。&lt;/p&gt;
&lt;p&gt;2、检查receiver是否为nil。不像其他语言，nil在objective-C中是完全合法的，并且这里有很多原因你也愿意这样，比如，至少我们省去了给一个对象发送消息前检查对象是否为空的操作。如果receiver为空，则会将 selector也设置为空，并且直接返回到消息调用的地方。如果对象非空，就继续下一步。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://ufolux.github.io/categories/iOS/"/>
    
    
      <category term="iOS核心编程" scheme="https://ufolux.github.io/tags/iOS%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>XcodeGhostS</title>
    <link href="https://ufolux.github.io/2015/11/04/Translation/XcodeGhostS/"/>
    <id>https://ufolux.github.io/2015/11/04/Translation/XcodeGhostS/</id>
    <published>2015-11-04T02:52:24.000Z</published>
    <updated>2021-03-11T07:20:00.110Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>XcodeGhost S: A New Breed Hits the US<br>November 03, 2015 | By Yong Kang , Zhaofeng Chen, Raymond Wei | Threat Research, Botnets<br>apple logo grey</p><p>Just over a month ago, iOS users were warned of the threat to their devices by the XcodeGhost malware. Apple quickly reacted, taking down infected apps from the App Store and releasing new security features to stop malicious activities. Through continuous monitoring of our customers’ networks, FireEye researchers have found that, despite the quick response, the threat of XcodeGhost has maintained persistence and been modified.</p><span id="more"></span><p>More specifically, we found that:</p><p>XcodeGhost has entered into U.S. enterprises and is a persistent security risk<br>Its botnet is still partially active<br>A variant we call XcodeGhost S reveals more advanced samples went undetected<br>After monitoring XcodeGhost related activity for four weeks, we observed 210 enterprises with XcodeGhost-infected applications running inside their networks, generating more than 28,000 attempts to connect to the XcodeGhost Command and Control (CnC) servers – which, while not under attacker control, are vulnerable to hijacking by threat actors. Figure 1 shows the top five countries XcodeGhost attempted to callback to during this time.</p><p>Figure 1. Top five countries XcodeGhost attempted to callback in a four-week span</p><p>The 210 enterprises we detected with XcodeGhost infections represent a wide range of industries. Figure 2 shows the top five industries affected by XcodeGhost, sorted by the percentage of callback attempts to the XcodeGhost CnC servers from inside their networks:</p><p>Figure 2: Top five industries affected based on callback attempts</p><p>Researchers have demonstrated how XcodeGhost CnC traffic can be hijacked to:</p><p>Distribute apps outside the App Store<br>Force browse to URL<br>Aggressively promote any app in the App Store by launching the download page directly<br>Pop-up phishing windows<br>Figure 3 shows the top 20 most active infected apps among 152 apps, based on data from our DTI cloud:</p><p>Figure 3: Top 20 infected apps</p><p>Although most vendors have already updated their apps on App Store, this chart indicates many users are actively using older, infected versions of various apps in the field. The version distribution varies among apps. For example, the most popular Apps 网易云音乐 and WeChat-infected versions are listed in Figure 4.</p><p>App Name</p><p>Version</p><p>Incident Count (in 3 weeks)</p><p>WeChat</p><p>6.2.5.19</p><p>2963</p><p>网易云音乐</p><p>Music 163</p><p>2.8.2</p><p>3084</p><p>2.8.3</p><p>2664</p><p>2.8.1</p><p>1227</p><p>Figure 4: Sample infected app versions</p><p>The infected iPhones are running iOS versions from 6.x.x to 9.x.x as illustrated by Figure 5. It is interesting to note that nearly 70% of the victims within our customer base remain on older iOS versions. We encourage them to update to the latest version iOS 9 as quickly as possible.</p><p>Figure 5: Distribution of iOS versions running infected apps</p><p>Some enterprises have taken steps to block the XcodeGhost DNS query within their network to cut off the communication between employees’ iPhones and the attackers’ CnC servers to protect them from being hijacked. However, until these employees update their devices and apps, they are still vulnerable to potential hijacking of the XcodeGhost CnC traffic – particularly when outside their corporate networks.</p><p>Given the number of infected devices detected within a short period among so many U.S enterprises, we believe that XcodeGhost continues to be an ongoing threat for enterprises.</p><p>XcodeGhost Modified to Exploit iOS 9</p><p>We have worked with Apple to have all XcodeGhost and XcodeGhost S (described below) samples we have detected removed from the App Store.</p><p>XcodeGhost is planted in different versions of Xcode, including Xcode 7 (released for iOS 9 development). In the latest version, which we call XcodeGhost S, features have been added to infect iOS 9 and bypass static detection.</p><p>According to [1], Apple introduced the “NSAppTransportSecurity” approach for iOS 9 to improve client-server connection security. By default, only secure connections (https with specific ciphers) are allowed on iOS 9. Due to this limitation, previous versions of XcodeGhost would fail to connect with the CnC server by using http. However, Apple also allows developers to add exceptions (“NSAllowsArbitraryLoads”) in the app’s Info.plist to allow http connection. As shown in Figure 6, the XcodeGhost S sample reads the setting of “NSAllowsArbitraryLoads” under the “NSAppTransportSecurity” entry in the app’s Info.plist and picks different CnC servers (http/https) based on this setting.</p><p>Figure 6: iOS 9 adoption in XcodeGhost S</p><p>Further, the CnC domain strings are concatenated character by character to bypass the static detection in XcodeGhost S, such behavior is shown in Figure 7.</p><p>Figure 7: Construct the CnC domain character by character</p><p>The FireEye iOS dynamic analysis platform has successfully detected an app  (“自由邦”)  [2] infected by XcodeGhost S and this app has been taken down from App Store in cooperation with Apple. It is a shopping app for travellers and is available on both U.S. and CN App Stores. As shown in Figure 8, the infected app’s version is 2.6.6, updated on Sep. 15.</p><p>Figure 8: An App Store app is infected with XcodeGhost S</p><p>Enterprise Protection</p><p>FireEye MTP has detected and assisted in Apple’s takedown of thousands of XcodeGhost-infected iOS applications. We advise all organizations to notify their employees of the threat of XcodeGhost and other malicious iOS apps. Employees should make sure that they update all apps to the latest version. For the apps Apple has removed, users should remove the apps and switch to other uninfected apps on App Store.</p><p>FireEye MTP management customers have full visibility into which mobile devices are infected in their deployment base. We recommend that customers immediately review MTP alerts, locate infected devices/users, and quarantine the devices until the infected apps are removed. FireEye NX customers are advised to immediately review alert logs for activities related to XcodeGhost communications.</p><p>[1] <a href="https://developer.apple.com/library/prerelease/ios/technotes/App-Transport-Security-Technote/">https://developer.apple.com/library/prerelease/ios/technotes/App-Transport-Security-Technote/</a><br>[2] <a href="https://itunes.apple.com/us/app/id915233927">https://itunes.apple.com/us/app/id915233927</a><br>[3] <a href="http://drops.wooyun.org/papers/9024">http://drops.wooyun.org/papers/9024</a><br>[4] <a href="https://itunes.apple.com/us/app/pdf-reader-annotate-scan-sign/id368377690?mt=8">https://itunes.apple.com/us/app/pdf-reader-annotate-scan-sign/id368377690?mt=8</a><br>[5] <a href="https://itunes.apple.com/us/app/winzip-leading-zip-unzip-cloud/id500637987?mt=8">https://itunes.apple.com/us/app/winzip-leading-zip-unzip-cloud/id500637987?mt=8</a><br>[6] <a href="https://itunes.apple.com/us/app/snaproll-use-as-snaps-on-snapchat/id741401966?mt=8">https://itunes.apple.com/us/app/snaproll-use-as-snaps-on-snapchat/id741401966?mt=8</a><br>[7] <a href="https://www.fireeye.com/blog/threat-research/2015/08/ios_masque_attackwe.html">https://www.fireeye.com/blog/threat-research/2015/08/ios_masque_attackwe.html</a><br>[8] <a href="https://www.fireeye.com/blog/threat-research/2015/02/ios_masque_attackre.html">https://www.fireeye.com/blog/threat-research/2015/02/ios_masque_attackre.html</a><br>[9] <a href="https://www.fireeye.com/blog/threat-research/2014/11/masque-attack-all-your-ios-apps-belong-to-us.html">https://www.fireeye.com/blog/threat-research/2014/11/masque-attack-all-your-ios-apps-belong-to-us.html</a><br>[10] <a href="https://www.fireeye.com/blog/threat-research/2015/06/three_new_masqueatt.html">https://www.fireeye.com/blog/threat-research/2015/06/three_new_masqueatt.html</a></p><p>This entry was posted on Tue Nov 03 07:27:00 EST 2015 and filed under Apple, Blog, Botnet, Botnets, Botnets, Latest Blog Posts, Raymond Wei, Threat Research, Yong Kang , Zhaofeng Chen and application security.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;XcodeGhost S: A New Breed Hits the US&lt;br&gt;November 03, 2015 | By Yong Kang , Zhaofeng Chen, Raymond Wei | Threat Research, Botnets&lt;br&gt;apple logo grey&lt;/p&gt;
&lt;p&gt;Just over a month ago, iOS users were warned of the threat to their devices by the XcodeGhost malware. Apple quickly reacted, taking down infected apps from the App Store and releasing new security features to stop malicious activities. Through continuous monitoring of our customers’ networks, FireEye researchers have found that, despite the quick response, the threat of XcodeGhost has maintained persistence and been modified.&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://ufolux.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>MVVM的优缺点</title>
    <link href="https://ufolux.github.io/2015/11/04/Translation/MVVM%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
    <id>https://ufolux.github.io/2015/11/04/Translation/MVVM的优缺点/</id>
    <published>2015-11-04T02:08:07.000Z</published>
    <updated>2021-03-11T07:20:00.110Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>作者：<a href="http://blogs.msdn.com/4026/ProfileUrlRedirect.ashx">JohnGossman</a> （MVVM 模式的创始人）</p><p>对于我们什么时候和为什么要使用 M-V-VM 与其它模式我思考了很多。<span id="more"></span>一个显然的目的就是在代码隐藏的层面对视图的抽象化，减少大量的业务逻辑或者节外生枝的胶水代码。所有好处都比较抽象，但这里有一个比较具体的优势：ViewModel 比​​代码隐藏或事件驱动的代码更容易进行单元测试。ViewModel，虽然它听起来更像是 View 而不像 Model，而且这意味着你可以方便地测试，而不用去理会麻烦的 UI 动画和交互。如果你曾经尝试过对 UI 代码进行单元测试，你就知道这会有多么困难。</p><p>那么它的缺点呢？对于简单的 UI 来讲，M-V-VM 是一种过度的设计。在复杂的情况下，很难预先设计出足够通用的 ViewModel。尽管数据绑定的神奇在于声明式，然而比起命令式的语法，他更难调试，即便你已经在代码中设置了断点（但如果你有很多事件在到处运行，那可能并不会有什么区别）。</p><p>数据绑定的性能十分好，但是他会趋向于创建大量的全局的本地数据。就这样运行一段时间，我们就给我们创建的每一个对象都添加了多个绑定。在构建 WPF 程序的时候我们使用了数据绑定，每个对象都几乎耗费了2k的内存…所以这说明用来实现绑定的逻辑比被绑定的对象本身要重得多。在这个例子中，我将全部的绑定替换为静态的回调方法，这一个做法差不多节省了 100MB 的内存…！</p><p>一般的 UI 不会创建这么多的绑定，但是性能是我们需要注意的问题。</p><p><a href="http://blogs.msdn.com/b/johngossman/archive/2006/03/04/543695.aspx">查看原文</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：&lt;a href=&quot;http://blogs.msdn.com/4026/ProfileUrlRedirect.ashx&quot;&gt;JohnGossman&lt;/a&gt; （MVVM 模式的创始人）&lt;/p&gt;
&lt;p&gt;对于我们什么时候和为什么要使用 M-V-VM 与其它模式我思考了很多。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://ufolux.github.io/categories/iOS/"/>
    
    
      <category term="iOS设计模式" scheme="https://ufolux.github.io/tags/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>切勿将内部测试版本随意发放测试</title>
    <link href="https://ufolux.github.io/2015/11/01/iOSSec/%E5%88%87%E5%8B%BF%E5%B0%86%E5%86%85%E9%83%A8%E6%B5%8B%E8%AF%95%E7%89%88%E6%9C%AC%E9%9A%8F%E6%84%8F%E5%8F%91%E6%94%BE%E6%B5%8B%E8%AF%95/"/>
    <id>https://ufolux.github.io/2015/11/01/iOSSec/切勿将内部测试版本随意发放测试/</id>
    <published>2015-11-01T14:14:13.000Z</published>
    <updated>2021-03-11T07:20:00.116Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="工作中发现的一些问题"><a href="#工作中发现的一些问题" class="headerlink" title="工作中发现的一些问题"></a>工作中发现的一些问题</h2><p>在一些公司中，为了测试的方便，经常会使用他们的企业证书去部署应用到测试设备上面。这样看似没什么问题，但是这里隐藏了一个安全问题。就是代码中的方法名和字符串经过反汇编都会一览无余地显示出来。</p><span id="more"></span><h2 id="一些实践"><a href="#一些实践" class="headerlink" title="一些实践"></a>一些实践</h2><h4 id="工具：Hopper"><a href="#工具：Hopper" class="headerlink" title="工具：Hopper"></a>工具：Hopper</h4><p>Hopper 是一个OSX平台下的反汇编程序，可以将二进制的可执行文件反汇编，查看程序中的方法，地址，字符串等，功能比较强大。</p><p>通过PP助手下载渠道包 .ipa 文件，解压缩之后进入 payload 目录下，将 .app 文件拖入 Hopper 中。之后一路默认选项。反汇编之后，我们在 String 的标签中可以看到一些乱码。这是由于在将 app 上传到 iTunes Connect 发布之后，苹果会对代码进行加密和混淆，使得字符串变成了一堆乱码，方法名称也全部变成了 c++ 标准库的代码。</p><p>经由企业证书打包部署渠道下载的 .ipa 文件，解压后发现，其文件结构和 AppStore 渠道下发的压缩包中目录结构明显不同。只有一个 payload 文件夹。再次将这个文件夹中的 .app 文件拖入 Hopper 中以默认选项进行反编译。结果发现，程序中的方法名称，字符串一览无余的以明文方式显示在 Hopper 中，包括 App 中用到的 AppKey ，AppSecret，token 以及众多的调试用信息都会显示出来。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>综上所述，如果企业渠道的内测版本文件被别有用心者获取之后，将会使重要的字段信息泄漏，从而导致请求被模拟或者身份被仿冒等安全问题的发生。</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>在测试中务必使用 Adhoc 证书进行小范围有限发布测试，并且注意一定要限制测试的范围，不可使别有用心的人获取到这些敏感信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;工作中发现的一些问题&quot;&gt;&lt;a href=&quot;#工作中发现的一些问题&quot; class=&quot;headerlink&quot; title=&quot;工作中发现的一些问题&quot;&gt;&lt;/a&gt;工作中发现的一些问题&lt;/h2&gt;&lt;p&gt;在一些公司中，为了测试的方便，经常会使用他们的企业证书去部署应用到测试设备上面。这样看似没什么问题，但是这里隐藏了一个安全问题。就是代码中的方法名和字符串经过反汇编都会一览无余地显示出来。&lt;/p&gt;
    
    </summary>
    
      <category term="安全" scheme="https://ufolux.github.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="iOS安全" scheme="https://ufolux.github.io/tags/iOS%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>iOS应用程序安全(20)-本地数据存储及其安全性（NSUserDefaults, CoreData, Sqlite, Plist 文件）</title>
    <link href="https://ufolux.github.io/2015/11/01/iOSSec/iOS%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%AE%89%E5%85%A8(20)-%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%8F%8A%E5%85%B6%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%88NSUserDefaults,%20CoreData,%20Sqlite,%20Plist%20%E6%96%87%E4%BB%B6%EF%BC%89/"/>
    <id>https://ufolux.github.io/2015/11/01/iOSSec/iOS应用程序安全(20)-本地数据存储及其安全性（NSUserDefaults, CoreData, Sqlite, Plist 文件）/</id>
    <published>2015-11-01T11:46:52.000Z</published>
    <updated>2021-03-11T07:20:00.116Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="作者：Prateek-Gianchandani"><a href="#作者：Prateek-Gianchandani" class="headerlink" title="作者：Prateek Gianchandani"></a>作者：Prateek Gianchandani</h4><h4 id="译者：吴发伟"><a href="#译者：吴发伟" class="headerlink" title="译者：吴发伟"></a>译者：吴发伟</h4><h4 id="原文网址"><a href="#原文网址" class="headerlink" title="原文网址"></a><a href="http://resources.infosecinstitute.com/ios-application-security-part-20-local-data-storage-nsuserdefaults-coredata-sqlite-plist-files/">原文网址</a></h4><h4 id="版权声明：自由转载-非商用-保持署名"><a href="#版权声明：自由转载-非商用-保持署名" class="headerlink" title="版权声明：自由转载-非商用-保持署名"></a>版权声明：自由转载-非商用-保持署名</h4><p>本文我们将看看应用在本地存储数据有哪些方法以及这些不同方法的安全性。<br>我们将会在一个demo上这些这些测试，你可以从我的<a href="https://github.com/prateek147/localDataStorageDemo">github账号</a>上下载这个例子程序。对于CoreData的例子，你可以从<a href="https://github.com/ChrisDrit/Core-Data-Example-Code">这</a>下载例子程序。本例有一个不同点就是我们将会在模拟器上运行这些应用，而不是在设备上运行。这样做的目的是为了证明在前面文章中的操作都可以通过Xcode来把这些应用运行在模拟器上。当然，你也可以把这应用安装到设备上。</p><span id="more"></span><h3 id="NSUserDefaults"><a href="#NSUserDefaults" class="headerlink" title="NSUserDefaults"></a>NSUserDefaults</h3><p>保存用户信息和属性的一个非常普通的方法就是使用NSUserDefaults。保存在NSUserDefaults中的信息在你的应用关闭后再次打开之后依然存在。保存信息到NSUserDefaults的一个例子就是保存用户是否已登录的状态。我们把用户的登录状态保存到NSUserDefaults以便用户关闭应用再次打开应用的时候，应用能够从NSUserDefaults获取数据，根据用户是否登录展示不同的界面。有些应用也用这个功能来保存机密数据，比如用户的访问令牌，以便下次应用登录的时候，它们能够使用这个令牌来再次认证用户。<br>从我的<a href="https://github.com/prateek147/localDataStorageDemo">github</a>可以下载例子应用，运行起来。你可以得到下面的界面，现在输入一些信息到与NSUserDefaults相关的文本框，然后点击下面的“Save in NSUserDefaults”。这样数据就保存到NSUserDefaults了。</p><p><img src="http://resources.infosecinstitute.com/wp-content/uploads/101613_1214_IOSApplicat1.png" alt></p><p>许多人不知道的是保存到NSUserDefaults的数据并没有加密，因此可以很容易的从应用的包中看到。NSUserDefaults被存在一个以应用的bundle id为名称的plist文件中。 首先，我们需要找到我们应用的bundle id。因为我们在模拟器上运行，我们可以在 <code>/Users/$username/Library/Application Support/iPhone Simulator/$ios version of simulator/Applications/</code> 找到应用。我这的路径是：<code>Users/prateekgianchandani/Library/Application Support/iPhone Simulator/6.1/Applications</code>。<br>一旦我们找到那个目录，我们可以看到一堆应用。我们可以用最近修改的日期找到我们的应用，因为它是最近修改的。</p><p><img src="http://resources.infosecinstitute.com/wp-content/uploads/101613_1214_IOSApplicat2.png" alt></p><p>进入到应用的bundle里面。通过 NSUserDefaults 保存的数据都可以在如下图所示的 <code>Library -&gt; Preferences -&gt; $AppBundleId.plist</code> 文件中找到。</p><p><img src="http://resources.infosecinstitute.com/wp-content/uploads/101613_1214_IOSApplicat3.png" alt></p><p>打开这个 plist 文件，我们可以清楚的看到这个文件的内容。</p><p><img src="http://resources.infosecinstitute.com/wp-content/uploads/101613_1214_IOSApplicat4.png" alt></p><p>有时候，plist 文件会以二进制格式保存，因此可能第一下看到会觉得不可读。你可以用 plutil 工具把它转成 xml 格式，或者直接用 iExplorer 在设备上查看。</p><h3 id="Plist-文件"><a href="#Plist-文件" class="headerlink" title="Plist 文件"></a>Plist 文件</h3><p>另一种保存数据普遍用的方法就是 plist 文件。Plist 文件应该始终被用来保存那些非机密的文件，因为它们没有加密，因此即使在非越狱的设备上也非常容易被获取。已经有漏洞被爆出来，大公司把机密数据比如访问令牌，用户名和密码保存到 plist 文件中。在下面的 demo 中，我们输入一些信息并保存到 plist 文件。</p><p><img src="http://resources.infosecinstitute.com/wp-content/uploads/101613_1214_IOSApplicat5.png" alt></p><p>下面是把数据保存到plist文件的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSArray *paths &#x3D; NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES)</span><br><span class="line">NSString *documentsDirectory &#x3D; [paths objectAtIndex:0];</span><br><span class="line">NSString *filePath &#x3D; [documentsDirectory stringByAppendingString:@&quot;&#x2F;userInfo.plist&quot;];</span><br><span class="line">NSMutableDictionary* plist &#x3D; [[NSMutableDictionary alloc] init];</span><br><span class="line">[plist setValue:self.usernameTextField.text forKey:@&quot;username&quot;];</span><br><span class="line">[plist setValue:self.passwordTextField.text forKey:@&quot;passwprd&quot;];</span><br><span class="line">[plist writeToFile:filePath atomically:YES];</span><br></pre></td></tr></table></figure><p>如你所见，我们能够给 plist 文件指定路径。我们可以搜索整个应用的所有plist文件。在这里，我们找到一个叫做 <code>userinfo.plist</code> 的文件。</p><p><img src="http://resources.infosecinstitute.com/wp-content/uploads/101613_1214_IOSApplicat6.png" alt></p><p>可以看到，它包含了我们刚刚输入的用户名/密码的组合。</p><p><img src="http://resources.infosecinstitute.com/wp-content/uploads/101613_1214_IOSApplicat7.png" alt></p><h3 id="CoreData和Sqlite文件"><a href="#CoreData和Sqlite文件" class="headerlink" title="CoreData和Sqlite文件"></a>CoreData和Sqlite文件</h3><p>因为 CoreData 内部使用 Sqlite 来保存信息，因此我们这里将只会介绍下 CoreData 。如果你不知道什么是 CoreData ，请查阅 Apple 官方文档</p><p>因此，基本上，CoreData 可以用来创建一个 model ，管理不同对象的关系，把数据保存到本地，然后当你查询的时候从本地缓存中获取它们。本例中，我们将使用一个 demo ，位于 <a href="https://github.com/ChrisDrit/Core-Data-Example-Code">github</a> 。运行起来，你会发现它只是一个简单的RSS feed。</p><p><img src="http://resources.infosecinstitute.com/wp-content/uploads/101613_1214_IOSApplicat10.png" alt></p><p>这个应用用CoreData保存数据。一个非常重要的一点就是CoreData内部使用sql，因此所有文件都以.db文件保存。我们到这个app的bundle中去看看。 在这个app的bundle中，你可以看到那里有一个MyCoreData.sqlite的文件。</p><p><img src="http://resources.infosecinstitute.com/wp-content/uploads/101613_1214_IOSApplicat11.png" alt></p><p>我们可以用sqlite3分析。我这slite文件的地址是：<code>~/Library/Application Support/iPhone Simulator/6.1/Applications/51038055-3CEC-4D90-98B8-A70BF12C7E9D/Documents</code>.</p><p><img src="http://resources.infosecinstitute.com/wp-content/uploads/101613_1214_IOSApplicat12.png" alt></p><p>我们可以看到，这里有个叫做ZSTORIES的表。在Core Data中，每个表名开头都会被追加一个Z。这意味着真正的实体名称是STORIES，如我们在工程的源码文件看到的那样。</p><p><img src="http://resources.infosecinstitute.com/wp-content/uploads/101613_1214_IOSApplicat13.png" alt></p><p>我们可以非常容易的导出这个表的所有值。请却表headers的状态是on。</p><p><img src="http://resources.infosecinstitute.com/wp-content/uploads/101613_1214_IOSApplicat14.png" alt></p><p>正如我们看到的那样，默认的，保存在CoreData的数据都是没有加密的，因此可以轻易的被取出。因此，我们不应该用CoreData保存机密数据。 有些库包装了一下CoreData, 声称能够保存加密数据。也有些库能够把数据加密保存到设备上，不过不使用CoreData。例如，Salesforce Mobile SDK 就使用了一个被称为SmartStore的功能来把加密数据以”Soups”的形式保存到设备上。</p><h3 id="Keychain"><a href="#Keychain" class="headerlink" title="Keychain"></a>Keychain</h3><p>有些开发者不太喜欢把数据保存到 Keychain 中，因为实现起来不那么直观。不过，把信息保存到 Keychain 中可能是非越狱设备上最安全的一种保存数据的方式了。而在越狱设备上，没有任何事情是安全的。这篇文章展示了使用一个简单的 wrapper 类，把数据保存到keychain是多么的简单。使用这个 wrapper 来保存数据到 keychain 就像把数据保存到 NSUserDefaults 那么简单。下面就是一段把字符串保存到 keychain 的代码。请注意和使用 NSUserDefaults 的语法非常类似。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PDKeychainBindings *bindings &#x3D; [PDKeychainBindings sharedKeychainBindings];</span><br><span class="line">[bindings setObject:@&quot;XYZ&quot; forKey:@&quot;authToken&quot;];</span><br></pre></td></tr></table></figure><p>下面是一段从keychain中取数据的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PDKeychainBindings *bindings &#x3D; [PDKeychainBindings sharedKeychainBindings];</span><br><span class="line">NSLog(@&quot;Auth token is %@&quot;,[bindings objectForKey:@&quot;authToken&quot;]]);</span><br></pre></td></tr></table></figure><h3 id="一些小技巧"><a href="#一些小技巧" class="headerlink" title="一些小技巧"></a>一些小技巧</h3><p>正如之前讨论过的那样，没有任何信息在越狱设备上是安全的。攻击者能够拿到Plist文件，导出整个keychain，替换方法实现，并且攻击者能做他想做的任何事情。不过开发者能够使用一些小技巧来使得脚本小子从应用获得信息变得更难。比如把文件加密放到本地设备上。这里<a href="http://highaltitudehacks.com/2013/09/17/ios-dev-storing-info-in-keychain-with-nsuserdefaults-like-syntax">这篇文章</a>详细的讨论了这一点。或者你可以使得攻击者更难理解你的信息。比如考虑要把某个用户的认证令牌（authentication token）保存到keychain当中，脚本小子可能就会导出keychain中的这个数据，然后试图劫持用户的会话。我们只需再把这个认证令牌字符串反转一下（reverse），然后再保存到keychain中，那么攻击者就不太可能会知道认证令牌是反转保存的。当然，攻击者可以追踪你的应用的每一个调用，然后理解到这一点，但是，一个如此简单的技术就能够让脚本小子猜足够的时间，以至于他们会开始寻找其它应用的漏洞。另一个简单技巧就是在每个真正的值保存之前都追加一个常量字符串。<br>在接下来的文章里，我们将讨论使用GDB进行运行时分析</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;作者：Prateek-Gianchandani&quot;&gt;&lt;a href=&quot;#作者：Prateek-Gianchandani&quot; class=&quot;headerlink&quot; title=&quot;作者：Prateek Gianchandani&quot;&gt;&lt;/a&gt;作者：Prateek Gianchandani&lt;/h4&gt;&lt;h4 id=&quot;译者：吴发伟&quot;&gt;&lt;a href=&quot;#译者：吴发伟&quot; class=&quot;headerlink&quot; title=&quot;译者：吴发伟&quot;&gt;&lt;/a&gt;译者：吴发伟&lt;/h4&gt;&lt;h4 id=&quot;原文网址&quot;&gt;&lt;a href=&quot;#原文网址&quot; class=&quot;headerlink&quot; title=&quot;原文网址&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://resources.infosecinstitute.com/ios-application-security-part-20-local-data-storage-nsuserdefaults-coredata-sqlite-plist-files/&quot;&gt;原文网址&lt;/a&gt;&lt;/h4&gt;&lt;h4 id=&quot;版权声明：自由转载-非商用-保持署名&quot;&gt;&lt;a href=&quot;#版权声明：自由转载-非商用-保持署名&quot; class=&quot;headerlink&quot; title=&quot;版权声明：自由转载-非商用-保持署名&quot;&gt;&lt;/a&gt;版权声明：自由转载-非商用-保持署名&lt;/h4&gt;&lt;p&gt;本文我们将看看应用在本地存储数据有哪些方法以及这些不同方法的安全性。&lt;br&gt;我们将会在一个demo上这些这些测试，你可以从我的&lt;a href=&quot;https://github.com/prateek147/localDataStorageDemo&quot;&gt;github账号&lt;/a&gt;上下载这个例子程序。对于CoreData的例子，你可以从&lt;a href=&quot;https://github.com/ChrisDrit/Core-Data-Example-Code&quot;&gt;这&lt;/a&gt;下载例子程序。本例有一个不同点就是我们将会在模拟器上运行这些应用，而不是在设备上运行。这样做的目的是为了证明在前面文章中的操作都可以通过Xcode来把这些应用运行在模拟器上。当然，你也可以把这应用安装到设备上。&lt;/p&gt;
    
    </summary>
    
      <category term="安全" scheme="https://ufolux.github.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="iOS安全" scheme="https://ufolux.github.io/tags/iOS%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习笔记－基本概念</title>
    <link href="https://ufolux.github.io/2015/10/31/Swift/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8D%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://ufolux.github.io/2015/10/31/Swift/Swift学习笔记－基本概念/</id>
    <published>2015-10-31T14:55:05.000Z</published>
    <updated>2021-03-11T07:20:00.109Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>总结一下学习 Swift 的一些要点，作为一个学习路线图。</p><span id="more"></span><p>结构体和类<br>1.结构体能做什么<br>2.类能做什么<br>3.两者之间有什么区别有什么联系</p><p>函数的类型<br>1.静态函数<br>2.实例函数</p><p>类型安全<br>1.类型的转换，是否允许显式转换，是否允许隐式转换<br>2.类型的兼容性（swift类型，ns类型）<br>3.类型安全的保证，拆包和强制拆包的规则<br>4.？！各有哪些作用</p><p>闭包<br>1.闭包的语法<br>2.闭包中变量的作用域和生命周期<br>3.闭包的内存模型</p><p>引用类型和值类型<br>1.两者的概念和区别<br>2.那些是引用类型，哪些是值类型<br>3.使用的方式</p><p>遵守协议和类的继承<br>1.如何继承类<br>2.如何遵守协议<br>####3.协议会被继承吗<br>是的，协议会被继承，需要重写父类中的协议方法，如果不重写就意味着提供了默认的实现</p><p>集合类型的拷贝<br>1.深拷贝，浅拷贝<br>2.字典的拷贝（键值是值类型，键值是引用类型）<br>3.数组的拷贝（元素是值类型，元素是引用类型）</p><p>常量与变量的区别<br>1.常量允许改变什么，不允许改变什么<br>2.变量允许改变什么，不允许改变什么</p><p>作用域标志<br>1.public private作用</p><p>扩展的作用</p><p>协议扩展（ Swift2.x ）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结一下学习 Swift 的一些要点，作为一个学习路线图。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://ufolux.github.io/categories/Swift/"/>
    
    
      <category term="学习" scheme="https://ufolux.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>HDOJ 1007</title>
    <link href="https://ufolux.github.io/2015/10/27/HDOJ/HDOJ1007/"/>
    <id>https://ufolux.github.io/2015/10/27/HDOJ/HDOJ1007/</id>
    <published>2015-10-27T15:42:08.000Z</published>
    <updated>2021-03-11T07:20:00.103Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1007">HDOJ1007 Quoit Design</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const double INF &#x3D; 1e20;</span><br><span class="line">const int N &#x3D; 100005;</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line">&#123;</span><br><span class="line">    double x;</span><br><span class="line">    double y;</span><br><span class="line">&#125;point[N];</span><br><span class="line">int n;</span><br><span class="line">int tmpt[N];</span><br><span class="line"></span><br><span class="line">bool cmpxy(const Point&amp; a, const Point&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    if(a.x !&#x3D; b.x)</span><br><span class="line">        return a.x &lt; b.x;</span><br><span class="line">    return a.y &lt; b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool cmpy(const int&amp; a, const int&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    return point[a].y &lt; point[b].y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double min(double a, double b)</span><br><span class="line">&#123;</span><br><span class="line">    return a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double dis(int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">    return sqrt((point[i].x-point[j].x)*(point[i].x-point[j].x)</span><br><span class="line">                + (point[i].y-point[j].y)*(point[i].y-point[j].y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double Closest_Pair(int left, int right)</span><br><span class="line">&#123;</span><br><span class="line">    double d &#x3D; INF;</span><br><span class="line">    if(left&#x3D;&#x3D;right)</span><br><span class="line">        return d;</span><br><span class="line">    if(left + 1 &#x3D;&#x3D; right)</span><br><span class="line">        return dis(left, right);</span><br><span class="line">    int mid &#x3D; (left+right)&gt;&gt;1;</span><br><span class="line">    double d1 &#x3D; Closest_Pair(left,mid);</span><br><span class="line">    double d2 &#x3D; Closest_Pair(mid+1,right);</span><br><span class="line">    d &#x3D; min(d1,d2);</span><br><span class="line">    int i,j,k&#x3D;0;</span><br><span class="line">    &#x2F;&#x2F;分离出宽度为d的区间</span><br><span class="line">    for(i &#x3D; left; i &lt;&#x3D; right; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(fabs(point[mid].x-point[i].x) &lt;&#x3D; d)</span><br><span class="line">            tmpt[k++] &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(tmpt,tmpt+k,cmpy);</span><br><span class="line">    &#x2F;&#x2F;线性扫描</span><br><span class="line">    for(i &#x3D; 0; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j &#x3D; i+1; j &lt; k &amp;&amp; point[tmpt[j]].y-point[tmpt[i]].y&lt;d; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            double d3 &#x3D; dis(tmpt[i],tmpt[j]);</span><br><span class="line">            if(d &gt; d3)</span><br><span class="line">                d &#x3D; d3;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    freopen(&quot;&#x2F;Users&#x2F;RichardLu&#x2F;Code&#x2F;C++&#x2F;Algorithm&#x2F;largeNumberSort&#x2F;largeNumberSort&#x2F;largeNumberSort&#x2F;testcase.in&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    freopen(&quot;&#x2F;Users&#x2F;RichardLu&#x2F;Code&#x2F;C++&#x2F;Algorithm&#x2F;largeNumberSort&#x2F;largeNumberSort&#x2F;largeNumberSort&#x2F;testcase.out&quot;, &quot;w&quot;, stdout);</span><br><span class="line">    </span><br><span class="line">    while(true)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        if(n&#x3D;&#x3D;0)</span><br><span class="line">            break;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">            scanf(&quot;%lf %lf&quot;,&amp;point[i].x,&amp;point[i].y);</span><br><span class="line">        sort(point,point+n,cmpxy);</span><br><span class="line">        printf(&quot;%.2lf\n&quot;,Closest_Pair(0,n-1)&#x2F;2);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(stdin);</span><br><span class="line">    fclose(stdout);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="OJ" scheme="https://ufolux.github.io/categories/OJ/"/>
    
    
  </entry>
  
  <entry>
    <title>ACMCoder 2009</title>
    <link href="https://ufolux.github.io/2015/10/27/HDOJ/ACMCoder%E6%95%B0%E5%88%97%E6%B1%82%E5%92%8C/"/>
    <id>https://ufolux.github.io/2015/10/27/HDOJ/ACMCoder数列求和/</id>
    <published>2015-10-27T15:42:07.000Z</published>
    <updated>2021-03-11T07:20:00.102Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://acm.acmcoder.com/showproblem.php?pid=2009">ACMCoder2009 数列求和</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    freopen(&quot;testcase.in&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    freopen(&quot;testcase.out&quot;, &quot;w&quot;, stdout);</span><br><span class="line">    double n,m;</span><br><span class="line">    while (cin&gt;&gt;n&gt;&gt;m&amp;&amp;n&gt;&#x3D;0&amp;&amp;m&gt;&#x3D;0) &#123;</span><br><span class="line">        m-&#x3D;1;</span><br><span class="line">        double sum &#x3D; n;</span><br><span class="line">        while (m--) &#123;</span><br><span class="line">            n &#x3D; sqrt((double)n);</span><br><span class="line">            sum +&#x3D; n;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(2)&lt;&lt;(double)sum&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(stdin);</span><br><span class="line">    fclose(stdout);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="OJ" scheme="https://ufolux.github.io/categories/OJ/"/>
    
    
  </entry>
  
  <entry>
    <title>ACM测试用例输入输出模版</title>
    <link href="https://ufolux.github.io/2015/10/27/HDOJ/ACM%E6%A8%A1%E7%89%88/"/>
    <id>https://ufolux.github.io/2015/10/27/HDOJ/ACM模版/</id>
    <published>2015-10-27T15:42:07.000Z</published>
    <updated>2021-03-11T07:20:00.103Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    freopen(&quot;testcase.in&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    freopen(&quot;testcase.out&quot;, &quot;w&quot;, stdout);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    fclose(stdin);</span><br><span class="line">    fclose(stdout);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="OJ" scheme="https://ufolux.github.io/categories/OJ/"/>
    
    
  </entry>
  
  <entry>
    <title>HDOJ 1002</title>
    <link href="https://ufolux.github.io/2015/10/27/HDOJ/HDOJ1002/"/>
    <id>https://ufolux.github.io/2015/10/27/HDOJ/HDOJ1002/</id>
    <published>2015-10-27T15:42:07.000Z</published>
    <updated>2021-03-11T07:20:00.103Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1002">HDOJ1002 A + B Problem II</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;  main.cpp</span><br><span class="line">&#x2F;&#x2F;  largeNumberSort</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;  Created by Richard on 9&#x2F;9&#x2F;15.</span><br><span class="line">&#x2F;&#x2F;  Copyright (c) 2015 luxin. All rights reserved.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">#define MAX_NUM 2000</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int add1[MAX_NUM],add2[MAX_NUM],res[MAX_NUM],tmp;</span><br><span class="line">char tmp1[MAX_NUM],tmp2[MAX_NUM];</span><br><span class="line">int N;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    int  count &#x3D; 0;</span><br><span class="line">    tmp &#x3D; 0;</span><br><span class="line">    while (count &lt; N) &#123;</span><br><span class="line">        </span><br><span class="line">        memset(add1,0,sizeof(add1));</span><br><span class="line">        memset(add2,0,sizeof(add2));</span><br><span class="line">        memset(res,0,sizeof(res));</span><br><span class="line">        memset(tmp1,0,sizeof(tmp1));</span><br><span class="line">        memset(tmp2,0,sizeof(tmp2));</span><br><span class="line">        </span><br><span class="line">        cin&gt;&gt;tmp1&gt;&gt;tmp2;</span><br><span class="line">        </span><br><span class="line">        int len1 &#x3D; static_cast&lt;int&gt;(strlen(tmp1));</span><br><span class="line">        int len2 &#x3D; static_cast&lt;int&gt;(strlen(tmp2));</span><br><span class="line">        </span><br><span class="line">        for (int i &#x3D; len1-1,k &#x3D; 0; i &gt;&#x3D; 0; --i,++k) &#123;</span><br><span class="line">            add1[k] &#x3D; tmp1[i] - &#39;0&#39;;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for (int i &#x3D; len2-1,k &#x3D; 0; i &gt;&#x3D; 0; --i,++k) &#123;</span><br><span class="line">            add2[k] &#x3D; tmp2[i] - &#39;0&#39;;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (len1 &gt;&#x3D; len2) &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt;&#x3D; len1; ++i) &#123;</span><br><span class="line">                res[i] &#x3D; (add1[i] + add2[i] + tmp) % 10;</span><br><span class="line">                tmp &#x3D; (add1[i] + add2[i] + tmp) &#x2F; 10;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;else if (len1 &lt; len2) &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt;&#x3D; len2; ++i) &#123;</span><br><span class="line">                res[i] &#x3D; (add1[i] + add2[i] + tmp) % 10;</span><br><span class="line">                tmp &#x3D; (add1[i] + add2[i] + tmp) &#x2F; 10;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int len &#x3D; 0;</span><br><span class="line">        if (len1 &gt;&#x3D; len2) len &#x3D; len1;</span><br><span class="line">        else len &#x3D; len2;</span><br><span class="line">        &#x2F;&#x2F;TODO: priint it</span><br><span class="line">        cout&lt;&lt;&quot;Case &quot;&lt;&lt;(count+1)&lt;&lt;&quot;:\n&quot;&lt;&lt;tmp1&lt;&lt;&quot; + &quot;&lt;&lt;tmp2&lt;&lt;&quot; &#x3D; &quot;;</span><br><span class="line">        if (res[len] !&#x3D; 0) cout&lt;&lt;res[len];</span><br><span class="line">        for (int i &#x3D; len-1; i &gt;&#x3D; 0; --i) &#123;</span><br><span class="line">            cout&lt;&lt;res[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;&quot;\n&quot;;</span><br><span class="line">        if (count !&#x3D; N-1) &#123;</span><br><span class="line">            cout&lt;&lt;&quot;\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="OJ" scheme="https://ufolux.github.io/categories/OJ/"/>
    
    
  </entry>
  
  <entry>
    <title>ACMCoder 2010</title>
    <link href="https://ufolux.github.io/2015/10/27/HDOJ/ACMCoder%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0/"/>
    <id>https://ufolux.github.io/2015/10/27/HDOJ/ACMCoder水仙花数/</id>
    <published>2015-10-27T15:42:07.000Z</published>
    <updated>2021-03-11T07:20:00.102Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://acm.acmcoder.com/showproblem.php?pid=2010">ACMCoder2010 水仙花数</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    freopen(&quot;testcase.in&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    freopen(&quot;testcase.out&quot;, &quot;w&quot;, stdout);</span><br><span class="line">    </span><br><span class="line">    int a,b;</span><br><span class="line">    while (cin&gt;&gt;a&gt;&gt;b) &#123;</span><br><span class="line">        bool flag &#x3D; false;</span><br><span class="line">        for (int i &#x3D; a; i &lt;&#x3D; b; ++i) &#123;</span><br><span class="line">            </span><br><span class="line">            int temp &#x3D; i,result&#x3D;0;</span><br><span class="line">            while (temp) &#123;</span><br><span class="line">                result+&#x3D;pow(temp%10, 3);</span><br><span class="line">                temp &#x3D; temp &#x2F; 10;</span><br><span class="line">            &#125;</span><br><span class="line">            if (result &#x3D;&#x3D; i) &#123;</span><br><span class="line">                if (!flag) &#123;</span><br><span class="line">                    cout&lt;&lt;result;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    cout&lt;&lt;&quot; &quot;&lt;&lt;result;</span><br><span class="line">                &#125;</span><br><span class="line">                flag &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!flag) &#123;</span><br><span class="line">            cout&lt;&lt;&quot;no&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;else</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    fclose(stdin);</span><br><span class="line">    fclose(stdout);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="OJ" scheme="https://ufolux.github.io/categories/OJ/"/>
    
    
  </entry>
  
  <entry>
    <title>HDOJ 1004</title>
    <link href="https://ufolux.github.io/2015/10/27/HDOJ/HDOJ1004/"/>
    <id>https://ufolux.github.io/2015/10/27/HDOJ/HDOJ1004/</id>
    <published>2015-10-27T15:42:07.000Z</published>
    <updated>2021-03-11T07:20:00.103Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1004">HDOJ1004 Let the Balloon Rise</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;  main.cpp</span><br><span class="line">&#x2F;&#x2F;  largeNumberSort</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;  Created by richard on 9&#x2F;9&#x2F;15.</span><br><span class="line">&#x2F;&#x2F;  Copyright (c) 2015 luxin. All rights reserved.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;    freopen(&quot;&#x2F;Users&#x2F;RichardLu&#x2F;Code&#x2F;C++&#x2F;Algorithm&#x2F;largeNumberSort&#x2F;largeNumberSort&#x2F;largeNumberSort&#x2F;testcase.in&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    &#x2F;&#x2F;    freopen(&quot;&#x2F;Users&#x2F;RichardLu&#x2F;Code&#x2F;C++&#x2F;Algorithm&#x2F;largeNumberSort&#x2F;largeNumberSort&#x2F;largeNumberSort&#x2F;testcase.out&quot;, &quot;w&quot;, stdout);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    map&lt;string, int&gt; string_int_map;</span><br><span class="line">    string a;</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    while (cin &gt;&gt; count&amp;&amp;count) &#123;</span><br><span class="line">        string_int_map.clear();</span><br><span class="line">        while (count--) &#123;</span><br><span class="line">            cin &gt;&gt; a;</span><br><span class="line">            string_int_map[a]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        string most &#x3D; &quot;&quot;;</span><br><span class="line">        for (map&lt;string, int&gt;::iterator it &#x3D; string_int_map.begin(); it !&#x3D; string_int_map.end(); ++it) &#123;</span><br><span class="line">            if (it-&gt;second &gt; string_int_map[most]) &#123;</span><br><span class="line">                most &#x3D; it-&gt;first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt;most&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;    fclose(stdin);</span><br><span class="line">    &#x2F;&#x2F;    fclose(stdout);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="OJ" scheme="https://ufolux.github.io/categories/OJ/"/>
    
    
  </entry>
  
  <entry>
    <title>HDOJ 1003</title>
    <link href="https://ufolux.github.io/2015/10/27/HDOJ/HDOJ1003/"/>
    <id>https://ufolux.github.io/2015/10/27/HDOJ/HDOJ1003/</id>
    <published>2015-10-27T15:42:07.000Z</published>
    <updated>2021-03-11T07:20:00.103Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1003">HDOJ1003 Max Sum</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define  MAX_LEN  100000UL</span><br><span class="line"></span><br><span class="line">int max_subsq(int *array, unsigned int size, unsigned int *start, unsigned int *end)</span><br><span class="line">&#123;</span><br><span class="line">    int max_sum &#x3D; -2000, sum &#x3D; 0;</span><br><span class="line">    int curstart &#x3D; *start &#x3D; 0;</span><br><span class="line">    unsigned int i;</span><br><span class="line">    </span><br><span class="line">    for (i &#x3D; 0; i &lt; size; i++)&#123;</span><br><span class="line">        if (sum &lt; 0)&#123;</span><br><span class="line">            sum &#x3D; array[i];&#x2F;&#x2F;丢弃之前的子串</span><br><span class="line">            curstart &#x3D; i;  &#x2F;&#x2F;将当前位置作为新的起始位置</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sum +&#x3D; array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (sum &gt; max_sum)&#123;</span><br><span class="line">            max_sum &#x3D; sum;</span><br><span class="line">            *start &#x3D; curstart;</span><br><span class="line">            *end   &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return max_sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int A[MAX_LEN];</span><br><span class="line">    int i &#x3D; 0, round, n, max;</span><br><span class="line">    unsigned int start, end;</span><br><span class="line">    freopen(&quot;&#x2F;Users&#x2F;RichardLu&#x2F;Code&#x2F;C++&#x2F;Algorithm&#x2F;largeNumberSort&#x2F;largeNumberSort&#x2F;largeNumberSort&#x2F;testcase.in&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    freopen(&quot;&#x2F;Users&#x2F;RichardLu&#x2F;Code&#x2F;C++&#x2F;Algorithm&#x2F;largeNumberSort&#x2F;largeNumberSort&#x2F;largeNumberSort&#x2F;testcase.out&quot;, &quot;w&quot;, stdout);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;round);</span><br><span class="line">    </span><br><span class="line">    while (i++ &lt; round)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        for (int j &#x3D; 0; j &lt; n; j++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;A[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        max &#x3D; max_subsq(A, n, &amp;start, &amp;end);</span><br><span class="line">        </span><br><span class="line">        printf(&quot;Case %d:\n&quot;, i);</span><br><span class="line">        printf(&quot;%d %d %d\n&quot;, max, start + 1, end + 1);</span><br><span class="line">        </span><br><span class="line">        if (i !&#x3D; round) printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(stdin);</span><br><span class="line">    fclose(stdout);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="OJ" scheme="https://ufolux.github.io/categories/OJ/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 9 系列教程 在UIKit中实践面向协议编程</title>
    <link href="https://ufolux.github.io/2015/10/27/Translation/iOS%209%20Tutorial%20Series-%20Protocol-Oriented%20Programming%20with%20UIKit/"/>
    <id>https://ufolux.github.io/2015/10/27/Translation/iOS 9 Tutorial Series- Protocol-Oriented Programming with UIKit/</id>
    <published>2015-10-27T15:42:07.000Z</published>
    <updated>2021-03-11T07:20:00.110Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="iOS-9-系列教程-在UIKit中实践面向协议编程"><a href="#iOS-9-系列教程-在UIKit中实践面向协议编程" class="headerlink" title="iOS 9 系列教程 在UIKit中实践面向协议编程"></a>iOS 9 系列教程 在UIKit中实践面向协议编程</h1><p><a href="https://www.captechconsulting.com/blogs/ios-9-tutorial-series-protocol-oriented-programming-with-uikit">原文在此</a> 翻译 by skyfly.xyz</p><p>在 WWDC2015 上那次关于 Swift 面向协议编程的发人深省的演讲后（是的，“很难啃”的那部分）似乎每个人都在谈论协议扩展这个令人兴奋的新的语言特性，同时它也使每个人都感到过困惑。</p><span id="more"></span><p>我曾经阅读过不计其数的关于 Swift 协议和协议扩展细节的文章，很明显，协议扩展将会成为 Swift 这道大餐里面的一剂猛料，苹果甚至建议，在可能的情况下尽量使用协议来替代类 —— 这个方法是面向协议编程的关键。</p><p>但是这些文章仅仅告诉了我什么是协议扩展，他们并没有明确的告诉我面向协议编程对于 UI 开发的意义是什么。现在大多数可用的示例代码构建的场景都是从来没有利用过任何框架。</p><p>我想要知道协议扩展应该如何应用于我已经构建的那些应用，我如何才能更加有力地在 iOS 中最重要的框架 — UIKit 中去利用这些方法。</p><p>既然我们有协议扩展，那么基于协议的方法在充满了类的 UIKit 框架中是不是更有价值呢？这篇文章中，我尝试对 Swift 协议扩展在真实世界的 UI 场景中的作用作一个合理的说明，并且也是记录我发现并没有完全的认识到协议扩展作用的流水账。</p><h3 id="使用协议的好处"><a href="#使用协议的好处" class="headerlink" title="使用协议的好处"></a>使用协议的好处</h3><p>协议并没有什么新鲜的，但我们可以使用内置的功能，共享的逻辑，神奇的力量扩展它们的这个想法……嗯，这是一个有趣的想法。更多个协议 == 更好的灵活性。每个协议扩展都是一小块可以被采用，重写（或者不）的模块化功能，并且可以通过 where 子句与特定类型的代码进行交互。</p><p>协议确实存在的目的确实只是为了讨编译器的欢心，但是协议扩展是真正可以在代码集之中共享的逻辑片段。</p><p>虽然我们只可以继承自一个父类，但是我们可以按照意愿遵守任意多数量的协议，遵守一个扩展后的协议就类似于在 Angular.js 中向 element 添加一个指令一样 —— 我们将一段改变对象行为的逻辑注射进去。协议不再仅仅是一个约定，结合扩展，他们可以是对功能的接受。</p><h3 id="如何去使用协议扩展"><a href="#如何去使用协议扩展" class="headerlink" title="如何去使用协议扩展"></a>如何去使用协议扩展</h3><p>协议扩展的用法十分简单，这篇文章不是一个指南，但是如果你需要尽快得知它是如何工作的而不是讨论协议扩展之于 UIKit 开发的适用性，请你去参考官方的 Swift 文档中关于协议扩展的那部分内容。</p><h3 id="协议扩展的局限性"><a href="#协议扩展的局限性" class="headerlink" title="协议扩展的局限性"></a>协议扩展的局限性</h3><p>在我们开始之前，需要弄清楚协议扩展不能做什么。有很多我们不能使用协议扩展来做的事，它们之中有许多是因为语言的设计原因导致的。然而我希望看到的是，在Swift的后续版本中，苹果可以对这些局限性做相应的处理。</p><ul><li><p>不能在 Objective-C 中调用协议扩展中的成员。</p></li><li><p>不能对结构体类型使用 where 语句。</p></li><li><p>不能定义由多个逗号分隔的 where 语句，类似于 if let 声明。</p></li><li><p>不能将动态变量存储在协议扩展中。</p></li><li><p>这也适用于非泛型的扩展中</p></li><li><p>静态变量应该是允许存在的，但是按照目前来看， Xcode 7.0 中将这种做法看作是一个错误，错误信息是 “static stored properties not yet supported in generic types”。</p></li><li><p>不能通过super来调用一个协议扩展，不像非泛型扩展那样，不过 <a href>@ketzusaka</a> 指出这可以通过这样的 <code>(self as MyProtocol).method()</code> 调用来实现。好想法！由于这个原因，协议扩展并没有真正的继承的概念。</p></li><li><p>不能遵守多个其中有重复成员的协议扩展。Swift 运行时会遵守最后一个协议而忽略其他的协议。</p><p>举个例子，如果我们有2个实现了相同方法的协议扩展，只有我们遵守的最后一个协议中的那个方法会被调用。无法调用其它扩展中的方法。</p></li><li><p>不能继承可选的协议方法。</p><p>可选协议方法需要使用     <code>@objc</code> 标签，然而这个标签并不能和协议扩展一起工作。</p></li><li><p>协议和它的扩展不能同时声明。</p></li></ul><p>如果能够在声明协议扩展协议部分的同时实现它的扩展，那就太好了。因为当扩展中包含了所有重要的逻辑时，协议中并不总是会有成员存在。</p><h2 id="第一部分：扩展现有的-UIKit-协议"><a href="#第一部分：扩展现有的-UIKit-协议" class="headerlink" title="第一部分：扩展现有的 UIKit 协议"></a>第一部分：扩展现有的 UIKit 协议</h2><p>当我第一次了解到协议扩展的时候，首先映入我脑海的协议是 <code>UITableViewDataSource</code> ，可以说在iOS平台上这是被最广泛实现的一个协议。我想，我是不是可以在我的应用中为所有的 <code>UITableViewDataSource</code> 提供一个默认的实现呢？这个貌似很有趣。</p><p>如果每个 UITableView 有很多的 sections，为什么不在同一个地方继承 <code>UITableViewDataSource</code> 并且实现 <code>numberOfSectionsInTableView:</code> 呢？如果我要在所有的列表中实现滑动删除功能的话，为何不在协议扩展中去实现 <code>UITableViewDelegate</code> 呢？</p><p>到现在为止，这件事还是不可能的。</p><p>我们<strong>不能</strong>做的：为 Objective-C    协议提供默认实现。</p><p>UIKit 仍然是从 Objective-C 编译过来的，而且 Objective-C 中没有可扩展协议这个概念。在实践中，这意味着尽管我们可以声明对 UIKit 协议的扩展，但是 UIKit 对象并不能够发现我们写在协议扩展中的方法。</p><p>举一个例子：如果我们在 <code>UICollectionViewDelegate</code> 的扩展中实现 <code>collectionView:didSelectItemAtIndexPath:</code> 方法，结果就是当 cell 被点击的时候，我们写在协议扩展中的这个方法并不会被调用，因为处于 Objective-C 语境中的 <code>UICollectionView</code> 发现不了这个方法。如果我们将一个非可选方法写到协议扩展里面，比如 <code>collectionView:cellForItemAtIndexPath:</code>，编译器将会抱怨说，我们没有遵守 <code>UICollectionViewDelegate</code> 协议。</p><p>Xcode 尝试着去给我们的协议扩展方法添加 <code>@objc</code> 前缀去修复这个问题，但是这是白费劲，这样做只会导致一个新的错误：<code>&quot;Method in protocol extension cannot be represented in Objective-C.&quot;</code> 这是底层的问题 —— 协议扩展只在 Swift2.x 以上版本的代码中才是可用的。</p><p>我们<strong>不能</strong>做的：为一个现存的 Objective-C 协议添加新的方法。</p><p>我们可以通过 Swift 直接调用 UIKit 的协议扩展方法，就算 UIKit 无法发现他们。这意味着尽管我们不能重写现存的 UIKit 协议方法，但是当我们需要使用那些协议的时候，可以为他们添加新的便利方法。</p><p>我承认，这好像没有那么令人激动。并且任何传统的 Objective-C 代码依旧无法调用这些方法。但这里还是留着一些机会。下面是一些简单的例子，这些例子告诉我们当前可以如何将现有的 UIKit 协议和协议扩展结合使用。</p><p>UIKit 协议扩展示例</p><h3 id="扩展-UICoordinateSpace"><a href="#扩展-UICoordinateSpace" class="headerlink" title="扩展 UICoordinateSpace"></a>扩展 <code>UICoordinateSpace</code></h3><p>是否曾经有过必须在 Core Graphics 和 UIKit 坐标系中做转换的经历？我们可以为 <code>UICoordinateSpace</code> 添加辅助方法，一个让 UIView 遵守的协议。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extension UICoordinateSpace &#123;</span><br><span class="line">    func insvertedRect(rect: CGRect) -&gt; CGRect &#123;</span><br><span class="line">        var transform &#x3D; CGAffineTransformMakeScale(1, -1)</span><br><span class="line">        transform &#x3D; CGAffineTransformTranslate(transform, 0, -self.bounds.size.height)</span><br><span class="line">        return CGRectApplyAffineTransform(rect, transform)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们的 <code>invertedRect</code> 方法在任何  <code>UICoordinateSpace</code> 协议的遵守者中都是可用的了，我们可以在我们的绘图方法中使用它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class DrawingView : UIView &#123;</span><br><span class="line">    &#x2F;&#x2F; Example -- Referencing custom UICoordinateSpace method inside UIView drawRect.</span><br><span class="line">    override func drawRect(rect: CGRect) &#123;</span><br><span class="line">        let invertedRect &#x3D; self.invertedRect(CGRectMake(50.0, 50.0, 200.0, 100.0))</span><br><span class="line">        print(NSStringFromCGRect(invertedRect)) &#x2F;&#x2F; 50.0, -150.0, 200.0, 100.0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展-UITableViewDataSource"><a href="#扩展-UITableViewDataSource" class="headerlink" title="扩展 UITableViewDataSource"></a>扩展 <code>UITableViewDataSource</code></h3><p>尽管我们不能为 <code>UITableViewDataSource</code> 提供默认实现，但我们仍然可以将那些可以被应用中任何 <code>UITableViewDataSource</code> 用到的通用逻辑放入协议中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">extension UITableViewDataSource &#123;</span><br><span class="line">    &#x2F;&#x2F; Returns the total # of rows in a table view.</span><br><span class="line">    func totalRows(tableView: UITableView) -&gt; Int &#123;</span><br><span class="line">        let totalSections &#x3D; self.numberOfSectionsInTableView?(tableView) ?? 1</span><br><span class="line">        var s &#x3D; 0, t &#x3D; 0</span><br><span class="line">        while s &lt; totalSections &#123;</span><br><span class="line">            t +&#x3D; self.tableView(tableView, numberOfRowsInSection: s)</span><br><span class="line">            s++</span><br><span class="line">        &#125;</span><br><span class="line">        return t</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>totalRows:</code> 方法是一个能够计算出我们 TableView 中 cell 个数的快捷方法，当 TableView 被分成很多 section 但是需要显示条目总数的时候很有用。<code>tableView:titleForFooterInSection:</code> 是使用这个方法的最佳位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class ItemsController: UITableViewController &#123;</span><br><span class="line">    &#x2F;&#x2F; Example -- displaying total # of items as a footer label.</span><br><span class="line">    override func tableView(tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? &#123;</span><br><span class="line">        if section &#x3D;&#x3D; self.numberOfSectionsInTableView(tableView)-1 &#123;</span><br><span class="line">            return String(&quot;Viewing %f Items&quot;, self.totalRows(tableView))</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展-UIViewControllerContextTransitioning"><a href="#扩展-UIViewControllerContextTransitioning" class="headerlink" title="扩展 UIViewControllerContextTransitioning"></a>扩展 <code>UIViewControllerContextTransitioning</code></h3><p>在阅读过我的《自定义导航过场动画 &amp; 更多（胡乱塞入的）》这篇文章后，也许你正在忙于制作一个自定义的导航过场动画。这里有一些我本应该在那个教程中用到的方法，是通过<br><code>UIViewControllerContextTransitioning</code> 协议提供的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">extension UIViewControllerContextTransitioning &#123;</span><br><span class="line">    &#x2F;&#x2F; Mock the indicated view by replacing it with its own snapshot. Useful when we don&#39;t want to render a view&#39;s subviews during animation, such as when applying transforms.</span><br><span class="line">    func mockViewWithKey(key: String) -&gt; UIView? &#123;</span><br><span class="line">        if let view &#x3D; self.viewForKey(key), container &#x3D; self.containerView() &#123;</span><br><span class="line">            let snapshot &#x3D; view.snapshotViewAfterScreenUpdates(false)</span><br><span class="line">            snapshot.frame &#x3D; view.frame</span><br><span class="line">            </span><br><span class="line">            container.insertSubview(snapshot, aboveSubview: view)</span><br><span class="line">            view.removeFromSuperview()</span><br><span class="line">            return snapshot</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Add a background to the container view. Useful for modal presentations, such as showing a partially translucent background behind our modal content.</span><br><span class="line">    func addBackgroundView(color: UIColor) -&gt; UIView? &#123;</span><br><span class="line">        if let container &#x3D; self.containerView() &#123;</span><br><span class="line">            let bg &#x3D; UIView(frame: container.bounds)</span><br><span class="line">            bg.backgroundColor &#x3D; color</span><br><span class="line">            </span><br><span class="line">            container.addSubview(bg)</span><br><span class="line">            container.sendSubviewToBack(bg)</span><br><span class="line">            return bg</span><br><span class="line">        &#125;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们能在传入我们动画协调者的 <code>transitionContext</code> 对象中调用这些方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class AnimationCoordinator : NSObject, UIViewControllerAnimatedTransitioning &#123;</span><br><span class="line">    &#x2F;&#x2F; Example -- using helper methods during a view controller transition.</span><br><span class="line">    func animateTransition(transitionContext: UIViewControllerContextTransitioning) &#123;</span><br><span class="line">        &#x2F;&#x2F; Add a background</span><br><span class="line">        transitionContext.addBackgroundView(UIColor(white: 0.0, alpha: 0.5))</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; Swap out the &quot;from&quot; view</span><br><span class="line">        transitionContext.mockViewWithKey(UITransitionContextFromViewKey)</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; Animate using awesome 3D animation...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func transitionDuration(transitionContext: UIViewControllerContextTransitioning?) -&gt; NSTimeInterval &#123;</span><br><span class="line">        return 5.0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展-UIScrollViewDelegate"><a href="#扩展-UIScrollViewDelegate" class="headerlink" title="扩展 UIScrollViewDelegate"></a>扩展 <code>UIScrollViewDelegate</code></h3><p>我们现在来看这种情况，在我们的应用中有许多个 <code>UIPageControl</code> 实例，为了使他们工作，我们往往要在各个 <code>UIScrollViewDelegate</code> 的实现之间复制和粘贴一些代码。协议扩展可以让这些逻辑变成通用化，而所有的调用都可以通过 <code>self</code> 来进行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">extension UIScrollViewDelegate &#123;</span><br><span class="line">    &#x2F;&#x2F; Convenience method to update a UIPageControl with the correct page.</span><br><span class="line">    func updatePageControl(pageControl: UIPageControl, scrollView: UIScrollView) &#123;</span><br><span class="line">        pageControl.currentPage &#x3D; lroundf(Float(scrollView.contentOffset.x &#x2F; (scrollView.contentSize.width &#x2F; CGFloat(pageControl.numberOfPages))));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Additionally, if we know Self is a UICollectionViewController we can eliminate the method&#39;s scrollView parameter.</span><br><span class="line"></span><br><span class="line">extension UIScrollViewDelegate where Self: UICollectionViewController &#123;</span><br><span class="line">    func updatePageControl(pageControl: UIPageControl) &#123;</span><br><span class="line">        pageControl.currentPage &#x3D; lroundf(Float(self.collectionView!.contentOffset.x &#x2F; (self.collectionView!.contentSize.width &#x2F; CGFloat(pageControl.numberOfPages))));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Example -- Page control updates from a UICollectionViewController using a protocol extension.</span><br><span class="line">class PagedCollectionView : UICollectionViewController &#123;</span><br><span class="line">    let pageControl &#x3D; UIPageControl()</span><br><span class="line">    </span><br><span class="line">    override func scrollViewDidScroll(scrollView: UIScrollView) &#123;</span><br><span class="line">        self.updatePageControl(self.pageControl)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，这些例子都很做作，事实证明，当涉及到扩展现有的 UIKit 协议时，并没有太多的选择，所做的事情都是非常不值一提的。然而，我们还是要问，如何才能在现有的 UIKit 设计模式上去使用自定义的协议扩展。</p><h2 id="第二部分：扩展自定义的协议"><a href="#第二部分：扩展自定义的协议" class="headerlink" title="第二部分：扩展自定义的协议"></a>第二部分：扩展自定义的协议</h2><p>使用 MVC 模式的面向协议编程<br>一个 iOS 应用一定会实现3个最重要的功能，这也是 iOS 应用开发的核心。这种设计模式通常被称为 <code>MVC (Model-View-Controller)</code>。其实，一个 app 真正所做的事情就是将某种数据可视化的表示出来。</p><h3 id="MVC详解"><a href="#MVC详解" class="headerlink" title="MVC详解"></a>MVC详解</h3><p>在下面三个例子中，我将会通过协议扩展来演示一些面向协议的设计模式，MVC模式的3个组成部分按照 Model -&gt; Controller -&gt; View 的顺序来工作。</p><h4 id="利用协议来管理Model（M）"><a href="#利用协议来管理Model（M）" class="headerlink" title="利用协议来管理Model（M）"></a>利用协议来管理Model（M）</h4><p>就拿我们正在开发的音乐 app Pear Music 来讲。涉及到了艺人，唱片，歌曲和播放列表这些 Model。我们需要构建一些代码来根据一个已经载入的标志从网络上获取这些 model。</p><p>当使用协议来进行开发的时候，最好从一个最高层次的抽象来入手。一个基本的原理是通过 API 按照资源的远程表示填充到 model 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Any entity which represents data which can be loaded from a remote source.</span><br><span class="line">protocol RemoteResource &#123;&#125;</span><br></pre></td></tr></table></figure><p>不过，稍等一下，这只不过是一个空的协议！我们不打算直接使用 <code>RemoteResource</code> 。这不是一个合约，而是一组功能，其中包括发起网络请求。因此，<code>RemoteResource</code> 的真正价值在于它的协议扩展。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">extension RemoteResource &#123;</span><br><span class="line">    func load(url: String, completion: ((success: Bool)-&gt;())?) &#123;</span><br><span class="line">        print(&quot;Performing request: &quot;, url)</span><br><span class="line">        </span><br><span class="line">        let task &#x3D; NSURLSession.sharedSession().dataTaskWithURL(NSURL(string: url)!) &#123; (data, response, error) -&gt; Void in</span><br><span class="line">            if let httpResponse &#x3D; response as? NSHTTPURLResponse where error &#x3D;&#x3D; nil &amp;&amp; data !&#x3D; nil &#123;</span><br><span class="line">                print(&quot;Response Code: %d&quot;, httpResponse.statusCode)</span><br><span class="line">                </span><br><span class="line">                dataCache[url] &#x3D; data</span><br><span class="line">                if let c &#x3D; completion &#123;</span><br><span class="line">                    c(success: true)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                print(&quot;Request Error&quot;)</span><br><span class="line">                if let c &#x3D; completion &#123;</span><br><span class="line">                    c(success: false)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        task.resume()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func dataForURL(url: String) -&gt; NSData? &#123;</span><br><span class="line">        &#x2F;&#x2F; A real app would require a more robust caching solution.</span><br><span class="line">        return dataCache[url]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public var dataCache: [String : NSData] &#x3D; [:]</span><br></pre></td></tr></table></figure><p>现在我们有了一个具有内建了加载远程数据并且检索数据功能的协议，任何这个协议的接受者将会自动得到这些方法。</p><p>我们已经给出了两个 API 用于交互，一个是表示 JSON 数据的（<code>api,pearmusic.com</code>）另一个是表示媒体的（<code>media.pearmusic.com</code>）。为了处理这个，我们将会为每种类型的数据设计一个 <code>RemoteResource</code> 的子协议。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protocol JSONResource : RemoteResource &#123;</span><br><span class="line">    var jsonHost: String &#123; get &#125;</span><br><span class="line">    var jsonPath: String &#123; get &#125;</span><br><span class="line">    func processJSON(success: Bool)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol MediaResource : RemoteResource &#123;</span><br><span class="line">    var mediaHost: String &#123; get &#125;</span><br><span class="line">    var mediaPath: String &#123; get &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一起来实现这几个协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">extension JSONResource &#123;</span><br><span class="line">    &#x2F;&#x2F; Default host value for REST resources</span><br><span class="line">    var jsonHost: String &#123; return &quot;api.pearmusic.com&quot; &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Generate the fully qualified URL</span><br><span class="line">    var jsonURL: String &#123; return String(format: &quot;http:&#x2F;&#x2F;%@%@&quot;, self.jsonHost, self.jsonPath) &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Main loading method.</span><br><span class="line">    func loadJSON(completion: (()-&gt;())?) &#123;</span><br><span class="line">        self.load(self.jsonURL) &#123; (success) -&gt; () in</span><br><span class="line">            &#x2F;&#x2F; Call adopter to process the result</span><br><span class="line">            self.processJSON(success)</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; Execute completion block on the main queue</span><br><span class="line">            if let c &#x3D; completion &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), c)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们提供了默认的 host，一个用来生成完整的 URL，另一个用来让他自己通过 <code>RemoteResourse</code> 的 <code>load:</code> 方法载入资源。一会我们会依靠我们的协议接受者来提供正确的 jsonPath。</p><p><code>MediaResource</code> 的模式与之相似。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">extension MediaResource &#123;</span><br><span class="line">    &#x2F;&#x2F; Default host value for media resources</span><br><span class="line">    var mediaHost: String &#123; return &quot;media.pearmusic.com&quot; &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Generate the fully qualified URL</span><br><span class="line">    var mediaURL: String &#123; return String(format: &quot;http:&#x2F;&#x2F;%@%@&quot;, self.mediaHost, self.mediaPath) &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Main loading method</span><br><span class="line">    func loadMedia(completion: (()-&gt;())?) &#123;</span><br><span class="line">        self.load(self.mediaURL) &#123; (success) -&gt; () in</span><br><span class="line">            &#x2F;&#x2F; Execute completion block on the main queue</span><br><span class="line">            if let c &#x3D; completion &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), c)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能注意到了这些实现是十分相似的。事实上将这些方法提升到 <code>RemoteResource</code> 它本身中是更加明智的，我们的子协议只需要返回正确的 host 就够了。</p><p>美中不足的是，我们的协议之间并不是互斥的 —— 我们想要一个能够同时表示 <code>JSONResource</code> 和 <code>MediaResource</code> 的对象。记住，协议扩展彼此之间会相互覆盖。除非我们想要显式地将这些属性和方法分开，只有哪些在最后一个被接受的协议中的方法和属性才能被调用。</p><p>通过给我们一些数据访问，来让他们更加特化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">extension JSONResource &#123;</span><br><span class="line">    var jsonValue: [String : AnyObject]? &#123;</span><br><span class="line">        do &#123;</span><br><span class="line">            if let d &#x3D; self.dataForURL(self.jsonURL), result &#x3D; try NSJSONSerialization.JSONObjectWithData(d, options: NSJSONReadingOptions.MutableContainers) as? [String : AnyObject] &#123;</span><br><span class="line">                return result</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch &#123;&#125;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension MediaResource &#123;</span><br><span class="line">    var imageValue: UIImage? &#123;</span><br><span class="line">        if let d &#x3D; self.dataForURL(self.mediaURL) &#123;</span><br><span class="line">            return UIImage(data: d)</span><br><span class="line">        &#125;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个展现协议扩展价值的经典的例子。一个传统的协议说：“我保证我是这种类型的东西，拥有这些特性“，而一个协议扩展说：”我有这些特性，因此我可以做这些特别的事情”。 <code>MediaResource</code> 访问了图像数据，它可以不去管它的具体类型或者是上下文，而是很简单的提供一个图像的值。</p><p>我提到我们将要根据一个标志（identifiers）加载我们的 model ，所以我们来为那些具有一个唯一标志的实体写一个协议。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">protocol Unique &#123;</span><br><span class="line">    var id: String! &#123; get set &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Unique where Self: NSObject &#123;</span><br><span class="line">    &#x2F;&#x2F; Built-in init method from a protocol!</span><br><span class="line">    init(id: String?) &#123;</span><br><span class="line">        self.init()</span><br><span class="line">        if let identifier &#x3D; id &#123;</span><br><span class="line">            self.id &#x3D; identifier</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            self.id &#x3D; NSUUID().UUIDString</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Bonus: Make sure Unique adopters are comparable.</span><br><span class="line">func &#x3D;&#x3D;(lhs: Unique, rhs: Unique) -&gt; Bool &#123;</span><br><span class="line">    return lhs.id &#x3D;&#x3D; rhs.id</span><br><span class="line">&#125;</span><br><span class="line">extension NSObjectProtocol where Self: Unique &#123;</span><br><span class="line">    func isEqual(object: AnyObject?) -&gt; Bool &#123;</span><br><span class="line">        if let o &#x3D; object as? Unique &#123;</span><br><span class="line">            return o.id &#x3D;&#x3D; self.id</span><br><span class="line">        &#125;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们不能在扩展中存储属性，我们还是不得不去依赖我们 <code>Unique</code> 的接受者声明 <code>id</code> 类型的属性。另外，你可能注意到了，我只为那些那些继承自 <code>NSObject</code> 类型的对象扩展了 <code>Unique</code> 协议。否则我们就不能调用 <code>self.init()</code> 因为它没有被声明。我们用一个变通的办法来解决这个问题，这个办法就是在协议中声明 <code>init()</code> 方法，但是这就需要接受者来实现这个方法。由于我们所有的 model 都是继承自 NSObject 类型的，所以这个情况下，这不成问题。</p><p>Ok，我们已经得到了一个从网络加载数据的基本策略。我们开始让 model 遵守这些协议。这是 <code>Song</code> model 的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Song : NSObject, JSONResource, Unique &#123;</span><br><span class="line">    &#x2F;&#x2F; MARK: - Metadata</span><br><span class="line">    var title: String?</span><br><span class="line">    var artist: String?</span><br><span class="line">    var streamURL: String?</span><br><span class="line">    var duration: NSNumber?</span><br><span class="line">    var imageURL: String?</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; MARK: - Unique</span><br><span class="line">    var id: String!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，稍等，<code>JSONResource</code> 的实现去哪了？</p><p>与其直接在我们的类中去实现 <code>JSONResource</code> 协议，不如利用一个条件化的协议扩展。这让我们只需在同一个地方稍作调整就可以组织所有基于 <code>RemoteResource</code> 的格式化逻辑，同时保持我们 model 实现的简洁。因此我们需要将下面的代码放进 <code>RemoteResource.swift</code> 文件中，而其他之前基于这个协议的逻辑则不用修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">extension JSONResource where Self: Song &#123;</span><br><span class="line">    var jsonPath: String &#123; return String(format: &quot;&#x2F;songs&#x2F;%@&quot;, self.id) &#125;</span><br><span class="line">    </span><br><span class="line">    func processJSON(success: Bool) &#123;</span><br><span class="line">        if let json &#x3D; self.jsonValue where success &#123;</span><br><span class="line">            self.title &#x3D; json[&quot;title&quot;] as? String ?? &quot;&quot;</span><br><span class="line">            self.artist &#x3D; json[&quot;artist&quot;] as? String ?? &quot;&quot;</span><br><span class="line">            self.streamURL &#x3D; json[&quot;url&quot;] as? String ?? &quot;&quot;</span><br><span class="line">            self.duration &#x3D; json[&quot;duration&quot;] as? NSNumber ?? 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保持在一个地方的所有的东西和 <code>RemoteResource</code> 相关对程序的组织有好处。协议的实现都在同一个地方，而且扩展的范围很清晰。当声明一个需要被扩展的协议时，我建议将扩展写在同一个文件内。</p><p>多亏了 <code>JSONResource</code>,<code>Unique</code> 的协议扩展，加载一首歌曲现在看起来是这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let s &#x3D; Song(id: &quot;abcd12345&quot;)</span><br><span class="line">let artistLabel &#x3D; UILabel()</span><br><span class="line"></span><br><span class="line">s.loadJSON &#123; (success) -&gt; () in</span><br><span class="line">    artistLabel.text &#x3D; s.artist</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转眼间我们的 Song 对象是一个队员数据的简单封装了，这也正是它应该变成的样子。我们的协议扩展正在为它做所有麻烦的事情。</p><p>这里有一个例子，它解释了一个同时遵守了 <code>JSONResource</code>，<code>MediaResource</code> 和 <code>MediaResource</code> 协议的 Playlist 对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Playlist: NSObject, JSONResource, MediaResource, Unique &#123;</span><br><span class="line">    &#x2F;&#x2F; MARK: - Metadata</span><br><span class="line">    var title: String?</span><br><span class="line">    var createdBy: String?</span><br><span class="line">    var songs: [Song]?</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; MARK: - Unique</span><br><span class="line">    var id: String!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension JSONResource where Self: Playlist &#123;</span><br><span class="line">    var jsonPath: String &#123; return String(format: &quot;&#x2F;playlists&#x2F;%@&quot;, self.id) &#125;</span><br><span class="line">    </span><br><span class="line">    func processJSON(success: Bool) &#123;</span><br><span class="line">        if let json &#x3D; self.jsonValue where success &#123;</span><br><span class="line">            self.title &#x3D; json[&quot;title&quot;] as? String ?? &quot;&quot;</span><br><span class="line">            self.createdBy &#x3D; json[&quot;createdBy&quot;] as? String ?? &quot;&quot;</span><br><span class="line">            &#x2F;&#x2F; etc...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在之前我们不假思索地为 <code>Playlist</code> 实现了 <code>MediaResource</code> 协议，是时候向后退回一点。我们注意到 media API 只要求提供 identifier ，并没有说明任何的具体类型。那意味着我们只需要知道 identifier 就可以构建 meidaPath。我们来使用一个 where 子句来让 <code>MediaResource</code> “聪明地” 和 <code>Unique</code> 一起工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extension MediaResource where Self: Unique &#123;</span><br><span class="line">    var mediaPath: String &#123; return String(format: &quot;&#x2F;images&#x2F;%@&quot;, self.id) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>Playlist</code> 已经遵守了 <code>Unique</code> 协议，这里已经不需要实现什么东西,就可以是它与 <code>MediaResource</code> 一起工作了！同样的逻辑可以应用到任何同样既是 <code>Unique</code> 也是 <code>MediaResource</code> 的对象上 —— 只要对象的 identifier 和我们 media API 中的图像符合就可以。他就将可以正常的工作。</p><p>Here’s how it looks to load our Playlist image:</p><p>看看它是怎么加载我们播放列表图片的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let p &#x3D; Playlist(id: &quot;abcd12345&quot;)</span><br><span class="line">let playlistImageView &#x3D; UIImageView(frame: CGRectMake(0.0, 0.0, 200.0, 200.0))</span><br><span class="line"></span><br><span class="line">p.loadMedia &#123; () -&gt; () in</span><br><span class="line">    playlistImageView.image &#x3D; p.imageValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在有一个通用的方法去定义那些可以被我们 app 中任何实体用到的远程资源了，不只是这些 model 对象。我们可以通过简单的扩展 <code>RemoteResource</code> 协议来处理不同类型的 <code>REST</code> 操作，并且可以为其它类型的数据构建更多的子协议。</p><h4 id="数据格式化协议-（C）"><a href="#数据格式化协议-（C）" class="headerlink" title="数据格式化协议 （C）"></a>数据格式化协议 （C）</h4><p>我们已经创建了一个加载 model 对象的方法，让我们将视线转移到下一步。为了将数据以一致的方式显示出来，我们需要格式化对象的元数据。</p><p>Pear Music 是一个庞大的 app，而且我们有许多不同类型的 model。每一个 model 都可以被显示在很多不同的地方。举个例子，我们想用一个艺人的名字作为 view controller 的标题，我们就想要让它简单地显示类似于 “{name}” 这样的东西。然而如果我们有一些额外的空间，比如在 <code>UITableViewCell</code> 中，我们就要换做用 “{name} ({instrument})” 这样的东西来显示。更进一步，如果我们有更大的空间，比如在一个很大的 <code>UILabel</code> 里面，我们就要使用 “{name} ({instrument}) {bio}”。</p><p>我们可以将这些格式化代码放入 view controller ， cell ，label 之中。这会工作得很好，但是这样做就会将逻辑散布在应用之中从而降低了可维护性。</p><p>将字符串格式化的工作可以放在 model 对象自身中来进行，但是当这些字符串真的需要被显示的时候，就不得不去做类型假设。</p><p>我们可以在一个基类中抛出一些便利方法，并且让每个 model 的子类提供他们自己的格式化方法，但是使用面向协议编程的方法，我们就应该以更加通用角度的考虑这些。</p><p>来把这些抽象的想法变成另一个协议好了，它可以描述任意一个可以被当成字符串来表示的对象。这里将会提供许多种长度的字符串，他们可以被用在不同的 UI 场景下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Any entity which can be represented as a string of varying lengths.</span><br><span class="line">protocol StringRepresentable &#123;</span><br><span class="line">    var shortString: String &#123; get &#125;</span><br><span class="line">    var mediumString: String &#123; get &#125;</span><br><span class="line">    var longString: String &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Bonus: Make sure StringRepresentable adopters are printed descriptively to the console.</span><br><span class="line">extension NSObjectProtocol where Self: StringRepresentable &#123;</span><br><span class="line">    var description: String &#123; return self.longString &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>足够简单。这里有几个我们将要构建成符合 <code>StringRepresentable</code> 协议的 model 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Artist : NSObject, StringRepresentable &#123;</span><br><span class="line">    var name: String!</span><br><span class="line">    var instrument: String!</span><br><span class="line">    var bio: String!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Album : NSObject, StringRepresentable &#123;</span><br><span class="line">    var title: String!</span><br><span class="line">    var artist: Artist!</span><br><span class="line">    var tracks: Int!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与我们组织 <code>RemoteResource</code> 的实现相似，我们将会把格式化的逻辑放进单独的 <code>StringRepresentable.swift</code> 文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extension StringRepresentable where Self: Artist &#123;</span><br><span class="line">    var shortString: String &#123; return self.name &#125;</span><br><span class="line">    var mediumString: String &#123; return String(format: &quot;%@ (%@)&quot;, self.name, self.instrument) &#125;</span><br><span class="line">    var longString: String &#123; return String(format: &quot;%@ (%@), %@&quot;, self.name, self.instrument, self.bio) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension StringRepresentable where Self: Album &#123;</span><br><span class="line">    var shortString: String &#123; return self.title &#125;</span><br><span class="line">    var mediumString: String &#123; return String(format: &quot;%@ (%d Tracks)&quot;, self.title, self.tracks) &#125;</span><br><span class="line">    var longString: String &#123; return String(format: &quot;%@, an Album by %@ (%d Tracks)&quot;, self.title, self.artist.name, self.tracks) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们已经处理好了格式化问题。还需要以一种方式来选择哪个字符串会在我们的 UI 场景下用到。我们坚持一贯的做法，来为在屏幕上显示的所有 <code>StringRepresentable</code> 定义行为，给他们一个 <code>containerSize</code> 和 <code>containerFont</code> 用于计算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protocol StringDisplay &#123;</span><br><span class="line">    var containerSize: CGSize &#123; get &#125;</span><br><span class="line">    var containerFont: UIFont &#123; get &#125;</span><br><span class="line">    func assignString(str: String)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我建议只在协议中声明那些将会被接受者实现的方法。而将那些真正包含了功能的方法写在协议扩展中。<code>displayStringValue:</code> 决定会用到哪个字符串，并且将它传到有具体类型的 <code>assignString:</code> 方法中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">extension StringDisplay &#123;</span><br><span class="line">    func displayStringValue(obj: StringRepresentable) &#123;</span><br><span class="line">        &#x2F;&#x2F; Determine the longest string which can fit within the containerSize, then assign it.</span><br><span class="line">        if self.stringWithin(obj.longString) &#123;</span><br><span class="line">            self.assignString(obj.longString)</span><br><span class="line">        &#125; else if self.stringWithin(obj.mediumString) &#123;</span><br><span class="line">            self.assignString(obj.mediumString)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            self.assignString(obj.shortString)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - Helper Methods</span><br><span class="line">    </span><br><span class="line">    func sizeWithString(str: String) -&gt; CGSize &#123;</span><br><span class="line">        return (str as NSString).boundingRectWithSize(CGSizeMake(self.containerSize.width, .max),</span><br><span class="line">            options: .UsesLineFragmentOrigin,</span><br><span class="line">            attributes:  [NSFontAttributeName: self.containerFont],</span><br><span class="line">            context: nil).size</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private func stringWithin(str: String) -&gt; Bool &#123;</span><br><span class="line">        return self.sizeWithString(str).height &lt;&#x3D; self.containerSize.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们有了几个 <code>StringRepresentable</code> model 对象，当接受协议的时候，它们将会自动选择正确的字符串来使用。那么，如何才能正确的将其插入 UIKit ？</p><p>我们从 UILabel 开始，最简单的例子。传统的选择会是子类化 UILabel 并且接受协议，然后使用自定义的 UILabel 实例自动接受 <code>StringDisplay</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extension UILabel : StringDisplay &#123;</span><br><span class="line">    var containerSize: CGSize &#123; return self.frame.size &#125;</span><br><span class="line">    var containerFont: UIFont &#123; return self.font &#125;</span><br><span class="line">    func assignString(str: String) &#123;</span><br><span class="line">        self.text &#x3D; str</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那确实是他全部的代码了，我们可以让其他 UIKit 类也这样做，只是返回 <code>StringDisplay</code> 需要的数据来施展这个魔法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">extension UITableViewCell : StringDisplay &#123;</span><br><span class="line">    var containerSize: CGSize &#123; return self.textLabel!.frame.size &#125;</span><br><span class="line">    var containerFont: UIFont &#123; return self.textLabel!.font &#125;</span><br><span class="line">    func assignString(str: String) &#123;</span><br><span class="line">        self.textLabel!.text &#x3D; str</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension UIButton : StringDisplay &#123;</span><br><span class="line">    var containerSize: CGSize &#123; return self.frame.size&#125;</span><br><span class="line">    var containerFont: UIFont &#123; return self.titleLabel!.font &#125;</span><br><span class="line">    func assignString(str: String) &#123;</span><br><span class="line">        self.setTitle(str, forState: .Normal)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension UIViewController : StringDisplay &#123;</span><br><span class="line">    var containerSize: CGSize &#123; return self.navigationController!.navigationBar.frame.size &#125;</span><br><span class="line">    var containerFont: UIFont &#123; return UIFont(name: &quot;HelveticaNeue-Medium&quot;, size: 34.0)! &#125; &#x2F;&#x2F; default UINavigationBar title font</span><br><span class="line">    func assignString(str: String) &#123;</span><br><span class="line">        self.title &#x3D; str</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，在实践中这个看起来是什么样子的呢？我们声明一个 <code>Artist</code> 对象，他遵守了 <code>StringRepresentable</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; Artist()</span><br><span class="line">a.name &#x3D; &quot;Bob Marley&quot;</span><br><span class="line">a.instrument &#x3D; &quot;Guitar &#x2F; Vocals&quot;</span><br><span class="line">a.bio &#x3D; &quot;Every little thing&#39;s gonna be alright.&quot;</span><br><span class="line">Since all UIButton instances have been extended to adopt StringDisplay, we can call the displayStringValue: method on them.</span><br><span class="line"></span><br><span class="line">let smallButton &#x3D; UIButton(frame: CGRectMake(0.0, 0.0, 120.0, 40.0))</span><br><span class="line">smallButton.displayStringValue(a)</span><br><span class="line"></span><br><span class="line">print(smallButton.titleLabel!.text) &#x2F;&#x2F; &#39;Bob Marley&#39;</span><br><span class="line"></span><br><span class="line">let mediumButton &#x3D; UIButton(frame: CGRectMake(0.0, 0.0, 300.0, 40.0))</span><br><span class="line">mediumButton.displayStringValue(a)</span><br><span class="line"></span><br><span class="line">print(mediumButton.titleLabel!.text) &#x2F;&#x2F; &#39;Bob Marley (Guitar &#x2F; Vocals)&#39;</span><br></pre></td></tr></table></figure><p>按钮的标题现在显示出适合 frame 的字符串。</p><p>用户点击一个唱片，然后 push 一个 <code>AlbumDetailsViewController</code>。我们的协议能够判断导航栏标题的格式。因为我们的 <code>StringDisplay</code> 协议扩展，<code>UINavigationBar</code> 在 iPad 上面将会显示一个更长一点的字符串，而 iPhone上面会显示一个更短的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class AlbumDetailsViewController : UIViewController &#123;</span><br><span class="line">    var album: Album!</span><br><span class="line">    </span><br><span class="line">    override func viewWillAppear(animated: Bool) &#123;</span><br><span class="line">        super.viewWillAppear(animated)</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; Display the right string based on the nav bar width.</span><br><span class="line">        self.displayStringValue(self.album)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们保证所有对 model 中字符串格式化的操作都已经在统一的地方完成了，而且它们的显示也灵活地根据所使用的 UI 元素进行了相应的调整。这种模式在日后创建的 model 和各种各样的 UI 元素中都可以被复用。由于我们构建的协议具有灵活性，这种实现方式甚至可以被直接利用到无 UI 的环境中去。</p><h4 id="样式的协议（V）"><a href="#样式的协议（V）" class="headerlink" title="样式的协议（V）"></a>样式的协议（V）</h4><p>我们已经了解了协议扩展对于模型和字符串格式化所起的作用，现在我们看一下纯前端的例子，这将说明协议扩展是如何让 UI 开发变得更强大的。</p><p>我们可以把协议当作 CSS 的 classes 来看待，并使用它来定义 UIKit 对象的样式。然后，通过接受一个样式协议使对象的可视化的外观自动改变。</p><p>首先，我们定义一个基协议，这个协议表示一个样式化的实体，声明一个最终被用来使格式生效的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Any entity which supports protocol-based styling.</span><br><span class="line">protocol Styled &#123;</span><br><span class="line">    func updateStyles()</span><br><span class="line">&#125;</span><br><span class="line">Then we&#39;ll make some sub-protocols which define different types of styles we&#39;d like to use.</span><br><span class="line"></span><br><span class="line">protocol BackgroundColor : Styled &#123;</span><br><span class="line">    var color: UIColor &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol FontWeight : Styled &#123;</span><br><span class="line">    var size: CGFloat &#123; get &#125;</span><br><span class="line">    var bold: Bool &#123; get &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们创建了这些继承的样式，所以我们的接受者就不需要显式地这么做了。</p><p>现在我们要把特殊的样式分支出来，并且使用协议扩展返回真正的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protocol BackgroundColor_Purple : BackgroundColor &#123;&#125;</span><br><span class="line">extension BackgroundColor_Purple &#123;</span><br><span class="line">    var color: UIColor &#123; return UIColor.purpleColor() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol FontWeight_H1 : FontWeight &#123;&#125;</span><br><span class="line">extension FontWeight_H1 &#123;</span><br><span class="line">    var size: CGFloat &#123; return 24.0 &#125;</span><br><span class="line">    var bold: Bool &#123; return true &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，剩下的所有事情就是基于 UIKit 元素的类型实现 <code>updateStyles</code> 方法我们使用非泛型的扩展来让全部的 <code>UITableViewCell</code> 实例遵守 <code>Styled</code> 协议。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">extension UITableViewCell : Styled &#123;</span><br><span class="line">    func updateStyles() &#123;</span><br><span class="line">        if let s &#x3D; self as? BackgroundColor &#123;</span><br><span class="line">            self.backgroundColor &#x3D; s.color</span><br><span class="line">            self.textLabel?.textColor &#x3D; .whiteColor()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if let s &#x3D; self as? FontWeight &#123;</span><br><span class="line">            self.textLabel?.font &#x3D; (s.bold) ? UIFont.boldSystemFontOfSize(s.size) : UIFont.systemFontOfSize(s.size)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了确认 <code>updateStyles</code> 被自动的调用，可以在扩展中重写 <code>awakeFromNib</code> 方法。有兴趣的人可以了解下，这个重写本质上会被插入继承链中，好像扩展是 <code>UITableViewCell</code> 的直接子类。在一个 <code>UITableViewCell</code> 的子类中调用 <code>super</code> 现在等于直接调用了这个方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public override func awakeFromNib() &#123;</span><br><span class="line">        super.awakeFromNib()</span><br><span class="line">        self.updateStyles()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在当我们创建 cell 的时候，只要接受我们想要的协议就可以了！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class PurpleHeaderCell : UITableViewCell, BackgroundColor_Purple, FontWeight_H1 &#123;&#125;</span><br></pre></td></tr></table></figure><p>我已经在我们的 UIKit 元素上创建了一个类 CSS 的样式声明。我们甚至可以为 UIKit 山寨一个类似于 Bootstrap 的东西。这种实现在很多方面都有较大的提升，而且对于那些拥有很多界面元素并且样式是高度动态化的应用来说是很有价值的。</p><p>想象一个应用程序，有20个不同的视图控制器，每一个遵守2到3个共同的视觉风格。我们只需要使用样式协议，而不是强迫自己继承一个基类，或者使用不断增多的全局方法来配置我们的样式，采用的样式协议很有必要，这让我们更专注于对更重要细节的实现。</p><h2 id="有什么收获？"><a href="#有什么收获？" class="headerlink" title="有什么收获？"></a>有什么收获？</h2><p>到现在为止，我们已经做了很多有趣的事情，那么我们从使用协议和协议扩展的经验中收获了什么呢？可能会有人说，我们没必要去创建这协议。</p><p>面向协议的编程不能完美的适配所有基于 UI 的开发场景。</p><p>当我们向应用程序添加共享，通用的功能的时候，协议和协议的扩展通常是有价值的。此外，其价值在程序的组织结构上的体现胜过于功能上的体现。</p><p>数据类型越多，协议可能就会更加有效。无论何时，只要 UI 需要显示众多格式的信息，协议都可以带来很大的改善。但是这并不意味着我们仅仅为了实现一个现实艺人名字的紫色 cell 就要去使用6个协议和一堆扩展。</p><p>我们借助 Pear Music 的情况来看一下面向协议的实现是否变得更加重要。</p><h3 id="增加复杂度"><a href="#增加复杂度" class="headerlink" title="增加复杂度"></a>增加复杂度</h3><p>我们已经在 Pear Music 上工作了一段时间，而且我们的唱片，艺人，歌曲和播放列表有着很棒的 UI。我们仍然用着美妙的协议和扩展，让它们为 MVC 的所有层面上都提供着便捷。现在 Pear 的 CEO 已经要求我们着手构建2.0版本了…我们面临一个新奇的竞争对手的挑战，它叫 Apple Music。</p><p>我们需要一个非常酷的新特性来定义我们的产品，经过广泛的研究我们做了决定，这个特性就是长按预览功能。这很大胆，也很有革命性，Jony Ive 貌似已经在镜头前谈论这个。现在我们基于 UIKit 使用面向协议编程来实现它。</p><p>构建模态页面</p><p>以下讲述了它是如何运作的 —— 我们的用户长按一个艺人，唱片，歌曲或者是播放列表的时候一个有动画效果的模态视图会显示在屏幕上，从网络中载入图片并且显示这个项目的描述，另外还有一个分享到 Facebook 的按钮。</p><p>我们来构建这个将会在用户长按时模态显示的 <code>UIViewController</code>。只需要一些遵守了 <code>StringRepresentable</code> 和 <code>MediaResource</code> 协议的东西的帮助，我们在一开始就可以通过初始化方法实现通用化，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class PreviewController: UIViewController &#123;</span><br><span class="line">    @IBOutlet weak var descriptionLabel: UILabel!</span><br><span class="line">    @IBOutlet weak var imageView: UIImageView!</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; The main model object which we&#39;re displaying</span><br><span class="line">    var modelObject: protocol!</span><br><span class="line">    </span><br><span class="line">    init(previewObject: protocol) &#123;</span><br><span class="line">        self.modelObject &#x3D; previewObject</span><br><span class="line">    </span><br><span class="line">        super.init(nibName: &quot;PreviewController&quot;, bundle: NSBundle.mainBundle())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，使用内建的协议扩展方法来把数据传给 <code>descriptionLabel</code> 和 <code>imageView</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; Apply string representations to our label. Will use the string which fits into our descLabel.</span><br><span class="line">        self.descriptionLabel.displayStringValue(self.modelObject)</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; Load MediaResource image from the network if needed</span><br><span class="line">        if self.modelObject.imageValue &#x3D;&#x3D; nil &#123;</span><br><span class="line">            self.modelObject.loadMedia &#123; () -&gt; () in</span><br><span class="line">                self.imageView.image &#x3D; self.modelObject.imageValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            self.imageView.image &#x3D; self.modelObject.imageValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后，我们用相同的方法来获取可以通过 Facebook 分享的元数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Called when tapping the Facebook share button.</span><br><span class="line">    @IBAction func tapShareButton(sender: UIButton) &#123;</span><br><span class="line">        if SLComposeViewController.isAvailableForServiceType(SLServiceTypeFacebook) &#123;</span><br><span class="line">            let vc &#x3D; SLComposeViewController(forServiceType: SLServiceTypeFacebook)</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; Use StringRepresentable.shortString in the title</span><br><span class="line">            let post &#x3D; String(format: &quot;Check out %@ on Pear Music 2.0!&quot;, self.modelObject.shortString)</span><br><span class="line">            vc.setInitialText(post)</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; Use the MediaResource url to link to</span><br><span class="line">            let url &#x3D; String(self.modelObject.mediaURL)</span><br><span class="line">            vc.addURL(NSURL(string: url))</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; Add the entity&#39;s image</span><br><span class="line">            vc.addImage(self.modelObject.imageValue!);</span><br><span class="line">            </span><br><span class="line">            self.presentViewController(vc, animated: true, completion: nil)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用协议是我们受益匪浅 —— 没有他们的话，我们也许已经在 <code>PreviewController</code> 中为每一种需要接收的对象都做了初始化方法。使用基于协议的方法是我们极佳地保持了视图控制器的简洁，并且可以灵活的应对未来的实现。</p><p>我们已经造出了一个轻便的，简洁的 <code>PreviewController</code>，我们可以把艺人，唱片，歌曲，播放列表或者其他任何基于协议模式构建的模型传进去。 <code>PreviewController</code> 里面却不会有一行关于具体模型的代码！</p><h3 id="与第三方的代码整合"><a href="#与第三方的代码整合" class="headerlink" title="与第三方的代码整合"></a>与第三方的代码整合</h3><p>在构建 <code>PreviewController</code> 时，这是最后一个我们可以很好地应用协议和协议扩展的场景。我们整合了一个新的框架，这个框架可以为我们 app 中的音乐人加载对应的 Twitter 信息。我们想在主页显示推文列表，我们已经拿到了一个推文的 model 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class TweetObject &#123;</span><br><span class="line">    var favorite_count: Int!</span><br><span class="line">    var retweet_count: Int!</span><br><span class="line">    var text: String!</span><br><span class="line">    var user_name: String!</span><br><span class="line">    var profile_image_id: String!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们并不拥有这个代码，我们也无法修改 <code>TweetObject</code>，但是我们仍然希望我们的用户可以使用长按手势来预览推文，并且使用和 <code>PreviewController</code> 相同的UI。我们需要做的所有事情就是扩展它，让他接受我们现有的协议。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">extension TweetObject : StringRepresentable, MediaResource &#123;</span><br><span class="line">    &#x2F;&#x2F; MARK: - MediaResource</span><br><span class="line">    var mediaHost: String &#123; return &quot;api.twitter.com&quot; &#125;</span><br><span class="line">    var mediaPath: String &#123; return String(format: &quot;&#x2F;images&#x2F;%@&quot;, self.profile_image_id) &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; MARK: - StringRepresentable</span><br><span class="line">    var shortString: String &#123; return self.user_name &#125;</span><br><span class="line">    var mediumString: String &#123; return String(format: &quot;%@ (%d Retweets)&quot;, self.user_name, self.retweet_count) &#125;</span><br><span class="line">    var longString: String &#123; return String(format: &quot;%@ Wrote: %@&quot;, self.user_name, self.text) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以将一个 <code>TweetObject</code> 对象传给 <code>PreviewController</code> 了，甚至不需要它知道我们使用的是一个外部的框架！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let tweet &#x3D; TweetObject()</span><br><span class="line">let vc &#x3D; PreviewController(previewObject: tweet)</span><br></pre></td></tr></table></figure><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>在 WWDC 2015 上，苹果建议在以往需要用到类的地方去使用协议，但是我质疑这个规则忽视了协议扩展与那些重类的（class-heavy）的框架，比如 UIKit 一同使用时展现出的细节上的局限性。协议扩展只能在<br>它们本身具有广泛的使用性并且不需要支持传统代码的时候才会体现出真正的价值。尽管一些我提到的例子乍一听起来是微不足道的，但是当你的应用体积变的庞大而且逻辑变得复杂的时候，这种灵活的设计会变得极为有用。</p><p>这是个可以解释的代码的成本效益（cost-benefit）问题。在一个主要基于 UI 的应用中协议和扩展并不是总能占有一席之地。如果你只有一个页面并且页面上只要显示一种信息，这并不会带来什么改变，不要对它在协议的层面进行过度思考。但是如果你的应用对于同样的核心数据在不同的视觉状态，样式和表示上变换多样，使用协议和协议扩展作为你的数据和它的表现形式之间的桥梁是一个明智的方法，这么作将会在未来受益。</p><p>最后，我想把协议扩展称为一种通用的改变游戏规则的特性不如将其称为是一个在高精确度开发场景中的一种具有建设性的工具。还是那句话，我觉得任何开发者对面向协议的技术的尝试都是值得的 —— 如果你不在协议的层面重新调整现有代码，你将永远不会知道这么做的益处。广泛的使用它们吧。</p><p>如果你有任何疑问，或者你想和我探讨一些细节，给我发个 email 或者 在 Twitter 上直接找我！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;iOS-9-系列教程-在UIKit中实践面向协议编程&quot;&gt;&lt;a href=&quot;#iOS-9-系列教程-在UIKit中实践面向协议编程&quot; class=&quot;headerlink&quot; title=&quot;iOS 9 系列教程 在UIKit中实践面向协议编程&quot;&gt;&lt;/a&gt;iOS 9 系列教程 在UIKit中实践面向协议编程&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.captechconsulting.com/blogs/ios-9-tutorial-series-protocol-oriented-programming-with-uikit&quot;&gt;原文在此&lt;/a&gt; 翻译 by skyfly.xyz&lt;/p&gt;
&lt;p&gt;在 WWDC2015 上那次关于 Swift 面向协议编程的发人深省的演讲后（是的，“很难啃”的那部分）似乎每个人都在谈论协议扩展这个令人兴奋的新的语言特性，同时它也使每个人都感到过困惑。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://ufolux.github.io/categories/iOS/"/>
    
    
      <category term="iOS设计模式" scheme="https://ufolux.github.io/tags/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
